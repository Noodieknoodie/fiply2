######## docs/FIPLI_CORE_LOGIC.md ########
```
# FIPLI_CORE_LOGIC.md
# This document contains specific details about the core data model and calculation logic of the FIPLI project.
################ FIPLI: Core Data Model & Calculation Logic ################
## Household
- Person 1: First/Last Name, DOB (required)
- Person 2: First/Last Name, DOB (optional)
- Ability to select which person's DOB is used to determine the projection start year  
- Used for all year-based calculations  
- Manages multiple plans  
## Time Handling Principles
- DOB is the only true date input  
- All calculations reference absolute years internally  
- Conversion rules:  
  - DOB → Plan Creation Year: Determines the start year. Projections always begin in the year the plan was created, ensuring consistency across different plans and preventing shifting start points based on user age at different access times.
  - Years ↔ Age: Derived dynamically from DOB when needed  
  - Store values as entered by the user and convert as needed. aka "store what you know, convert in the backend"  
## Plans
- Each household → multiple plans  
- Each plan consists of:  
  1. Base Facts Aggregation  
  2. Scenarios  
  3. Projection  
**Base Facts Aggregation**  
## Asset Categories
- Customizable names (e.g., Qualified, Non-Qualified)  
- Assets can be assigned to categories  
- Categories for grouping/reporting only  
## Assets
- Value  
- Optional category assignment  
- Growth handling:  
  1. Default: Uses base assumption growth rate  
  2. Override: Asset-specific fixed rate  
  3. Stepwise: Multiple rates over time periods (start year / end year)  
  4. Gaps in stepwise fall to default  
- Optional inflation toggle  
## Liability Categories
- Customizable names (e.g., Personal, Business)  
- Liabilities can be assigned to categories  
- Categories for grouping/reporting only  
## Liabilities
- Value  
- Optional category assignment  
- Optional interest rate  
- Fixed value if no rate specified  
- No default growth rate usage, not affected by it  
## Scheduled Inflows/Outflows
- Start year, end year (stored as entered but converted as needed)  
- Amount  
- Optional inflation toggle  
- For discrete events only  
- Input in years  
- Examples: College (start year, end year different), inheritance (start year, end year the same)  
## Retirement Income
- Start year, end year  
- Amount  
- Optional inflation toggle  
- Input in absolute years (derived dynamically from selected person's retirement age)  
- For SS/Pension/Deferred Comp, etc.  
- Separate from scheduled inflows  
## Base Assumptions
- Default growth rate  
- Inflation rate  
- Retirement year (derived from selected retirement age)  
- End year (life expectancy year)
## Base Facts vs Scenarios
Base facts represent known financial components:
- Assets and their growth
- Liabilities and interest
- Scheduled cash flows (both inflows and outflows)
- Retirement income streams (Social Security, pensions)
Scenarios add withdrawal modeling:
- Annual retirement spending (how much can be safely withdrawn)
(Retirement Spending is a blanket withdrawal rate that begins at retirement and applies to the aggregated retirement nest egg portfolio, drawing from the combined pool of retirement-eligible assets and income streams rather than any specific account. This is only in Scenarios.)
- Always inflation-adjusted
- Starts at retirement year
- Common use: Finding maximum sustainable withdrawal rate
## Scenario System - Detailed Behavior
Scenarios provide a sandbox for "what-if" analysis. Each scenario:
1. Timeline Fundamentals
- Uses same projection timeline as the base plan (start/end years)
- This ensures all scenarios can be compared on the same charts
2. Inherits (with override capability):
- All assets with their values and growth configurations 
- All liabilities with their values and interest rates
- All scheduled cash flows with their amounts and timing
- All retirement income streams with their amounts and timing
- All base assumptions (growth rates, inflation)
3. Override Flexibility Examples:
- Asset/liability values
- Individual growth rate configurations (changing rate, start year, end year of stepwise periods)
- Cash flow amounts and timing
- Retirement income amounts and timing
- Default growth rate
- Inflation rate
- Retirement ages
4. Unique to Scenarios:
- Retirement spending amount (the aggregated portfolio withdrawal)
Important: Scenarios maintain maximum override flexibility while preserving the base plan's fundamental timeline. This allows for detailed "what-if" modeling while ensuring all scenarios can be meaningfully compared.
## Chart Projection
- Annual periods only  
- X-axis: Year-based (absolute years)  
- Y-axis: Portfolio value  
- Shows retirement nest egg  
- Not total net worth  
- Linear calculations only  
- No intra-year display  
- Dynamic updates on changes  
## Validation Philosophy
The system prevents impossible states (like overlapping periods) while allowing maximum flexibility for reasonable values. Timeline consistency is enforced architecturally rather than through validation.
## Core Validations
(This app is designed for maximum flexibility. Validations ensure logical consistency without unnecessary restrictions, allowing accurate and user-driven projections.)  
1. Date of birth must be a valid past date  
2. Retirement year must be after the start year  
3. End year must be after retirement year  
4. Start year must be before end year for inflows/outflows  
5. Stepwise growth periods must be in chronological order and not overlap  
6. Growth rate, inflation rate, and interest rate must be numeric and can be negative  
7. Assets, liabilities, scheduled inflows, scheduled outflows, retirement income, and retirement spending must be positive values  
8. Retirement spending cannot be negative  
## Annual Calculation Order
1. Start with prior year-end values  
2. Apply scheduled inflows (inflation-adjusted if enabled)  
3. Apply scheduled outflows (inflation-adjusted if enabled)  
4. Apply retirement income  
5. Apply retirement spending  
6. Apply growth rates to remaining balance:  
   - Asset-specific rates first  
   - Default rates to remaining  
7. Apply liability interest  
8. Calculate year-end total  
## Value Display Principles
- All values shown in current dollars  
- Inflation adjustments compound annually  
- Growth compounds annually  
- No partial year or day counting  
- No cash flow timing within year  
- All events assumed to occur at year boundaries  
- Portfolio values represent year-end totals  
These rules deliberately simplified for:  
- Clear user understanding  
- Consistent calculations  
- Predictable results  
- Easy scenario comparison  
- Linear projection model integrity  
# KEY TAKEAWAYS  
- **Core modeling choice:** No intra-year calculations, strictly linear projections. Ensures predictability and transparency.  
- **Scenario overrides:** Each scenario is a sandbox that inherits base facts but can override parameters, allowing flexible "what-if" planning, including max sustainable spend calculations.  
- **Growth rate system:** Assets can have default, fixed, or stepwise growth rates, while liabilities use an optional interest rate instead of growth rates.  
- **Time handling:** The system uses absolute years as the primary reference for calculations, while the database stores the user's original input and converts between formats as needed.  
- **Calculation flow:** A structured order ensures logical consistency, applying inflows, outflows, income, spending, growth, and liabilities sequentially.  
- **Validation rules:** Designed for flexibility while preventing illogical inputs, such as non-chronological stepwise growth periods or negative retirement spending.
```

######## docs/FIPLI_DB_SCHEMA.md ########
```
# FIPLI_DB_SCHEMA.md
# This document contains the schema preview for the FIPLI database.
################ FIPLI: DB Schema #################
DB File Path: backend\database_operations\database\fiply2_database.db
BEGIN TRANSACTION;
CREATE TABLE asset_categories (
    asset_category_id INTEGER PRIMARY KEY AUTOINCREMENT,
    plan_id INTEGER NOT NULL,
    category_name TEXT NOT NULL,
    category_order INTEGER DEFAULT 0,               -- For UI ordering
    FOREIGN KEY (plan_id) REFERENCES plans (plan_id) ON DELETE CASCADE
);
INSERT INTO "asset_categories" VALUES(1,1,'Real Estate',1);
INSERT INTO "asset_categories" VALUES(2,1,'Retirement Accounts',2);
INSERT INTO "asset_categories" VALUES(3,1,'Investments',3);
INSERT INTO "asset_categories" VALUES(4,2,'Tech Stocks',1);
INSERT INTO "asset_categories" VALUES(5,2,'Crypto',2);
INSERT INTO "asset_categories" VALUES(6,2,'Index Funds',3);
INSERT INTO "asset_categories" VALUES(7,2,'Real Estate',4);
INSERT INTO "asset_categories" VALUES(8,6,'International Real Estate',1);
INSERT INTO "asset_categories" VALUES(9,6,'Global Equities',2);
INSERT INTO "asset_categories" VALUES(10,6,'Cryptocurrency',3);
CREATE TABLE assets (
    asset_id INTEGER PRIMARY KEY AUTOINCREMENT,
    plan_id INTEGER NOT NULL,
    asset_category_id INTEGER NOT NULL,
    asset_name TEXT NOT NULL,
    owner TEXT NOT NULL,                           -- 'person1', 'person2', or 'joint'
    value REAL NOT NULL,                          -- Current value
    include_in_nest_egg INTEGER DEFAULT 1,        -- Include in retirement calculations
    FOREIGN KEY (plan_id) REFERENCES plans (plan_id) ON DELETE CASCADE,
    FOREIGN KEY (asset_category_id) REFERENCES asset_categories (asset_category_id) ON DELETE CASCADE
);
INSERT INTO "assets" VALUES(1,1,1,'Primary Residence','joint',750000.0,0);
INSERT INTO "assets" VALUES(2,1,2,'401(k)','person1',500000.0,1);
INSERT INTO "assets" VALUES(3,1,2,'IRA','person2',350000.0,1);
INSERT INTO "assets" VALUES(4,1,3,'Stock Portfolio','joint',250000.0,1);
INSERT INTO "assets" VALUES(5,2,4,'Tech Portfolio','person1',300000.0,1);
INSERT INTO "assets" VALUES(6,2,5,'Bitcoin Holdings','person1',150000.0,1);
INSERT INTO "assets" VALUES(7,2,6,'Total Market ETF','person1',500000.0,1);
CREATE TABLE base_assumptions (
    plan_id INTEGER PRIMARY KEY,
    retirement_age_1 INTEGER,                       -- Age-based: "Retire at 65"
    retirement_age_2 INTEGER,                       -- Age-based: "Retire at 65"
    final_age_1 INTEGER,                           -- Age-based: "Plan until 95"
    final_age_2 INTEGER,                           -- Age-based: "Plan until 95"
    final_age_selector INTEGER,                     -- Which person's final age to use (1 or 2)
    default_growth_rate REAL,                      -- Annual growth rate (e.g., 0.05 for 5%)
    inflation_rate REAL,                           -- Annual inflation rate (e.g., 0.03 for 3%)
    FOREIGN KEY (plan_id) REFERENCES plans (plan_id) ON DELETE CASCADE
);
INSERT INTO "base_assumptions" VALUES(1,65,67,95,95,1,0.06,0.028);
INSERT INTO "base_assumptions" VALUES(2,45,NULL,90,NULL,1,0.07,0.03);
INSERT INTO "base_assumptions" VALUES(3,65,65,90,95,2,0.05,0.029);
INSERT INTO "base_assumptions" VALUES(4,62,65,92,92,1,0.055,0.026);
INSERT INTO "base_assumptions" VALUES(5,62,65,92,92,1,0.055,0.026);
INSERT INTO "base_assumptions" VALUES(6,58,60,95,95,1,0.065,0.031);
CREATE TABLE growth_rate_configurations (
    growth_rate_id INTEGER PRIMARY KEY AUTOINCREMENT,
    asset_id INTEGER,                               -- Optional: if configuring asset growth
    retirement_income_plan_id INTEGER,              -- Optional: if configuring income growth
    scenario_id INTEGER,                            -- Optional: if scenario-specific
    configuration_type TEXT NOT NULL,               -- 'DEFAULT', 'OVERRIDE', or 'STEPWISE'
    start_year INTEGER NOT NULL,                    -- Year-based: Market projections by year
    end_year INTEGER,                               -- Year-based: Market projections by year
    growth_rate REAL NOT NULL,                      -- Annual rate
    FOREIGN KEY (asset_id)
        REFERENCES assets (asset_id) ON DELETE CASCADE,
    FOREIGN KEY (retirement_income_plan_id)
        REFERENCES retirement_income_plans (income_plan_id) ON DELETE CASCADE,
    FOREIGN KEY (scenario_id)
        REFERENCES scenarios (scenario_id) ON DELETE CASCADE
);
INSERT INTO "growth_rate_configurations" VALUES(1,2,NULL,NULL,'OVERRIDE',2024,NULL,0.07);
INSERT INTO "growth_rate_configurations" VALUES(2,3,NULL,NULL,'OVERRIDE',2024,NULL,0.065);
INSERT INTO "growth_rate_configurations" VALUES(3,4,NULL,NULL,'STEPWISE',2024,2026,0.08);
INSERT INTO "growth_rate_configurations" VALUES(4,4,NULL,NULL,'STEPWISE',2027,2030,0.06);
INSERT INTO "growth_rate_configurations" VALUES(5,5,NULL,NULL,'STEPWISE',2024,2025,0.15);
INSERT INTO "growth_rate_configurations" VALUES(6,5,NULL,NULL,'STEPWISE',2026,2027,0.1);
CREATE TABLE households (
    household_id INTEGER PRIMARY KEY AUTOINCREMENT,
    household_name TEXT NOT NULL,
    person1_first_name TEXT NOT NULL,
    person1_last_name TEXT NOT NULL,
    person1_dob DATE NOT NULL,                      -- Full date for precise calculations
    person2_first_name TEXT,
    person2_last_name TEXT,
    person2_dob DATE,                               -- Full date for precise calculations
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
INSERT INTO "households" VALUES(1,'Test Household A','John','Smith','1970-05-15','Jane','Smith','1972-08-23','2025-01-28 05:52:00','2025-01-28 05:52:00');
INSERT INTO "households" VALUES(2,'Test Household B','Sarah','Johnson','1985-03-20',NULL,NULL,NULL,'2025-01-28 05:52:46','2025-01-28 05:52:46');
INSERT INTO "households" VALUES(3,'Test Household C','Robert','Miller','1960-08-10','Emma','Miller','1980-12-15','2025-01-28 05:58:02','2025-01-28 05:58:02');
INSERT INTO "households" VALUES(4,'Test Household D','Michael','Anderson','1965-11-22','Lisa','Anderson','1966-03-15','2025-01-28 06:13:37','2025-01-28 06:13:37');
INSERT INTO "households" VALUES(5,'Test Household E','David','Wilson','1975-04-30','Maria','Wilson','1978-09-12','2025-01-28 06:14:35','2025-01-28 06:14:35');
CREATE TABLE inflows_outflows (
    inflow_outflow_id INTEGER PRIMARY KEY AUTOINCREMENT,
    plan_id INTEGER NOT NULL,
    type TEXT NOT NULL,                           -- 'inflow' or 'outflow'
    name TEXT NOT NULL,
    owner TEXT NOT NULL,                          -- 'person1', 'person2', or 'joint'
    annual_amount REAL NOT NULL,
    start_year INTEGER NOT NULL,                  -- Year-based: "Inheritance in 2025"
    end_year INTEGER,                             -- Year-based: "Until 2030"
    apply_inflation INTEGER DEFAULT 0,            -- Should amount inflate over time?
    FOREIGN KEY (plan_id) REFERENCES plans (plan_id) ON DELETE CASCADE
);
INSERT INTO "inflows_outflows" VALUES(1,1,'inflow','Salary Person 1','person1',120000.0,2024,2029,1);
INSERT INTO "inflows_outflows" VALUES(2,1,'inflow','Salary Person 2','person2',95000.0,2024,2031,1);
INSERT INTO "inflows_outflows" VALUES(3,1,'outflow','Property Tax','joint',8500.0,2024,NULL,1);
INSERT INTO "inflows_outflows" VALUES(4,2,'inflow','Tech Job Salary','person1',180000.0,2024,2030,1);
INSERT INTO "inflows_outflows" VALUES(5,2,'inflow','Rental Income','person1',36000.0,2024,NULL,1);
INSERT INTO "inflows_outflows" VALUES(6,2,'inflow','Side Consulting','person1',25000.0,2024,2026,0);
CREATE TABLE liabilities (
    liability_id INTEGER PRIMARY KEY AUTOINCREMENT,
    plan_id INTEGER NOT NULL,
    liability_category_id INTEGER NOT NULL,
    liability_name TEXT NOT NULL,
    owner TEXT NOT NULL,                           -- 'person1', 'person2', or 'joint'
    value REAL NOT NULL,                          -- Current value
    interest_rate REAL,                           -- Annual interest rate
    include_in_nest_egg INTEGER DEFAULT 1,        -- Include in retirement calculations
    FOREIGN KEY (plan_id) REFERENCES plans (plan_id) ON DELETE CASCADE,
    FOREIGN KEY (liability_category_id) REFERENCES liability_categories (liability_category_id) ON DELETE CASCADE
);
INSERT INTO "liabilities" VALUES(1,1,1,'Home Mortgage','joint',450000.0,0.0375,1);
INSERT INTO "liabilities" VALUES(2,1,2,'Car Loan','person1',35000.0,0.0425,1);
INSERT INTO "liabilities" VALUES(3,2,3,'Rental Property Mortgage','person1',300000.0,0.0425,1);
INSERT INTO "liabilities" VALUES(4,2,4,'Investment Line of Credit','person1',50000.0,0.065,1);
CREATE TABLE liability_categories (
    liability_category_id INTEGER PRIMARY KEY AUTOINCREMENT,
    plan_id INTEGER NOT NULL,
    category_name TEXT NOT NULL,
    category_order INTEGER DEFAULT 0,               -- For UI ordering
    FOREIGN KEY (plan_id) REFERENCES plans (plan_id) ON DELETE CASCADE
);
INSERT INTO "liability_categories" VALUES(1,1,'Mortgages',1);
INSERT INTO "liability_categories" VALUES(2,1,'Personal Loans',2);
INSERT INTO "liability_categories" VALUES(3,2,'Investment Property Loans',1);
INSERT INTO "liability_categories" VALUES(4,2,'Credit Lines',2);
INSERT INTO "liability_categories" VALUES(5,6,'International Mortgages',1);
INSERT INTO "liability_categories" VALUES(6,6,'Business Loans',2);
CREATE TABLE plans (
    plan_id INTEGER PRIMARY KEY AUTOINCREMENT,
    household_id INTEGER NOT NULL,
    plan_name TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP, reference_person INTEGER NOT NULL DEFAULT 1, plan_creation_year INTEGER,
    FOREIGN KEY (household_id) REFERENCES households (household_id) ON DELETE CASCADE
);
INSERT INTO "plans" VALUES(1,1,'Base Retirement Plan','2025-01-28 05:52:00','2025-01-28 05:52:00',1,NULL);
INSERT INTO "plans" VALUES(2,2,'FIRE Strategy Plan','2025-01-28 05:52:46','2025-01-28 05:52:46',1,NULL);
INSERT INTO "plans" VALUES(3,2,'FIRE Strategy Plan','2025-01-28 05:53:31','2025-01-28 05:53:31',1,NULL);
INSERT INTO "plans" VALUES(4,3,'Staggered Retirement Plan','2025-01-28 05:58:02','2025-01-28 05:58:02',1,NULL);
INSERT INTO "plans" VALUES(5,4,'Pension Optimization Plan','2025-01-28 06:13:37','2025-01-28 06:13:37',1,NULL);
INSERT INTO "plans" VALUES(6,5,'International Retirement Plan','2025-01-28 06:14:35','2025-01-28 06:14:35',1,NULL);
CREATE TABLE retirement_income_plans (
    income_plan_id INTEGER PRIMARY KEY AUTOINCREMENT,
    plan_id INTEGER NOT NULL,
    name TEXT NOT NULL,
    owner TEXT NOT NULL,                          -- 'person1', 'person2', or 'joint'
    annual_income REAL NOT NULL,
    start_age INTEGER NOT NULL,                   -- Age-based: "Social Security at 67"
    end_age INTEGER,                              -- Age-based: "Pension until 85"
    include_in_nest_egg INTEGER DEFAULT 1,        -- Include in retirement calculations
    FOREIGN KEY (plan_id) REFERENCES plans (plan_id) ON DELETE CASCADE
);
INSERT INTO "retirement_income_plans" VALUES(1,1,'Social Security','person1',32000.0,67,NULL,1);
INSERT INTO "retirement_income_plans" VALUES(2,1,'Pension','person2',45000.0,65,NULL,1);
INSERT INTO "retirement_income_plans" VALUES(3,2,'Social Security','person1',28000.0,67,NULL,1);
INSERT INTO "retirement_income_plans" VALUES(4,2,'Rental Income Stream','person1',36000.0,45,NULL,1);
INSERT INTO "retirement_income_plans" VALUES(5,5,'Corporate Pension','person1',65000.0,62,NULL,1);
INSERT INTO "retirement_income_plans" VALUES(6,5,'State Pension','person2',42000.0,65,NULL,1);
CREATE TABLE scenario_assumptions (
    scenario_id INTEGER PRIMARY KEY,
    retirement_age_1 INTEGER,                       -- Age-based: Retirement planning is age-focused
    retirement_age_2 INTEGER,                       -- Age-based: Retirement planning is age-focused
    default_growth_rate REAL,                      -- Annual rate
    inflation_rate REAL,                           -- Annual rate
    annual_retirement_spending REAL,                -- Amount
    FOREIGN KEY (scenario_id) REFERENCES scenarios (scenario_id) ON DELETE CASCADE
);
INSERT INTO "scenario_assumptions" VALUES(1,60,62,0.055,0.03,85000.0);
INSERT INTO "scenario_assumptions" VALUES(2,67,69,0.045,0.025,75000.0);
INSERT INTO "scenario_assumptions" VALUES(3,43,NULL,0.08,0.032,100000.0);
INSERT INTO "scenario_assumptions" VALUES(4,47,NULL,0.05,0.028,80000.0);
INSERT INTO "scenario_assumptions" VALUES(5,45,NULL,0.065,0.03,90000.0);
CREATE TABLE scenario_overrides (
    override_id INTEGER PRIMARY KEY AUTOINCREMENT,
    scenario_id INTEGER NOT NULL,
    asset_id INTEGER,                               -- Optional: if overriding an asset
    liability_id INTEGER,                           -- Optional: if overriding a liability
    inflow_outflow_id INTEGER,                      -- Optional: if overriding a cash flow
    retirement_income_plan_id INTEGER,              -- Optional: if overriding retirement income
    override_field TEXT NOT NULL,                   -- Field being overridden
    override_value TEXT NOT NULL,                   -- New value (matches source table's format)
    FOREIGN KEY (scenario_id) 
        REFERENCES scenarios (scenario_id) ON DELETE CASCADE,
    FOREIGN KEY (asset_id) 
        REFERENCES assets (asset_id) ON DELETE CASCADE,
    FOREIGN KEY (liability_id) 
        REFERENCES liabilities (liability_id) ON DELETE CASCADE,
    FOREIGN KEY (inflow_outflow_id) 
        REFERENCES inflows_outflows (inflow_outflow_id) ON DELETE CASCADE,
    FOREIGN KEY (retirement_income_plan_id)
        REFERENCES retirement_income_plans (income_plan_id) ON DELETE CASCADE
);
INSERT INTO "scenario_overrides" VALUES(1,1,2,NULL,NULL,NULL,'value','600000');
INSERT INTO "scenario_overrides" VALUES(2,2,4,NULL,NULL,NULL,'remove','TRUE');
INSERT INTO "scenario_overrides" VALUES(3,3,5,NULL,NULL,NULL,'value','400000');
INSERT INTO "scenario_overrides" VALUES(4,3,6,NULL,NULL,NULL,'remove','TRUE');
INSERT INTO "scenario_overrides" VALUES(5,4,5,NULL,NULL,NULL,'value','200000');
CREATE TABLE scenarios (
    scenario_id INTEGER PRIMARY KEY AUTOINCREMENT,
    plan_id INTEGER NOT NULL,
    scenario_name TEXT NOT NULL,
    scenario_color TEXT,                            -- For UI visualization
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (plan_id) REFERENCES plans (plan_id) ON DELETE CASCADE
);
INSERT INTO "scenarios" VALUES(1,1,'Early Retirement','#FF5733','2025-01-28 05:52:00');
INSERT INTO "scenarios" VALUES(2,1,'Conservative Growth','#33FF57','2025-01-28 05:52:00');
INSERT INTO "scenarios" VALUES(3,2,'Ultra Aggressive','#FF0000','2025-01-28 05:52:46');
INSERT INTO "scenarios" VALUES(4,2,'Market Correction','#0000FF','2025-01-28 05:52:46');
INSERT INTO "scenarios" VALUES(5,2,'Balanced Approach','#00FF00','2025-01-28 05:52:46');
INSERT INTO "scenarios" VALUES(6,5,'Early Pension Take','#4B0082','2025-01-28 06:13:37');
INSERT INTO "scenarios" VALUES(7,5,'Delayed Social Security','#800000','2025-01-28 06:13:37');
INSERT INTO "scenarios" VALUES(8,5,'Hybrid Approach','#006400','2025-01-28 06:13:37');
CREATE INDEX idx_households_name ON households (household_name);
CREATE INDEX idx_plans_household_id ON plans (household_id);
CREATE INDEX idx_scenarios_plan_id ON scenarios (plan_id);
CREATE INDEX idx_scenario_overrides_scenario_id ON scenario_overrides (scenario_id);
CREATE INDEX idx_scenario_overrides_asset_id ON scenario_overrides (asset_id);
CREATE INDEX idx_scenario_overrides_liability_id ON scenario_overrides (liability_id);
CREATE INDEX idx_scenario_overrides_inflow_outflow_id ON scenario_overrides (inflow_outflow_id);
CREATE INDEX idx_scenario_overrides_rip_id ON scenario_overrides (retirement_income_plan_id);
CREATE INDEX idx_asset_categories_plan_id ON asset_categories (plan_id);
CREATE INDEX idx_assets_plan_id ON assets (plan_id);
CREATE INDEX idx_assets_category_id ON assets (asset_category_id);
CREATE INDEX idx_liability_categories_plan_id ON liability_categories (plan_id);
CREATE INDEX idx_liabilities_plan_id ON liabilities (plan_id);
CREATE INDEX idx_liabilities_category_id ON liabilities (liability_category_id);
CREATE INDEX idx_inflows_outflows_plan_id ON inflows_outflows (plan_id);
CREATE INDEX idx_inflows_outflows_type ON inflows_outflows (type);
CREATE INDEX idx_inflows_outflows_years ON inflows_outflows (start_year, end_year);
CREATE INDEX idx_retirement_income_plans_plan_id ON retirement_income_plans (plan_id);
CREATE INDEX idx_growth_rate_configurations_asset_id ON growth_rate_configurations (asset_id);
CREATE INDEX idx_growth_rate_configurations_rip_id ON growth_rate_configurations (retirement_income_plan_id);
CREATE INDEX idx_growth_rate_configurations_scenario_id ON growth_rate_configurations (scenario_id);
CREATE INDEX idx_growth_rate_configurations_years ON growth_rate_configurations (start_year, end_year);
DELETE FROM "sqlite_sequence";
INSERT INTO "sqlite_sequence" VALUES('households',5);
INSERT INTO "sqlite_sequence" VALUES('plans',6);
INSERT INTO "sqlite_sequence" VALUES('scenarios',8);
INSERT INTO "sqlite_sequence" VALUES('asset_categories',10);
INSERT INTO "sqlite_sequence" VALUES('inflows_outflows',6);
INSERT INTO "sqlite_sequence" VALUES('retirement_income_plans',6);
INSERT INTO "sqlite_sequence" VALUES('assets',7);
INSERT INTO "sqlite_sequence" VALUES('liability_categories',6);
INSERT INTO "sqlite_sequence" VALUES('liabilities',4);
INSERT INTO "sqlite_sequence" VALUES('growth_rate_configurations',6);
INSERT INTO "sqlite_sequence" VALUES('scenario_overrides',5);
COMMIT;
```

######## docs/FIPLI_FILE_HIERARCHY.md ########
```
fiply2/
backend/
    main.py
    requirements.txt
    database_operations/
        connection.py
        models.py
        schema.sql
        __init__.py
        calculations/
            scenario_calcs.py
            __init__.py
            base_facts/
                assets_calcs.py
                base_facts_calcs.py
                cash_flows_calcs.py
                growth_handler_calcs.py
                liabilities_calcs.py
                retirement_income_calcs.py
                __init__.py
                base_facts_utils/
            scenario/
                scenario_utils/
        crud/
            base_assumptions_crud.py
            households_crud.py
            plans_crud.py
            scenarios_crud.py
            __init__.py
            financial/
                assets_crud.py
                cash_flows_crud.py
                growth_rates_crud.py
                liabilities_crud.py
                retirement_income_crud.py
                __init__.py
        database/
            fiply2_database.db
            schema.sql
        tests/
            conftest.py
            test_crud_operations.py
            test_growth_calculations.py
            test_growth_configurations.py
            test_retirement_calculations.py
            test_scenario_calculations.py
            test_scenario_creation.py
            test_timeline_validations.py
            test_time_handeling.py
            __init__.py
            database_tests/
            fixtures/
            util_tests/
        utils/
            money_utils.py
            time_utils.py
            __init__.py
        validation/
            growth_validation.py
            money_validation.py
            scenario_timeline_validation.py
            time_validation.py
IGNORE/
    compile.py
    hierarchy.py
    schema.py
    stripcomments.py
    IGNORE/
        txt_files/
            backend_combined.txt
            docs_combined.txt
            tests_combined.txt
    txt_files/
```

######## docs/FIPLI_PROJECT_OVERVIEW.md ########
```
# FIPLI_PROJECT_OVERVIEW.md
# This document is a high-level overview of the FIPLI project
################ FIPLI: System Overview & Core Modeling #################
# Core Purpose & High-Level Overview
Fipli is a streamlined financial planning projection system implementing deterministic linear modeling. Conceptually, it's similar to eMoney or MoneyGuidePro, but with an intentionally simplified computational model. While the original prototype was built in Excel, the current implementation uses Python for computational logic and SQL for data persistence, though the core algorithms could be implemented in either environment. Fipli is optimized for scenario analysis and comparative projection modeling rather than granular financial planning - we explicitly exclude tax implications, withdrawal sequencing, and other complexities typically found in comprehensive financial planning tools.
# The Fundamental Visualization
The core visualization model is a line graph where the Y-axis represents portfolio value in dollars and the X-axis tracks time progression in years. The X-axis is structured around absolute years (e.g., 2025, 2026, 2027) rather than relative age. However, since age is directly tied to the selected start year and date of birth, projections maintain full compatibility with both age-based and year-based perspectives. The tick marks represent annual periods, initiating from the year the plan was created, ensuring a fixed and consistent starting point for projections. The fundamental design principle is strict adherence to annual-period linear projections - we explicitly avoid any intra-year calculations or display granularity. The line itself represents the projected retirement portfolio value - specifically the retirement nest egg, not total net worth.
# Data Model Foundation
The composition of this nest egg is determined through a structured set of user-defined inputs. These inputs encompass several core data entities: assets, liabilities, scheduled inflows, scheduled outflows, and retirement income streams. Each of these entities can be organized into user-defined classification buckets - for instance, assets might be categorized as qualified or non-qualified, while liabilities might be grouped into personal or business categories. The system is governed by a set of base parameters called base facts, which include the default growth rate, inflation rate, and time period boundaries (start, retirement, and end points expressed in absolute years). It's important to note that retirement spending, while central to the analysis, is intentionally excluded from these base facts.
# Growth Rate System
The growth rate system in Fipli is particularly sophisticated. The base facts establish a default growth rate, but individual assets can override this in several ways. An asset can have a simple growth rate override - useful for assigning different returns to different investment types, like setting a higher growth rate for an aggressive equity portfolio. For more complex projections, assets can use stepwise growth rate overrides, where different rates apply during different time periods. When using stepwise overrides, any time periods not explicitly covered default back to the scenario's (or base facts') default growth rate. Liabilities follow a different model - they don't participate in the default growth rate system at all, instead having an optional interest rate parameter that, if specified, determines liability growth. Inflation adjustments can be toggled for various inputs, including scheduled inflows, scheduled outflows, and retirement income streams. When enabled, these values are adjusted before they are applied in the annual calculations. When enabled, these values are automatically adjusted using the inflation rate specified in either the base facts or scenario assumptions.
# Scenario System
Each scenario begins as a clone of the base facts, creating a sandbox for "what-if" analysis. While scenarios inherit all base fact parameters, they can independently override any of these values. What makes scenarios particularly powerful is their unique retirement spending parameter - an inflation-adjusted annual outflow that begins at retirement and continues through the final projection year. To clarify the distinction between scheduled flows and retirement spending: the scheduled inflows and outflows in the base facts are meant for modeling discrete events like education expenses or inheritance receipts. This allows users to quickly test different spending levels against their base assumptions. Often, users will use scenarios to solve for maximum sustainable spending - essentially finding the spending level that depletes the portfolio exactly at the final projection year - but the tool supports any arbitrary spending pattern.
# Business Logic & Calculations
The business logic enforces consistent date handling throughout the system. We follow a "enter what you know, calculate what you need" principle. Users enter their date of birth, and the system derives their current age dynamically. However, all projections and calculations are stored in absolute years to maintain a unified and consistent timeline. The system ensures full interchangeability between age and year for all inputs, calculations, and visualizations. Users can input values using either format, and the system dynamically converts between them as needed. Scheduled inflows and outflows are expressed in years, while retirement income streams default to age-based inputs, as retirement benefits typically trigger at specific ages. All calculations happen dynamically, with the system aggregating assets, applying growth rates, processing scheduled flows, and computing portfolio values in a way that maintains consistency with standard financial planning practices while keeping the computational model straightforward and deterministic.​​​​​​​​​​​​​​​​
```

######## backend/main.py ########
```
"""
Main entry point for the FIPLI application.
This file handles initialization of core components like the database.
"""
from database_operations.connection import init_database, get_session
def initialize_application():
    """Initialize all required components of the application."""
    print("Initializing FIPLI application...")
    # Initialize the database first
    print("Initializing database...")
    engine = init_database()
    print("Database initialized successfully!")
    return engine
def main():
    """Main entry point of the application."""
    try:
        engine = initialize_application()
        # At this point, the database is initialized and ready to use
        # You can add more startup logic here as needed
        print("FIPLI application started successfully!")
        return engine
    except Exception as e:
        print(f"Error starting application: {str(e)}")
        raise
if __name__ == "__main__":
    # This means "only run this if you're running this file directly"
    main() 
```

######## backend/database_operations/connection.py ########
```
# backend\database_operations\connection.py
from pathlib import Path
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session
from sqlalchemy.engine import Engine
from sqlalchemy.pool import StaticPool
from .models import init_tables
# Get the absolute path to the database file
DB_PATH = Path(__file__).parent / "database" / "fiply2_database.db"
# Global engine instance
_engine = None
def init_database() -> Engine:
    """Initialize the database engine and tables. Call this once when your application starts."""
    global _engine
    if _engine is None:
        # Create database directory if it doesn't exist
        DB_PATH.parent.mkdir(parents=True, exist_ok=True)
        # Create SQLite database engine with 2.0 style
        _engine = create_engine(
            f"sqlite:///{DB_PATH}",
            echo=False,  # Set to True for SQL query logging
            future=True,  # Use SQLAlchemy 2.0 style
            poolclass=StaticPool,  # Better for SQLite
            connect_args={"check_same_thread": False}  # Allow multi-threading for SQLite
        )
        # Initialize tables
        init_tables(_engine)
    return _engine
def get_engine() -> Engine:
    """Get the database engine. Make sure init_database() was called first."""
    global _engine
    if _engine is None:
        raise RuntimeError("Database not initialized. Call init_database() first.")
    return _engine
def get_session() -> Session:
    """Create and return a new database session."""
    engine = get_engine()  # This will raise an error if init_database() wasn't called
    # 2.0 style session creation
    SessionLocal = sessionmaker(
        bind=engine,
        autocommit=False,
        autoflush=False,
        future=True  # Use 2.0 style
    )
    return SessionLocal()
```

######## backend/database_operations/models.py ########
```
# backend\database_operations\models.py
from datetime import datetime, date
from typing import Optional, List
from sqlalchemy import Integer, String, Float, Date, DateTime, ForeignKey, Text, Boolean
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship
from sqlalchemy.ext.asyncio import AsyncAttrs
class Base(AsyncAttrs, DeclarativeBase):
    """Base class for all SQLAlchemy models."""
    pass
class Household(Base):
    """Represents a household in the financial planning system."""
    __tablename__ = "households"
    household_id: Mapped[int] = mapped_column(Integer, primary_key=True)
    household_name: Mapped[str] = mapped_column(Text, nullable=False)
    person1_first_name: Mapped[str] = mapped_column(Text, nullable=False)
    person1_last_name: Mapped[str] = mapped_column(Text, nullable=False)
    person1_dob: Mapped[date] = mapped_column(Date, nullable=False)
    person2_first_name: Mapped[Optional[str]] = mapped_column(Text)
    person2_last_name: Mapped[Optional[str]] = mapped_column(Text)
    person2_dob: Mapped[Optional[date]] = mapped_column(Date)
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.now)
    updated_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.now, onupdate=datetime.now)
    plans: Mapped[List["Plan"]] = relationship(back_populates="household", cascade="all, delete-orphan")
class Plan(Base):
    """Financial plan model."""
    __tablename__ = "plans"
    plan_id: Mapped[int] = mapped_column(Integer, primary_key=True)
    household_id: Mapped[int] = mapped_column(ForeignKey("households.household_id", ondelete="CASCADE"), nullable=False)
    plan_name: Mapped[str] = mapped_column(Text, nullable=False)
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.now)
    updated_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.now, onupdate=datetime.now)
    reference_person: Mapped[int] = mapped_column(Integer, nullable=False, default=1)
    plan_creation_year: Mapped[Optional[int]] = mapped_column(Integer)
    # Relationships
    household: Mapped["Household"] = relationship("Household", back_populates="plans")
    base_assumptions: Mapped[Optional["BaseAssumption"]] = relationship(
        back_populates="plan", 
        uselist=False,
        cascade="all, delete-orphan"
    )
    scenarios: Mapped[List["Scenario"]] = relationship(
        back_populates="plan",
        cascade="all, delete-orphan"
    )
    asset_categories: Mapped[List["AssetCategory"]] = relationship(
        back_populates="plan", 
        cascade="all, delete-orphan"
    )
    liability_categories: Mapped[List["LiabilityCategory"]] = relationship(
        back_populates="plan", 
        cascade="all, delete-orphan"
    )
    assets: Mapped[List["Asset"]] = relationship(
        back_populates="plan", 
        cascade="all, delete-orphan"
    )
    liabilities: Mapped[List["Liability"]] = relationship(
        back_populates="plan", 
        cascade="all, delete-orphan"
    )
    inflows_outflows: Mapped[List["InflowOutflow"]] = relationship(
        back_populates="plan", 
        cascade="all, delete-orphan"
    )
    retirement_income_plans: Mapped[List["RetirementIncomePlan"]] = relationship(
        back_populates="plan", 
        cascade="all, delete-orphan"
    )
class BaseAssumption(Base):
    """Stores global assumptions for a plan."""
    __tablename__ = "base_assumptions"
    plan_id: Mapped[int] = mapped_column(ForeignKey("plans.plan_id", ondelete="CASCADE"), primary_key=True)
    retirement_age_1: Mapped[Optional[int]] = mapped_column(Integer)
    retirement_age_2: Mapped[Optional[int]] = mapped_column(Integer)
    final_age_1: Mapped[Optional[int]] = mapped_column(Integer)
    final_age_2: Mapped[Optional[int]] = mapped_column(Integer)
    final_age_selector: Mapped[Optional[int]] = mapped_column(Integer)
    default_growth_rate: Mapped[Optional[float]] = mapped_column(Float)
    inflation_rate: Mapped[Optional[float]] = mapped_column(Float)
    plan: Mapped["Plan"] = relationship("Plan", back_populates="base_assumptions")
class Scenario(Base):
    """Represents a what-if scenario for a plan."""
    __tablename__ = "scenarios"
    scenario_id: Mapped[int] = mapped_column(Integer, primary_key=True)
    plan_id: Mapped[int] = mapped_column(ForeignKey("plans.plan_id", ondelete="CASCADE"), nullable=False)
    scenario_name: Mapped[str] = mapped_column(Text, nullable=False)
    scenario_color: Mapped[Optional[str]] = mapped_column(Text)
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.now)
    plan: Mapped["Plan"] = relationship("Plan", back_populates="scenarios")
    assumptions: Mapped[Optional["ScenarioAssumption"]] = relationship(
        back_populates="scenario", 
        uselist=False,
        cascade="all, delete-orphan"
    )
    overrides: Mapped[List["ScenarioOverride"]] = relationship(
        back_populates="scenario", 
        cascade="all, delete-orphan"
    )
    growth_rates: Mapped[List["GrowthRateConfiguration"]] = relationship(
        back_populates="scenario", 
        cascade="all, delete-orphan"
    )
class ScenarioAssumption(Base):
    """Stores scenario-specific assumptions."""
    __tablename__ = "scenario_assumptions"
    scenario_id: Mapped[int] = mapped_column(ForeignKey("scenarios.scenario_id", ondelete="CASCADE"), primary_key=True)
    retirement_age_1: Mapped[Optional[int]] = mapped_column(Integer)
    retirement_age_2: Mapped[Optional[int]] = mapped_column(Integer)
    default_growth_rate: Mapped[Optional[float]] = mapped_column(Float)
    inflation_rate: Mapped[Optional[float]] = mapped_column(Float)
    annual_retirement_spending: Mapped[Optional[float]] = mapped_column(Float)
    scenario: Mapped["Scenario"] = relationship("Scenario", back_populates="assumptions")
class ScenarioOverride(Base):
    """Stores granular overrides for financial components within scenarios."""
    __tablename__ = "scenario_overrides"
    override_id: Mapped[int] = mapped_column(Integer, primary_key=True)
    scenario_id: Mapped[int] = mapped_column(ForeignKey("scenarios.scenario_id", ondelete="CASCADE"), nullable=False)
    asset_id: Mapped[Optional[int]] = mapped_column(ForeignKey("assets.asset_id", ondelete="CASCADE"))
    liability_id: Mapped[Optional[int]] = mapped_column(ForeignKey("liabilities.liability_id", ondelete="CASCADE"))
    inflow_outflow_id: Mapped[Optional[int]] = mapped_column(ForeignKey("inflows_outflows.inflow_outflow_id", ondelete="CASCADE"))
    retirement_income_plan_id: Mapped[Optional[int]] = mapped_column(ForeignKey("retirement_income_plans.income_plan_id", ondelete="CASCADE"))
    override_field: Mapped[str] = mapped_column(Text, nullable=False)
    override_value: Mapped[str] = mapped_column(Text, nullable=False)
    scenario = relationship("Scenario", back_populates="overrides")
    asset = relationship("Asset", back_populates="overrides")
    liability = relationship("Liability", back_populates="overrides")
    inflow_outflow = relationship("InflowOutflow", back_populates="overrides")
    retirement_income_plan = relationship("RetirementIncomePlan", back_populates="overrides")
class AssetCategory(Base):
    """Represents categories for organizing assets."""
    __tablename__ = "asset_categories"
    asset_category_id: Mapped[int] = mapped_column(Integer, primary_key=True)
    plan_id: Mapped[int] = mapped_column(ForeignKey("plans.plan_id", ondelete="CASCADE"), nullable=False)
    category_name: Mapped[str] = mapped_column(Text, nullable=False)
    category_order: Mapped[int] = mapped_column(Integer, default=0)
    plan = relationship("Plan", back_populates="asset_categories")
    assets = relationship("Asset", back_populates="category")
class Asset(Base):
    """Represents assets associated with a plan."""
    __tablename__ = "assets"
    asset_id: Mapped[int] = mapped_column(Integer, primary_key=True)
    plan_id: Mapped[int] = mapped_column(ForeignKey("plans.plan_id", ondelete="CASCADE"), nullable=False)
    asset_category_id: Mapped[int] = mapped_column(ForeignKey("asset_categories.asset_category_id", ondelete="CASCADE"), nullable=False)
    asset_name: Mapped[str] = mapped_column(Text, nullable=False)
    owner: Mapped[str] = mapped_column(Text, nullable=False)  # 'person1', 'person2', or 'joint'
    value: Mapped[float] = mapped_column(Float, nullable=False)
    include_in_nest_egg: Mapped[bool] = mapped_column(Boolean, default=True)
    plan = relationship("Plan", back_populates="assets")
    category = relationship("AssetCategory", back_populates="assets")
    overrides = relationship("ScenarioOverride", back_populates="asset")
    growth_rates = relationship("GrowthRateConfiguration", back_populates="asset")
class LiabilityCategory(Base):
    """Represents categories for organizing liabilities."""
    __tablename__ = "liability_categories"
    liability_category_id: Mapped[int] = mapped_column(Integer, primary_key=True)
    plan_id: Mapped[int] = mapped_column(ForeignKey("plans.plan_id", ondelete="CASCADE"), nullable=False)
    category_name: Mapped[str] = mapped_column(Text, nullable=False)
    category_order: Mapped[int] = mapped_column(Integer, default=0)
    plan = relationship("Plan", back_populates="liability_categories")
    liabilities = relationship("Liability", back_populates="category")
class Liability(Base):
    """Represents liabilities associated with a plan."""
    __tablename__ = "liabilities"
    liability_id: Mapped[int] = mapped_column(Integer, primary_key=True)
    plan_id: Mapped[int] = mapped_column(ForeignKey("plans.plan_id", ondelete="CASCADE"), nullable=False)
    liability_category_id: Mapped[int] = mapped_column(ForeignKey("liability_categories.liability_category_id", ondelete="CASCADE"), nullable=False)
    liability_name: Mapped[str] = mapped_column(Text, nullable=False)
    owner: Mapped[str] = mapped_column(Text, nullable=False)  # 'person1', 'person2', or 'joint'
    value: Mapped[float] = mapped_column(Float, nullable=False)
    interest_rate: Mapped[Optional[float]] = mapped_column(Float)
    include_in_nest_egg: Mapped[bool] = mapped_column(Boolean, default=True)
    plan = relationship("Plan", back_populates="liabilities")
    category = relationship("LiabilityCategory", back_populates="liabilities")
    overrides = relationship("ScenarioOverride", back_populates="liability")
class InflowOutflow(Base):
    """Represents recurring cash flows (income or expenses)."""
    __tablename__ = "inflows_outflows"
    inflow_outflow_id: Mapped[int] = mapped_column(Integer, primary_key=True)
    plan_id: Mapped[int] = mapped_column(ForeignKey("plans.plan_id", ondelete="CASCADE"), nullable=False)
    type: Mapped[str] = mapped_column(Text, nullable=False)  # 'inflow' or 'outflow'
    name: Mapped[str] = mapped_column(Text, nullable=False)
    owner: Mapped[str] = mapped_column(Text, nullable=False)  # 'person1', 'person2', or 'joint'
    annual_amount: Mapped[float] = mapped_column(Float, nullable=False)
    start_year: Mapped[int] = mapped_column(Integer, nullable=False)
    end_year: Mapped[Optional[int]] = mapped_column(Integer)
    apply_inflation: Mapped[bool] = mapped_column(Boolean, default=False)
    plan = relationship("Plan", back_populates="inflows_outflows")
    overrides = relationship("ScenarioOverride", back_populates="inflow_outflow")
class RetirementIncomePlan(Base):
    """Represents retirement income sources like Social Security or pensions."""
    __tablename__ = "retirement_income_plans"
    income_plan_id: Mapped[int] = mapped_column(Integer, primary_key=True)
    plan_id: Mapped[int] = mapped_column(ForeignKey("plans.plan_id", ondelete="CASCADE"), nullable=False)
    name: Mapped[str] = mapped_column(Text, nullable=False)
    owner: Mapped[str] = mapped_column(Text, nullable=False)  # 'person1', 'person2', or 'joint'
    annual_income: Mapped[float] = mapped_column(Float, nullable=False)
    start_age: Mapped[int] = mapped_column(Integer, nullable=False)
    end_age: Mapped[Optional[int]] = mapped_column(Integer)
    include_in_nest_egg: Mapped[bool] = mapped_column(Boolean, default=True)
    apply_inflation: Mapped[bool] = mapped_column(Boolean, default=False)
    plan = relationship("Plan", back_populates="retirement_income_plans")
    overrides = relationship("ScenarioOverride", back_populates="retirement_income_plan")
    growth_rates = relationship("GrowthRateConfiguration", back_populates="retirement_income_plan")
class GrowthRateConfiguration(Base):
    """Manages growth rates for assets and retirement income plans."""
    __tablename__ = "growth_rate_configurations"
    growth_rate_id: Mapped[int] = mapped_column(Integer, primary_key=True)
    asset_id: Mapped[Optional[int]] = mapped_column(ForeignKey("assets.asset_id", ondelete="CASCADE"))
    retirement_income_plan_id: Mapped[Optional[int]] = mapped_column(ForeignKey("retirement_income_plans.income_plan_id", ondelete="CASCADE"))
    scenario_id: Mapped[Optional[int]] = mapped_column(ForeignKey("scenarios.scenario_id", ondelete="CASCADE"))
    configuration_type: Mapped[str] = mapped_column(Text, nullable=False)  # 'DEFAULT', 'OVERRIDE', or 'STEPWISE'
    start_year: Mapped[int] = mapped_column(Integer, nullable=False)
    end_year: Mapped[Optional[int]] = mapped_column(Integer)
    growth_rate: Mapped[float] = mapped_column(Float, nullable=False)
    asset = relationship("Asset", back_populates="growth_rates")
    retirement_income_plan = relationship("RetirementIncomePlan", back_populates="growth_rates")
    scenario = relationship("Scenario", back_populates="growth_rates")
def init_tables(engine):
    """Initialize database tables. Should be called after engine is created."""
    Base.metadata.create_all(bind=engine)
```

######## backend/database_operations/__init__.py ########
```
# backend/database_operations/__init__.py
```

######## backend/database_operations/calculations/scenario_calcs.py ########
```
"""
## Scenarios
- Clone of base facts
- Inherits all base facts and base assumptions
- Can override any base fact as well as the fact's parameters
- Unique: Has retirement spending
- Retirement spending:
  - Starts at retirement year
  - Always inflation adjusted
  - Common use: Max sustainable spend
## Base Facts Aggregation
Base facts must remain unchanged while scenarios can modify:
- Asset values and growth
- Liability values and interest
- Cash flow amounts and timing
- Retirement income amounts and timing
- Base assumptions
## Value Display Principles
- All values shown in current dollars
- Inflation adjustments compound annually
Key features of this implementation:
1. Proper inheritance of base facts
2. Support for all types of overrides
3. Always-inflating retirement spending
4. Clear tracking of override impacts
5. Maintains base fact integrity
6. Comprehensive validation
"""
from dataclasses import dataclass
from decimal import Decimal
from typing import List, Dict, Optional
from copy import deepcopy
from ..models import ScenarioAssumption, ScenarioOverride
from .base_facts.base_facts_calcs import BaseFacts, YearlyCalculationResult, PortfolioValues
from ..utils.money_utils import to_decimal, apply_annual_inflation
@dataclass
class ScenarioFact:
    """Holds scenario-specific data and overrides."""
    scenario_id: int
    name: str
    base_facts: BaseFacts
    retirement_spending: Decimal
    assumption_overrides: Optional[ScenarioAssumption]
    component_overrides: List[ScenarioOverride]
@dataclass
class ScenarioCalculationResult:
    """Stores results of scenario calculations."""
    base_result: YearlyCalculationResult
    scenario_portfolio: PortfolioValues
    retirement_spending: Decimal
    adjusted_spending: Decimal
    spending_impact: Decimal
    override_impacts: Dict[str, Decimal]
    metadata: Dict
class ScenarioCalculator:
    """Calculates scenario outcomes with overrides and spending adjustments."""
    def calculate_scenario_year(self, scenario: ScenarioFact, year: int,
                                base_result: YearlyCalculationResult,
                                prior_scenario_result: Optional[ScenarioCalculationResult] = None) -> ScenarioCalculationResult:
        """Computes scenario values based on base results."""
        portfolio = deepcopy(base_result.ending_portfolio)
        override_impacts = self._apply_component_overrides(portfolio, scenario.component_overrides)
        retirement_spending = adjusted_spending = spending_impact = Decimal('0')
        if self._is_retirement_spending_active(scenario, year):
            retirement_spending = scenario.retirement_spending
            adjusted_spending = apply_annual_inflation(retirement_spending, self._get_inflation_rate(scenario),
                                                       year - scenario.base_facts.start_year)
            spending_impact = adjusted_spending - retirement_spending
            portfolio = self._apply_retirement_spending(portfolio, adjusted_spending)
        return ScenarioCalculationResult(
            base_result=base_result,
            scenario_portfolio=portfolio,
            retirement_spending=retirement_spending,
            adjusted_spending=adjusted_spending,
            spending_impact=spending_impact,
            override_impacts=override_impacts,
            metadata=self._generate_calculation_metadata(scenario, year, override_impacts, spending_impact)
        )
    def _apply_component_overrides(self, portfolio: PortfolioValues, overrides: List[ScenarioOverride]) -> Dict[str, Decimal]:
        """Applies scenario component overrides to portfolio."""
        impacts = {key: Decimal('0') for key in ["asset_value", "liability_value", "cash_flow", "retirement_income"]}
        for override in overrides:
            original_value = self._get_original_value(portfolio, override)
            new_value = to_decimal(override.override_value)
            impact = new_value - original_value
            if override.asset_id:
                impacts["asset_value"] += impact
                portfolio.asset_values[override.asset_id] = new_value
            elif override.liability_id:
                impacts["liability_value"] += impact
                portfolio.liability_values[override.liability_id] = new_value
        return impacts
    def _apply_retirement_spending(self, portfolio: PortfolioValues, spending_amount: Decimal) -> PortfolioValues:
        """Deducts retirement spending from portfolio values."""
        portfolio.retirement_portfolio_value -= spending_amount
        return self._update_portfolio_totals(portfolio)
    def _is_retirement_spending_active(self, scenario: ScenarioFact, year: int) -> bool:
        """Checks if retirement spending applies in a given year."""
        retirement_year = (scenario.assumption_overrides.retirement_age_1
                           if scenario.assumption_overrides and scenario.assumption_overrides.retirement_age_1
                           else scenario.base_facts.retirement_year)
        return year >= retirement_year
    def _get_inflation_rate(self, scenario: ScenarioFact) -> Decimal:
        """Retrieves applicable inflation rate, considering overrides."""
        return (scenario.assumption_overrides.inflation_rate
                if scenario.assumption_overrides and scenario.assumption_overrides.inflation_rate is not None
                else to_decimal(scenario.base_facts.base_assumptions.inflation_rate))
    def _get_original_value(self, portfolio: PortfolioValues, override: ScenarioOverride) -> Decimal:
        """Fetches the original value for a given override target."""
        return (portfolio.asset_values.get(override.asset_id, Decimal('0')) if override.asset_id
                else portfolio.liability_values.get(override.liability_id, Decimal('0')) if override.liability_id
                else Decimal('0'))
    def _update_portfolio_totals(self, portfolio: PortfolioValues) -> PortfolioValues:
        """Recalculates total net worth after adjustments."""
        portfolio.total_net_worth = sum(portfolio.asset_values.values()) - sum(portfolio.liability_values.values())
        return portfolio
    def _generate_calculation_metadata(self, scenario: ScenarioFact, year: int,
                                       override_impacts: Dict[str, Decimal], spending_impact: Decimal) -> Dict:
        """Generates metadata for a scenario calculation."""
        return {
            "scenario_name": scenario.name,
            "year": year,
            "override_count": len(scenario.component_overrides),
            "total_override_impact": sum(override_impacts.values()),
            "spending_impact": spending_impact
        }
    def validate_scenario_facts(self, scenario: ScenarioFact) -> None:
        """Ensures scenario inputs are valid before calculations."""
        if scenario.retirement_spending < 0:
            raise ValueError("Retirement spending cannot be negative")
        if scenario.assumption_overrides and scenario.assumption_overrides.retirement_age_1 is not None:
            if scenario.assumption_overrides.retirement_age_1 < 0:
                raise ValueError("Invalid retirement age override")
        for override in scenario.component_overrides:
            if not any([override.asset_id, override.liability_id, override.inflow_outflow_id, override.retirement_income_plan_id]):
                raise ValueError(f"Override {override.override_id} has no target")
    def generate_override_summary(self, scenario: ScenarioFact) -> Dict[str, int]:
        """Generates a summary of scenario overrides."""
        summary = {key: 0 for key in ["asset_overrides", "liability_overrides", "cash_flow_overrides", "retirement_income_overrides"]}
        for override in scenario.component_overrides:
            if override.asset_id:
                summary["asset_overrides"] += 1
            elif override.liability_id:
                summary["liability_overrides"] += 1
            elif override.inflow_outflow_id:
                summary["cash_flow_overrides"] += 1
            elif override.retirement_income_plan_id:
                summary["retirement_income_overrides"] += 1
        return summary
```

######## backend/database_operations/calculations/__init__.py ########
```
"""Financial calculations package.""" 
```

######## backend/database_operations/calculations/base_facts/assets_calcs.py ########
```
"""
## Assets
- Value  
- Optional category assignment  
- Growth handling:  
  1. Default: Uses base assumption growth rate  
  2. Override: Asset-specific fixed rate  
  3. Stepwise: Multiple rates over time periods (start year / end year)  
  4. Gaps in stepwise fall to default  
- Optional inflation toggle
## Growth Rate System
- Assets can have default, fixed, or stepwise growth rates
- Stepwise: Multiple rates over time periods
- Gaps in stepwise fall to default
This implementation:
1. Handles the three types of growth rates (default, override, stepwise)
2. Properly falls back to default rate when needed
3. Manages category aggregation
4. Tracks which assets are included in retirement portfolio
5. Provides detailed calculation metadata
6. Validates configurations and prevents overlapping periods
"""
from dataclasses import dataclass
from decimal import Decimal
from typing import List, Dict, Optional
from ...models import GrowthRateConfiguration
from ...utils.money_utils import to_decimal, apply_annual_compound_rate, combine_amounts, round_to_currency
from ...validation.money_validation import validate_positive_amount, validate_rate
from ...validation.growth_validation import validate_growth_config_type, validate_stepwise_periods
@dataclass
class AssetFact:
    """Stores asset details and growth configurations."""
    asset_id: int
    value: Decimal
    category_id: int
    include_in_nest_egg: bool
    growth_configs: List[GrowthRateConfiguration]
    owner: str
    name: str
@dataclass
class AssetCalculationResult:
    """Stores results of asset growth calculations."""
    asset_id: int
    starting_value: Decimal
    ending_value: Decimal
    applied_growth_rate: Decimal
    category_id: int
    growth_amount: Decimal
    included_in_nest_egg: bool
    metadata: Dict
class AssetCalculator:
    """Handles asset valuation with growth rate application."""
    def calculate_asset_value(self, asset: AssetFact, year: int, default_rate: Decimal,
                              plan_creation_year: int) -> AssetCalculationResult:
        """Calculates asset value applying growth rates."""
        if year < plan_creation_year:
            raise ValueError(f"Cannot calculate asset value before plan creation year {plan_creation_year}")
        starting_value = asset.value
        growth_rate = self._get_applicable_growth_rate(asset.growth_configs, year, default_rate)
        ending_value = apply_annual_compound_rate(starting_value, growth_rate)
        growth_amount = ending_value - starting_value
        return AssetCalculationResult(
            asset_id=asset.asset_id,
            starting_value=starting_value,
            ending_value=ending_value,
            applied_growth_rate=growth_rate,
            category_id=asset.category_id,
            growth_amount=growth_amount,
            included_in_nest_egg=asset.include_in_nest_egg,
            metadata=self._generate_metadata(asset, year, growth_rate, growth_amount)
        )
    def calculate_multiple_assets(self, assets: List[AssetFact], year: int, default_rate: Decimal,
                                  plan_creation_year: int) -> List[AssetCalculationResult]:
        """Calculates values for multiple assets."""
        self.validate_asset_facts(assets)
        return [self.calculate_asset_value(asset, year, default_rate, plan_creation_year) for asset in assets]
    def aggregate_by_category(self, results: List[AssetCalculationResult]) -> Dict[int, Decimal]:
        """Aggregates assets by category."""
        totals: Dict[int, Decimal] = {}
        for result in results:
            totals[result.category_id] = combine_amounts([totals.get(result.category_id, Decimal('0')), result.ending_value])
        return totals
    def calculate_nest_egg_value(self, results: List[AssetCalculationResult]) -> Decimal:
        """Computes total value of nest-egg eligible assets."""
        return combine_amounts([r.ending_value for r in results if r.included_in_nest_egg])
    def _get_applicable_growth_rate(self, growth_configs: List[GrowthRateConfiguration], year: int,
                                    default_rate: Decimal) -> Decimal:
        """Determines applicable growth rate based on hierarchy."""
        for config in sorted(growth_configs, key=lambda c: c.configuration_type == 'OVERRIDE', reverse=True):
            if config.configuration_type == 'STEPWISE' and config.start_year <= year <= (config.end_year or year):
                return to_decimal(config.growth_rate)
            if config.configuration_type == 'OVERRIDE':
                return to_decimal(config.growth_rate)
        return default_rate
    def validate_asset_facts(self, assets: List[AssetFact]) -> None:
        """Validates asset values and growth configurations."""
        for asset in assets:
            validate_positive_amount(asset.value, f"asset_{asset.asset_id}_value")
            for config in asset.growth_configs:
                validate_growth_config_type(config.configuration_type, f"asset_{asset.asset_id}_growth_type")
            stepwise_periods = [{"start_year": c.start_year, "end_year": c.end_year}
                                for c in asset.growth_configs if c.configuration_type == 'STEPWISE']
            if stepwise_periods:
                validate_stepwise_periods(stepwise_periods, f"asset_{asset.asset_id}_growth_periods")
    def _generate_metadata(self, asset: AssetFact, year: int, applied_rate: Decimal, growth_amount: Decimal) -> Dict:
        """Generates metadata about asset valuation."""
        return {
            "asset_name": asset.name,
            "owner": asset.owner,
            "year": year,
            "applied_growth_rate": str(round_to_currency(applied_rate)),
            "growth_amount": str(round_to_currency(growth_amount)),
            "rate_type": self._determine_rate_type(asset.growth_configs, year)
        }
    def _determine_rate_type(self, growth_configs: List[GrowthRateConfiguration], year: int) -> str:
        """Determines the type of applied growth rate."""
        for config in growth_configs:
            if config.configuration_type == 'STEPWISE' and config.start_year <= year <= (config.end_year or year):
                return 'STEPWISE'
            if config.configuration_type == 'OVERRIDE':
                return 'OVERRIDE'
        return 'DEFAULT'
```

######## backend/database_operations/calculations/base_facts/base_facts_calcs.py ########
```
# backend/database_operations/calculations/base_facts/base_facts_calculator.py
"""
## Annual Calculation Order
1. Start with prior year-end values  
2. Apply scheduled inflows (inflation-adjusted if enabled)  
3. Apply scheduled outflows (inflation-adjusted if enabled)  
4. Apply retirement income  
5. Apply retirement spending  
6. Apply asset growth using `GrowthRateHandler`:  
   - Asset-specific rates applied through `_apply_all_growth`  
   - Default rates applied if no asset-specific rate exists  
7. Apply liability interest  
8. Calculate year-end total  
## Value Display Principles
- All values shown in current dollars
- Inflation adjustments compound annually
- Growth is calculated exclusively via `GrowthRateHandler`  
- No partial year or day counting  
- No cash flow timing within year  
- All events occur at year boundaries  
- Portfolio values represent year-end totals  
## Growth Calculation Updates
- Growth calculations are now centralized in `GrowthRateHandler`  
- `_apply_all_growth` is the single method for applying growth to all assets  
- Liability interest remains separate but follows similar compound application  
"""
from dataclasses import dataclass
from decimal import Decimal
from typing import List, Dict, Optional
from ...models import Asset, Liability, InflowOutflow, RetirementIncomePlan, BaseAssumption
from ...utils.money_utils import to_decimal, apply_annual_compound_rate, apply_annual_inflation
from .growth_handler_calcs import GrowthRateHandler
@dataclass
class BaseFacts:
    """Stores base financial data for projections."""
    assets: List[Asset]
    liabilities: List[Liability]
    inflows_outflows: List[InflowOutflow]
    retirement_income: List[RetirementIncomePlan]
    base_assumptions: BaseAssumption
    start_year: int
    retirement_year: int
    end_year: int
@dataclass
class PortfolioValues:
    """Represents financial portfolio status."""
    asset_values: Dict[int, Decimal]
    liability_values: Dict[int, Decimal]
    asset_category_totals: Dict[str, Decimal]
    liability_category_totals: Dict[str, Decimal]
    retirement_portfolio_value: Decimal
    total_net_worth: Decimal
@dataclass
class CashFlowResults:
    """Tracks cash movements in a given year."""
    inflows: Dict[int, Decimal]
    outflows: Dict[int, Decimal]
    net_inflows: Decimal
    net_outflows: Decimal
    total_net_flow: Decimal
@dataclass
class IncomeResults:
    """Records annual retirement income."""
    income_streams: Dict[int, Decimal]
    total_income: Decimal
@dataclass
class YearlyCalculationResult:
    """Stores full results of an annual projection."""
    year: int
    starting_portfolio: PortfolioValues
    cash_flows: CashFlowResults
    income: IncomeResults
    ending_portfolio: PortfolioValues
    metadata: Dict
class BaseFactsCalculator:
    """Executes annual financial projections."""
    def __init__(self):
        self.growth_handler = GrowthRateHandler()
    def calculate_year(self, year: int, base_facts: BaseFacts,
                       prior_result: Optional[YearlyCalculationResult]) -> YearlyCalculationResult:
        """Computes portfolio projections for a given year."""
        starting_portfolio = self._carry_forward_values(prior_result) if prior_result else self._initialize_starting_values(base_facts)
        cash_flows = self.process_cash_flows(year, base_facts)
        income = self.process_retirement_income(year, base_facts)
        interim_portfolio = self._apply_flows_to_portfolio(starting_portfolio, cash_flows, income, base_facts)
        grown_portfolio = self._apply_all_growth(interim_portfolio, year, base_facts)
        final_portfolio = self.apply_liability_interest(grown_portfolio, base_facts)
        final_portfolio = self._update_portfolio_totals(final_portfolio, base_facts)
        return YearlyCalculationResult(
            year=year,
            starting_portfolio=starting_portfolio,
            cash_flows=cash_flows,
            income=income,
            ending_portfolio=final_portfolio,
            metadata=self._generate_calculation_metadata(year, final_portfolio, cash_flows)
        )
    def _apply_all_growth(self, portfolio: PortfolioValues, year: int, base_facts: BaseFacts) -> PortfolioValues:
        """Applies growth to all assets."""
        for asset in base_facts.assets:
            growth_result = self.growth_handler.apply_growth(
                portfolio.asset_values[asset.asset_id],
                asset.asset_id,
                year,
                to_decimal(base_facts.base_assumptions.default_growth_rate),
                asset.growth_rates
            )
            portfolio.asset_values[asset.asset_id] = growth_result.final_value
        return self._update_portfolio_totals(portfolio, base_facts)
    def apply_liability_interest(self, portfolio: PortfolioValues, base_facts: BaseFacts) -> PortfolioValues:
        """Applies interest to liabilities."""
        for liability in base_facts.liabilities:
            if liability.interest_rate:
                portfolio.liability_values[liability.liability_id] = apply_annual_compound_rate(
                    portfolio.liability_values[liability.liability_id], to_decimal(liability.interest_rate)
                )
        return self._update_portfolio_totals(portfolio, base_facts)
    def process_cash_flows(self, year: int, base_facts: BaseFacts) -> CashFlowResults:
        """Calculates cash inflows and outflows for a year."""
        inflows, outflows = {}, {}
        for flow in base_facts.inflows_outflows:
            if flow.start_year <= year <= (flow.end_year or flow.start_year):
                amount = to_decimal(flow.annual_amount)
                if flow.apply_inflation:
                    amount = apply_annual_inflation(amount, to_decimal(base_facts.base_assumptions.inflation_rate),
                                                    year - base_facts.start_year)
                (inflows if flow.type == 'inflow' else outflows)[flow.inflow_outflow_id] = amount
        return CashFlowResults(
            inflows=inflows,
            outflows=outflows,
            net_inflows=sum(inflows.values()),
            net_outflows=sum(outflows.values()),
            total_net_flow=sum(inflows.values()) - sum(outflows.values())
        )
    def process_retirement_income(self, year: int, base_facts: BaseFacts) -> IncomeResults:
        """Computes retirement income for a year."""
        if year < base_facts.retirement_year:
            return IncomeResults(income_streams={}, total_income=Decimal('0'))
        income_streams = {income.income_plan_id: to_decimal(income.annual_income) for income in base_facts.retirement_income
                          if self._is_income_active(income, year)}
        return IncomeResults(
            income_streams=income_streams,
            total_income=sum(income_streams.values())
        )
    def _update_portfolio_totals(self, portfolio: PortfolioValues, base_facts: BaseFacts) -> PortfolioValues:
        """Updates portfolio totals including net worth and category values."""
        portfolio.total_net_worth = sum(portfolio.asset_values.values()) - sum(portfolio.liability_values.values())
        portfolio.retirement_portfolio_value = sum(value for asset in base_facts.assets
                                                   if asset.include_in_nest_egg and (value := portfolio.asset_values[asset.asset_id]))
        portfolio.asset_category_totals = {asset.asset_category_id: sum(portfolio.asset_values[a.asset_id]
                                                                         for a in base_facts.assets
                                                                         if a.asset_category_id == asset.asset_category_id)
                                           for asset in base_facts.assets}
        portfolio.liability_category_totals = {liability.liability_category_id: sum(portfolio.liability_values[l.liability_id]
                                                                                    for l in base_facts.liabilities
                                                                                    if l.liability_category_id == liability.liability_category_id)
                                               for liability in base_facts.liabilities}
        return portfolio
    def _apply_flows_to_portfolio(self, portfolio: PortfolioValues, cash_flows: CashFlowResults, income: IncomeResults,
                                  base_facts: BaseFacts) -> PortfolioValues:
        """Adjusts portfolio for cash flow and income events."""
        portfolio.retirement_portfolio_value += sum(cash_flows.inflows.values()) - sum(cash_flows.outflows.values()) + income.total_income
        return self._update_portfolio_totals(portfolio, base_facts)
    def generate_projection(self, base_facts: BaseFacts) -> List[YearlyCalculationResult]:
        """Generates complete financial projection timeline."""
        self.validate_inputs(base_facts)
        results, prior_result = [], None
        for year in range(base_facts.start_year, base_facts.end_year + 1):
            result = self.calculate_year(year, base_facts, prior_result)
            results.append(result)
            prior_result = result
        return results
    def validate_inputs(self, base_facts: BaseFacts) -> None:
        """Ensures all financial inputs are valid."""
        if not base_facts.assets and not base_facts.liabilities:
            raise ValueError("At least one asset or liability is required.")
        if base_facts.start_year >= base_facts.retirement_year or base_facts.retirement_year >= base_facts.end_year:
            raise ValueError("Invalid timeline sequence.")
    def _is_income_active(self, income: RetirementIncomePlan, year: int) -> bool:
        """Checks if a retirement income stream is active in a given year."""
        return income.start_year <= year <= (income.end_year or income.start_year)
    def _generate_calculation_metadata(self, year: int, portfolio: PortfolioValues, flows: CashFlowResults) -> Dict:
        """Creates metadata about a given year's calculations."""
        return {
            "year": year,
            "total_inflows": flows.net_inflows,
            "total_outflows": flows.net_outflows,
            "ending_portfolio_value": portfolio.retirement_portfolio_value
        }
```

######## backend/database_operations/calculations/base_facts/cash_flows_calcs.py ########
```
"""
Handles calculations for discrete event cash flows.
Follows core principles:
- Annual periods only
- No intra-year calculations
- Optional inflation adjustment
"""
from dataclasses import dataclass
from decimal import Decimal
from typing import List, Dict, Optional
from enum import Enum
from ...utils.money_utils import to_decimal, apply_annual_inflation
class FlowType(Enum):
    """Represents cash flow types."""
    INFLOW = 'inflow'
    OUTFLOW = 'outflow'
@dataclass
class CashFlowFact:
    """Defines a discrete cash flow event."""
    flow_id: int
    name: str
    flow_type: FlowType
    annual_amount: Decimal
    start_year: int
    end_year: int
    apply_inflation: bool
    owner: str
@dataclass
class CashFlowCalculationResult:
    """Stores results of cash flow calculations."""
    flow_id: int
    flow_name: str
    flow_type: FlowType
    base_amount: Decimal
    adjusted_amount: Decimal
    is_active: bool
    metadata: Dict
@dataclass
class AggregatedFlows:
    """Aggregates inflows and outflows, including inflation-adjusted values."""
    total_inflows: Decimal
    total_outflows: Decimal
    inflation_adjusted_inflows: Decimal
    inflation_adjusted_outflows: Decimal
    net_flow: Decimal
class CashFlowCalculator:
    """Handles cash flow calculations and aggregation."""
    def calculate_flow_amount(self, flow: CashFlowFact, year: int,
                              inflation_rate: Decimal, plan_start_year: int) -> CashFlowCalculationResult:
        """Computes cash flow for a given year."""
        is_active = flow.start_year <= year <= flow.end_year
        base_amount = flow.annual_amount if is_active else Decimal('0')
        adjusted_amount = apply_annual_inflation(base_amount, inflation_rate, year - plan_start_year) \
            if is_active and flow.apply_inflation else base_amount
        return CashFlowCalculationResult(
            flow_id=flow.flow_id,
            flow_name=flow.name,
            flow_type=flow.flow_type,
            base_amount=base_amount,
            adjusted_amount=adjusted_amount,
            is_active=is_active,
            metadata=self._generate_metadata(flow, year)
        )
    def calculate_multiple_flows(self, flows: List[CashFlowFact], year: int,
                                 inflation_rate: Decimal, plan_start_year: int) -> List[CashFlowCalculationResult]:
        """Computes cash flows for multiple events."""
        return [self.calculate_flow_amount(flow, year, inflation_rate, plan_start_year) for flow in flows]
    def aggregate_flows(self, results: List[CashFlowCalculationResult]) -> AggregatedFlows:
        """Aggregates inflows, outflows, and net cash flow."""
        inflows, outflows, adj_inflows, adj_outflows = Decimal('0'), Decimal('0'), Decimal('0'), Decimal('0')
        for result in results:
            if result.is_active:
                if result.flow_type == FlowType.INFLOW:
                    inflows += result.base_amount
                    adj_inflows += result.adjusted_amount
                else:
                    outflows += result.base_amount
                    adj_outflows += result.adjusted_amount
        return AggregatedFlows(
            total_inflows=inflows,
            total_outflows=outflows,
            inflation_adjusted_inflows=adj_inflows,
            inflation_adjusted_outflows=adj_outflows,
            net_flow=adj_inflows - adj_outflows
        )
    def validate_cash_flows(self, flows: List[CashFlowFact]) -> None:
        """Ensures all cash flows have valid amounts and timelines."""
        for flow in flows:
            if flow.annual_amount <= 0:
                raise ValueError(f"Cash flow {flow.flow_id} has invalid amount.")
            if flow.start_year > flow.end_year:
                raise ValueError(f"Cash flow {flow.flow_id} has an invalid year sequence.")
    def calculate_total_flow_amount(self, annual_amount: Decimal, start_year: int, end_year: Optional[int],
                                    inflation_rate: Optional[Decimal] = None, apply_inflation: bool = False) -> Decimal:
        """Computes total cash flow over a period, optionally applying inflation."""
        duration = (end_year or start_year) - start_year + 1
        if not apply_inflation or not inflation_rate:
            return annual_amount * duration
        return sum(apply_annual_inflation(annual_amount, inflation_rate, year) for year in range(duration))
    def calculate_total_inflation_impact(self, results: List[CashFlowCalculationResult]) -> Dict[FlowType, Decimal]:
        """Computes the total impact of inflation on cash flows."""
        impact = {FlowType.INFLOW: Decimal('0'), FlowType.OUTFLOW: Decimal('0')}
        for result in results:
            if result.is_active:
                impact[result.flow_type] += result.adjusted_amount - result.base_amount
        return impact
    def _generate_metadata(self, flow: CashFlowFact, year: int) -> Dict:
        """Creates metadata for a cash flow calculation."""
        return {
            "flow_name": flow.name,
            "flow_type": flow.flow_type.value,
            "owner": flow.owner,
            "year": year,
            "is_single_year": flow.start_year == flow.end_year
        }
```

######## backend/database_operations/calculations/base_facts/growth_handler_calcs.py ########
```
# backend/database_operations/calculations/base_facts/growth_handler.py
"""
Moved from the prior assets_helpers.py file to this file.
"""
"""
## Assets
- Growth handling:  
  1. Default: Uses base assumption growth rate  
  2. Override: Asset-specific fixed rate  
  3. Stepwise: Multiple rates over time periods
  4. Gaps in stepwise fall to default
- Optional inflation toggle
## Growth Rate System
- Assets can have default, fixed, or stepwise growth rates
- Stepwise: Multiple rates over time periods
- Gaps in stepwise fall to default
"""
from decimal import Decimal
from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass
from ...models import GrowthRateConfiguration
from ...utils.money_utils import to_decimal, apply_annual_compound_rate
from ...validation.money_validation import validate_rate
@dataclass
class GrowthResult:
    """Stores growth calculation results."""
    final_value: Decimal
    growth_amount: Decimal
    applied_rate: Decimal
    rate_source: str  # 'default', 'override', or 'stepwise'
    period_start: Optional[int] = None
    period_end: Optional[int] = None
class GrowthRateHandler:
    """Handles asset growth rate calculations."""
    def apply_growth(self, value: Decimal, year: int, default_rate: Decimal,
                     growth_configs: List[GrowthRateConfiguration]) -> GrowthResult:
        """Applies growth to a value based on the highest priority rate."""
        rate, source, period = self._get_applicable_rate(growth_configs, year, default_rate)
        final_value = apply_annual_compound_rate(value, rate)
        return GrowthResult(
            final_value=final_value,
            growth_amount=final_value - value,
            applied_rate=rate,
            rate_source=source,
            period_start=period[0] if period else None,
            period_end=period[1] if period else None
        )
    def _get_applicable_rate(self, configs: List[GrowthRateConfiguration], year: int,
                             default_rate: Decimal) -> Tuple[Decimal, str, Optional[Tuple[int, int]]]:
        """Determines the highest priority growth rate."""
        for config in sorted(configs, key=lambda c: (c.configuration_type != 'STEPWISE', c.start_year)):
            if config.start_year <= year and (config.end_year is None or config.end_year >= year):
                return to_decimal(config.growth_rate), config.configuration_type.lower(), (
                    config.start_year, config.end_year) if config.configuration_type == 'STEPWISE' else None
        return default_rate, 'default', None
    def validate_stepwise_configurations(self, configs: List[GrowthRateConfiguration]) -> None:
        """Ensures stepwise growth configurations do not overlap."""
        stepwise_configs = sorted([c for c in configs if c.configuration_type == 'STEPWISE'], key=lambda x: x.start_year)
        for i in range(len(stepwise_configs) - 1):
            if stepwise_configs[i].end_year and stepwise_configs[i].end_year >= stepwise_configs[i + 1].start_year:
                raise ValueError(f"Overlapping growth periods: {stepwise_configs[i].start_year}-{stepwise_configs[i].end_year} "
                                 f"and {stepwise_configs[i + 1].start_year}-{stepwise_configs[i + 1].end_year}")
            validate_rate(stepwise_configs[i].growth_rate)
```

######## backend/database_operations/calculations/base_facts/liabilities_calcs.py ########
```
"""
Liability calculation module.
Unlike assets which use a complex growth rate system, liabilities use a simple interest model.
Key differences:
- No default growth rate usage
- Optional simple interest rate
- Fixed value if no rate specified
"""
from decimal import Decimal
from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass
from ...utils.money_utils import to_decimal, apply_annual_compound_rate
from ...utils.time_utils import validate_year_not_before_plan_creation
@dataclass
class LiabilityFact:
    """Stores liability details for calculations."""
    liability_id: int
    value: Decimal
    interest_rate: Optional[Decimal]
    category_id: int
    include_in_nest_egg: bool
    plan_creation_year: Optional[int]
@dataclass
class LiabilityCalculationResult:
    """Stores liability calculation results."""
    liability_id: int
    starting_value: Decimal
    ending_value: Decimal
    interest_amount: Decimal
    category_id: int
    has_interest: bool
    metadata: Dict
class LiabilityCalculator:
    """Performs liability calculations using a simple interest model."""
    @staticmethod
    def calculate_liability_value(liability: LiabilityFact, year: int) -> LiabilityCalculationResult:
        """Computes liability value for a given year."""
        if liability.plan_creation_year:
            validate_year_not_before_plan_creation(year, liability.plan_creation_year)
        starting_value = liability.value
        ending_value, interest_amount = LiabilityCalculator.apply_interest(starting_value, liability.interest_rate)
        return LiabilityCalculationResult(
            liability_id=liability.liability_id,
            starting_value=starting_value,
            ending_value=ending_value,
            interest_amount=interest_amount,
            category_id=liability.category_id,
            has_interest=liability.interest_rate is not None,
            metadata=LiabilityCalculator.generate_metadata(liability, year, starting_value, ending_value)
        )
    @staticmethod
    def calculate_multiple_liabilities(liabilities: List[LiabilityFact], year: int) -> List[LiabilityCalculationResult]:
        """Computes liability values for multiple liabilities."""
        return [LiabilityCalculator.calculate_liability_value(liability, year) for liability in liabilities]
    @staticmethod
    def aggregate_by_category(results: List[LiabilityCalculationResult]) -> Dict[int, Decimal]:
        """Sums liabilities by category."""
        totals = {}
        for result in results:
            totals[result.category_id] = totals.get(result.category_id, Decimal('0')) + result.ending_value
        return totals
    @staticmethod
    def calculate_nest_egg_total(results: List[LiabilityCalculationResult]) -> Decimal:
        """Computes total liabilities marked as included in the nest egg."""
        return sum(result.ending_value for result in results if result.include_in_nest_egg)
    @staticmethod
    def apply_interest(value: Decimal, rate: Optional[Decimal]) -> Tuple[Decimal, Decimal]:
        """Applies simple interest for one period."""
        if rate is None:
            return value, Decimal('0')
        ending_value = apply_annual_compound_rate(value, rate)
        return ending_value, ending_value - value
    @staticmethod
    def calculate_weighted_average_rate(liabilities: List[Tuple[Decimal, Optional[Decimal]]]) -> Optional[Decimal]:
        """Computes weighted average interest rate across liabilities."""
        total_value = sum(value for value, rate in liabilities if rate)
        weighted_sum = sum(value * rate for value, rate in liabilities if rate)
        return weighted_sum / total_value if total_value else None
    @staticmethod
    def project_liability_value(current_value: Decimal, interest_rate: Optional[Decimal], years: int) -> Decimal:
        """Projects liability value over a number of years."""
        return apply_annual_compound_rate(current_value, interest_rate, years) if interest_rate else current_value
    @staticmethod
    def validate_liability_values(liabilities: List[Tuple[int, Decimal]]) -> None:
        """Ensures all liabilities have positive values."""
        for lid, value in liabilities:
            if value <= 0:
                raise ValueError(f"Liability {lid} has invalid value: {value}")
    @staticmethod
    def calculate_total_interest(results: List[Tuple[Decimal, Decimal]]) -> Decimal:
        """Computes total interest across all liabilities."""
        return sum(ending - starting for starting, ending in results)
    @staticmethod
    def identify_fixed_value_liabilities(liabilities: List[Tuple[int, Optional[Decimal]]]) -> List[int]:
        """Identifies liabilities with no interest rate."""
        return [lid for lid, rate in liabilities if rate is None]
    @staticmethod
    def identify_high_interest_liabilities(liabilities: List[Tuple[int, Optional[Decimal]]], threshold: Decimal) -> List[int]:
        """Identifies liabilities with interest rates exceeding a threshold."""
        return [lid for lid, rate in liabilities if rate and rate > threshold]
    @staticmethod
    def generate_metadata(liability: LiabilityFact, year: int, start_value: Decimal, end_value: Decimal) -> Dict:
        """Creates metadata for liability calculations."""
        return {
            "liability_id": liability.liability_id,
            "year": year,
            "starting_value": str(start_value),
            "ending_value": str(end_value),
            "interest_amount": str(end_value - start_value),
            "has_interest": liability.interest_rate is not None,
            "interest_rate": str(liability.interest_rate) if liability.interest_rate else None,
            "is_fixed_value": liability.interest_rate is None,
            "plan_creation_year": liability.plan_creation_year
        }
```

######## backend/database_operations/calculations/base_facts/retirement_income_calcs.py ########
```
"""
## Retirement Income
- Start year, end year
- Amount
- Optional inflation toggle
- Input in absolute years (derived dynamically from selected person's retirement age)
- For SS/Pension/Deferred Comp, etc.
- Separate from scheduled inflows
## Time Handling Principles
- DOB is the only true date input
- All calculations reference absolute years internally
- Conversion rules:
  - Years ↔ Age: Derived dynamically from DOB when needed
  - Store values as entered and convert as needed
## Value Display Principles
- Inflation adjustments compound annually
- No partial year or day counting
- All events assumed to occur at year boundaries
1. Proper age-based activation of income streams
2. Support for lifetime income (no end age)
3. Optional inflation adjustments
4. Clear separation from scheduled inflows
5. Proper handling of DOB for age calculations
6. Utilities for analyzing income streams by type
""" 
from dataclasses import dataclass
from decimal import Decimal
from typing import List, Dict, Optional
from datetime import date
from ...utils.money_utils import to_decimal, apply_annual_inflation
from ...utils.time_utils import get_age_at_year
@dataclass
class RetirementIncomeFact:
    """Represents a retirement income stream."""
    income_id: int
    name: str
    owner: str
    annual_income: Decimal
    start_age: int
    end_age: Optional[int]
    include_in_nest_egg: bool
    apply_inflation: bool
    dob: date
@dataclass
class IncomeCalculationResult:
    """Stores results of income calculations."""
    income_id: int
    income_name: str
    base_amount: Decimal
    adjusted_amount: Decimal
    inflation_adjustment: Decimal
    is_active: bool
    included_in_nest_egg: bool
    metadata: Dict
class RetirementIncomeCalculator:
    """Handles retirement income calculations."""
    def calculate_income_amount(self, income: RetirementIncomeFact, year: int,
                                inflation_rate: Decimal, plan_start_year: int) -> IncomeCalculationResult:
        """Calculates income for a given year."""
        current_age = get_age_at_year(income.dob, year)
        is_active = self._is_income_active(income, current_age)
        if not is_active:
            return IncomeCalculationResult(
                income_id=income.income_id,
                income_name=income.name,
                base_amount=income.annual_income,
                adjusted_amount=Decimal('0'),
                inflation_adjustment=Decimal('0'),
                is_active=False,
                included_in_nest_egg=income.include_in_nest_egg,
                metadata=self._generate_metadata(income, year, current_age, Decimal('0'))
            )
        base_amount = income.annual_income
        inflation_adjustment = apply_annual_inflation(base_amount, inflation_rate, year - plan_start_year) - base_amount
        adjusted_amount = base_amount + inflation_adjustment if income.apply_inflation else base_amount
        return IncomeCalculationResult(
            income_id=income.income_id,
            income_name=income.name,
            base_amount=base_amount,
            adjusted_amount=adjusted_amount,
            inflation_adjustment=inflation_adjustment,
            is_active=True,
            included_in_nest_egg=income.include_in_nest_egg,
            metadata=self._generate_metadata(income, year, current_age, inflation_adjustment)
        )
    def calculate_multiple_income_streams(self, income_streams: List[RetirementIncomeFact], year: int,
                                          inflation_rate: Decimal, plan_start_year: int) -> List[IncomeCalculationResult]:
        """Calculates income for multiple streams."""
        return [self.calculate_income_amount(income, year, inflation_rate, plan_start_year) for income in income_streams]
    def aggregate_by_source(self, results: List[IncomeCalculationResult]) -> Dict[str, Decimal]:
        """Totals income by source."""
        totals = {}
        for result in results:
            if result.is_active:
                totals[result.income_name] = totals.get(result.income_name, Decimal('0')) + result.adjusted_amount
        return totals
    def calculate_total_income(self, results: List[IncomeCalculationResult], nest_egg_only: bool = False) -> Decimal:
        """Calculates total income."""
        return sum(r.adjusted_amount for r in results if r.is_active and (not nest_egg_only or r.included_in_nest_egg))
    def calculate_total_inflation_impact(self, results: List[IncomeCalculationResult]) -> Decimal:
        """Calculates total inflation impact."""
        return sum(r.inflation_adjustment for r in results if r.is_active)
    def _is_income_active(self, income: RetirementIncomeFact, current_age: int) -> bool:
        """Checks if income is active for the given age."""
        return income.start_age <= current_age <= (income.end_age or 100)
    def _generate_metadata(self, income: RetirementIncomeFact, year: int, current_age: int,
                           inflation_adjustment: Decimal) -> Dict:
        """Creates metadata for income calculations."""
        return {
            "income_name": income.name,
            "owner": income.owner,
            "year": year,
            "current_age": current_age,
            "inflation_enabled": income.apply_inflation,
            "inflation_adjustment": str(inflation_adjustment),
            "start_age": income.start_age,
            "end_age": income.end_age or "Lifetime",
            "is_lifetime_income": income.end_age is None
        }
    def validate_retirement_income_facts(self, income_streams: List[RetirementIncomeFact]) -> None:
        """Validates income streams before calculation."""
        for income in income_streams:
            if income.annual_income <= 0:
                raise ValueError(f"Income stream {income.income_id} has invalid amount")
            if income.end_age is not None and income.start_age > income.end_age:
                raise ValueError(f"Income stream {income.income_id} has invalid age sequence")
    def get_lifetime_income_streams(self, results: List[IncomeCalculationResult]) -> List[IncomeCalculationResult]:
        """Returns lifetime income streams."""
        return [r for r in results if r.metadata["is_lifetime_income"]]
    def get_fixed_term_income_streams(self, results: List[IncomeCalculationResult]) -> List[IncomeCalculationResult]:
        """Returns fixed-term income streams."""
        return [r for r in results if not r.metadata["is_lifetime_income"]]
```

######## backend/database_operations/calculations/base_facts/__init__.py ########
```

```

######## backend/database_operations/crud/base_assumptions_crud.py ########
```
# backend/database_operations/crud/base_assumptions_crud.py
"""
Full CRUD operations for base assumptions following SQLAlchemy 2.0 style
Comprehensive validation:
Retirement and final ages within bounds
Valid age sequences for both people
Growth and inflation rates
Final age selector logic
Dynamic year calculations based on DOB and ages
Proper error handling and transaction management
Support for optional person 2 data
Validation against household data through plan relationship
Utility method for getting absolute year mappings
"""
from datetime import datetime
from typing import Optional, Dict, Any
from decimal import Decimal
from sqlalchemy import select, update, delete
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError, NoResultFound
from ..models import BaseAssumption, Plan
from ..validation.time_validation import (
    validate_positive_age,
    validate_age_sequence,
    validate_year_not_before_plan_creation
)
from ..utils.time_utils import get_age_in_year
from ..validation.money_validation import validate_rate
from ..utils.time_utils import get_start_year, get_retirement_year, get_final_projection_year
class BaseAssumptionCRUD:
    """CRUD operations for plan base assumptions."""
    def __init__(self, session: Session):
        self.session = session
    def create_base_assumptions(
        self,
        plan_id: int,
        retirement_age_1: int,
        final_age_1: int,
        default_growth_rate: float,
        inflation_rate: float,
        retirement_age_2: Optional[int] = None,
        final_age_2: Optional[int] = None,
        final_age_selector: int = 1,
    ) -> BaseAssumption:
        """
        Create base assumptions for a plan.
        Args:
            plan_id: ID of plan these assumptions belong to
            retirement_age_1: Retirement age for person 1
            final_age_1: Final age (life expectancy) for person 1
            default_growth_rate: Default annual growth rate for assets
            inflation_rate: Annual inflation rate
            retirement_age_2: Optional retirement age for person 2
            final_age_2: Optional final age for person 2
            final_age_selector: Which person's final age to use (1 or 2)
        Returns:
            Newly created BaseAssumption instance
        Raises:
            ValueError: If validation fails
            NoResultFound: If plan_id doesn't exist
            IntegrityError: If database constraint violated
        """
        # Verify plan exists
        stmt = select(Plan).where(Plan.plan_id == plan_id)
        plan = self.session.execute(stmt).scalar_one_or_none()
        if not plan:
            raise NoResultFound(f"Plan {plan_id} not found")
        # Validate retirement and final ages for person 1
        if not validate_positive_age(retirement_age_1):
            raise ValueError("Invalid retirement age for person 1")
        if not validate_positive_age(final_age_1):
            raise ValueError("Invalid final age for person 1")
        current_age = get_age_in_year(plan.household.person1_dob, datetime.now().year)
        if not validate_age_sequence(current_age, retirement_age_1, final_age_1):
            raise ValueError("Invalid age sequence for person 1")
        # Validate person 2 ages if provided
        if retirement_age_2 is not None:
            if not validate_positive_age(retirement_age_2):
                raise ValueError("Invalid retirement age for person 2")
            if final_age_2 is not None:
                if not validate_positive_age(final_age_2):
                    raise ValueError("Invalid final age for person 2")
                current_age_2 = get_age_in_year(plan.household.person2_dob, datetime.now().year)
                if not validate_age_sequence(current_age_2, retirement_age_2, final_age_2):
                    raise ValueError("Invalid age sequence for person 2")
        # Validate rates
        validate_rate(default_growth_rate, "default_growth_rate")
        validate_rate(inflation_rate, "inflation_rate")
        # Validate final age selector
        if final_age_selector not in [1, 2]:
            raise ValueError("final_age_selector must be 1 or 2")
        if final_age_selector == 2 and final_age_2 is None:
            raise ValueError("Cannot select person 2's final age when it's not provided")
        # Create base assumptions instance
        base_assumptions = BaseAssumption(
            plan_id=plan_id,
            retirement_age_1=retirement_age_1,
            retirement_age_2=retirement_age_2,
            final_age_1=final_age_1,
            final_age_2=final_age_2,
            final_age_selector=final_age_selector,
            default_growth_rate=default_growth_rate,
            inflation_rate=inflation_rate
        )
        try:
            self.session.add(base_assumptions)
            self.session.commit()
            return base_assumptions
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to create base assumptions", orig=e)
    def get_base_assumptions(self, plan_id: int) -> Optional[BaseAssumption]:
        """
        Retrieve base assumptions for a plan.
        Args:
            plan_id: ID of plan to get assumptions for
        Returns:
            BaseAssumption instance if found, None otherwise
        """
        stmt = select(BaseAssumption).where(BaseAssumption.plan_id == plan_id)
        return self.session.execute(stmt).scalar_one_or_none()
    def update_base_assumptions(
        self,
        plan_id: int,
        update_data: Dict[str, Any]
    ) -> Optional[BaseAssumption]:
        """
        Update base assumptions.
        Args:
            plan_id: ID of plan whose assumptions to update
            update_data: Dictionary of fields to update and their new values
        Returns:
            Updated BaseAssumption instance if found, None otherwise
        Raises:
            ValueError: If validation fails
            IntegrityError: If database constraint violated
        """
        # Get current assumptions and plan for validation
        stmt = select(BaseAssumption, Plan).join(Plan).where(BaseAssumption.plan_id == plan_id)
        result = self.session.execute(stmt).first()
        if not result:
            return None
        current_assumptions, plan = result
        # Validate rates if provided
        if 'default_growth_rate' in update_data:
            validate_rate(update_data['default_growth_rate'], "default_growth_rate")
        if 'inflation_rate' in update_data:
            validate_rate(update_data['inflation_rate'], "inflation_rate")
        # Validate ages if provided
        retirement_age_1 = update_data.get('retirement_age_1', current_assumptions.retirement_age_1)
        final_age_1 = update_data.get('final_age_1', current_assumptions.final_age_1)
        retirement_age_2 = update_data.get('retirement_age_2', current_assumptions.retirement_age_2)
        final_age_2 = update_data.get('final_age_2', current_assumptions.final_age_2)
        if 'retirement_age_1' in update_data or 'final_age_1' in update_data:
            if not validate_age_sequence(plan.household.person1_dob.year, retirement_age_1, final_age_1):
                raise ValueError("Invalid age sequence for person 1")
        if (retirement_age_2 is not None and 
            ('retirement_age_2' in update_data or 'final_age_2' in update_data)):
            if not validate_age_sequence(plan.household.person2_dob.year, retirement_age_2, final_age_2):
                raise ValueError("Invalid age sequence for person 2")
        try:
            # Perform the update
            stmt = (
                update(BaseAssumption)
                .where(BaseAssumption.plan_id == plan_id)
                .values(**update_data)
                .returning(BaseAssumption)
            )
            result = self.session.execute(stmt)
            self.session.commit()
            return result.scalar_one()
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to update base assumptions", orig=e)
    def delete_base_assumptions(self, plan_id: int) -> bool:
        """
        Delete base assumptions for a plan.
        Args:
            plan_id: ID of plan whose assumptions to delete
        Returns:
            True if assumptions were deleted, False if not found
        """
        stmt = delete(BaseAssumption).where(BaseAssumption.plan_id == plan_id)
        result = self.session.execute(stmt)
        self.session.commit()
        return result.rowcount > 0
    def get_year_mappings(self, plan_id: int) -> Dict[str, int]:
        """
        Get absolute year mappings for key plan dates.
        Args:
            plan_id: ID of plan to get mappings for
        Returns:
            Dictionary containing start_year, retirement_year, and end_year
        Raises:
            NoResultFound: If plan or assumptions not found
        """
        stmt = (
            select(BaseAssumption, Plan)
            .join(Plan)
            .where(BaseAssumption.plan_id == plan_id)
        )
        result = self.session.execute(stmt).first()
        if not result:
            raise NoResultFound(f"Base assumptions not found for plan {plan_id}")
        assumptions, plan = result
        # Determine which DOB to use based on final_age_selector
        if assumptions.final_age_selector == 1:
            dob = plan.household.person1_dob
            retirement_age = assumptions.retirement_age_1
            final_age = assumptions.final_age_1
        else:
            dob = plan.household.person2_dob
            retirement_age = assumptions.retirement_age_2
            final_age = assumptions.final_age_2
        # Calculate years using new utility functions
        start_year = get_start_year(plan.plan_creation_year)
        retirement_year = get_retirement_year(dob, retirement_age)
        end_year = get_final_projection_year(dob, final_age)
        return {
            'start_year': start_year,
            'retirement_year': retirement_year,
            'end_year': end_year
        }
```

######## backend/database_operations/crud/households_crud.py ########
```
# backend/database_operations/crud/households.py
"""
Full CRUD operations following SQLAlchemy 2.0 style
Proper validation of DOBs as required by core logic
Handles both required Person 1 and optional Person 2 data
Maintains created_at and updated_at timestamps
Cascade deletion of related plans (through SQLAlchemy relationship)
Proper error handling and transaction management
Additional utility method for household summary including plan count
"""
from datetime import date, datetime
from typing import List, Optional, Dict, Any
from sqlalchemy import select, update, delete
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
from ..models import Household
from ..validation.time_validation import validate_dob
class HouseholdCRUD:
    """Handles CRUD operations for households."""
    def __init__(self, session: Session):
        self.session = session
    def create_household(self, household_name: str, person1_first_name: str, person1_last_name: str, person1_dob: date,
                         person2_first_name: Optional[str] = None, person2_last_name: Optional[str] = None, person2_dob: Optional[date] = None) -> Household:
        """Creates a household with up to two members."""
        if not validate_dob(person1_dob):
            raise ValueError("Invalid date of birth for person 1")
        if person2_dob and not validate_dob(person2_dob):
            raise ValueError("Invalid date of birth for person 2")
        household = Household(
            household_name=household_name, person1_first_name=person1_first_name, person1_last_name=person1_last_name,
            person1_dob=person1_dob, person2_first_name=person2_first_name, person2_last_name=person2_last_name, person2_dob=person2_dob
        )
        try:
            self.session.add(household)
            self.session.commit()
            return household
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to create household", orig=e)
    def get_household(self, household_id: int) -> Optional[Household]:
        """Retrieves a household by ID."""
        return self.session.execute(select(Household).where(Household.household_id == household_id)).scalar_one_or_none()
    def get_all_households(self) -> List[Household]:
        """Returns all households."""
        return list(self.session.execute(select(Household)).scalars().all())
    def update_household(self, household_id: int, update_data: Dict[str, Any]) -> Optional[Household]:
        """Updates a household's information."""
        if 'person1_dob' in update_data and not validate_dob(update_data['person1_dob']):
            raise ValueError("Invalid date of birth for person 1")
        if 'person2_dob' in update_data and update_data['person2_dob'] and not validate_dob(update_data['person2_dob']):
            raise ValueError("Invalid date of birth for person 2")
        try:
            update_data['updated_at'] = datetime.now()
            result = self.session.execute(
                update(Household).where(Household.household_id == household_id).values(**update_data).returning(Household)
            )
            self.session.commit()
            return result.scalar_one_or_none()
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to update household", orig=e)
    def delete_household(self, household_id: int) -> bool:
        """Deletes a household by ID."""
        result = self.session.execute(delete(Household).where(Household.household_id == household_id))
        self.session.commit()
        return result.rowcount > 0
    def get_household_summary(self, household_id: int) -> Optional[Dict[str, Any]]:
        """Returns a summary of a household, including plan count."""
        household = self.get_household(household_id)
        if not household:
            return None
        return {
            'household_id': household.household_id,
            'household_name': household.household_name,
            'person1_name': f"{household.person1_first_name} {household.person1_last_name}",
            'person2_name': f"{household.person2_first_name} {household.person2_last_name}" if household.person2_first_name else None,
            'plan_count': len(household.plans),
            'created_at': household.created_at,
            'updated_at': household.updated_at
        }
```

######## backend/database_operations/crud/plans_crud.py ########
```
# backend/database_operations/crud/plans.py
"""
Full CRUD operations for plans following SQLAlchemy 2.0 style
Optional eager loading of relationships for detailed queries
Household existence verification on plan creation
Comprehensive plan summary including related entity counts
Timeline validation based on core logic requirements
Proper error handling and transaction management
Maintains created_at and updated_at timestamps
Cascade deletion handled through SQLAlchemy relationships
"""
from datetime import datetime
from typing import List, Optional, Dict, Any
from sqlalchemy import select, update, delete
from sqlalchemy.orm import Session, joinedload
from sqlalchemy.exc import IntegrityError, NoResultFound
from ..models import Plan, Household, BaseAssumption
from ..validation.scenario_timeline_validation import validate_projection_timeline
class PlanCRUD:
    """Handles CRUD operations for financial plans."""
    def __init__(self, session: Session):
        self.session = session
    def create_plan(self, household_id: int, plan_name: str) -> Plan:
        """Creates a financial plan for a household."""
        if not self.session.execute(select(Household).where(Household.household_id == household_id)).scalar_one_or_none():
            raise NoResultFound(f"Household {household_id} not found")
        plan = Plan(
            household_id=household_id, 
            plan_name=plan_name,
            plan_creation_year=datetime.now().year
        )
        try:
            self.session.add(plan)
            self.session.commit()
            return plan
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to create plan", orig=e)
    def get_plan(self, plan_id: int, include_relationships: bool = False) -> Optional[Plan]:
        """Retrieves a plan by ID, optionally loading related data."""
        stmt = select(Plan).where(Plan.plan_id == plan_id)
        if include_relationships:
            stmt = stmt.options(
                joinedload(Plan.base_assumptions), joinedload(Plan.scenarios),
                joinedload(Plan.asset_categories), joinedload(Plan.liability_categories),
                joinedload(Plan.assets), joinedload(Plan.liabilities),
                joinedload(Plan.inflows_outflows), joinedload(Plan.retirement_income_plans)
            )
        return self.session.execute(stmt).scalar_one_or_none()
    def get_household_plans(self, household_id: int) -> List[Plan]:
        """Returns all plans for a household."""
        return list(self.session.execute(select(Plan).where(Plan.household_id == household_id)).scalars().all())
    def update_plan(self, plan_id: int, update_data: Dict[str, Any]) -> Optional[Plan]:
        """Updates a financial plan."""
        try:
            update_data['updated_at'] = datetime.now()
            result = self.session.execute(
                update(Plan).where(Plan.plan_id == plan_id).values(**update_data).returning(Plan)
            )
            self.session.commit()
            return result.scalar_one_or_none()
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to update plan", orig=e)
    def delete_plan(self, plan_id: int) -> bool:
        """Deletes a plan by ID."""
        result = self.session.execute(delete(Plan).where(Plan.plan_id == plan_id))
        self.session.commit()
        return result.rowcount > 0
    def get_plan_summary(self, plan_id: int) -> Optional[Dict[str, Any]]:
        """Returns a summary of a plan including related entity counts."""
        plan = self.get_plan(plan_id, include_relationships=True)
        if not plan:
            return None
        return {
            'plan_id': plan.plan_id,
            'plan_name': plan.plan_name,
            'household_id': plan.household_id,
            'scenario_count': len(plan.scenarios),
            'asset_count': len(plan.assets),
            'liability_count': len(plan.liabilities),
            'cash_flow_count': len(plan.inflows_outflows),
            'retirement_income_count': len(plan.retirement_income_plans),
            'has_base_assumptions': plan.base_assumptions is not None,
            'created_at': plan.created_at,
            'updated_at': plan.updated_at
        }
    def validate_plan_timeline(self, plan_id: int) -> bool:
        """Validates if a plan's timeline is logically consistent."""
        plan = self.get_plan(plan_id)
        if not plan or not plan.base_assumptions:
            return False
        start_year = datetime.now().year
        return validate_projection_timeline(
            start_year, plan.base_assumptions.retirement_age_1, plan.base_assumptions.final_age_1
        )
```

######## backend/database_operations/crud/scenarios_crud.py ########
```
from datetime import datetime
from typing import List, Optional, Dict, Any
from sqlalchemy import select, update, delete
from sqlalchemy.orm import Session, joinedload
from sqlalchemy.exc import IntegrityError, NoResultFound
from ..models import Scenario, ScenarioAssumption, ScenarioOverride, Plan
from ..validation.money_validation import validate_positive_amount, validate_rate
from ..validation.time_validation import validate_year_range, validate_year_not_before_plan_creation
class ScenarioCRUD:
    """Handles CRUD operations for scenarios."""
    def __init__(self, session: Session):
        self.session = session
    def create_scenario(self, plan_id: int, scenario_name: str, scenario_color: Optional[str] = None,
                        assumptions: Optional[Dict[str, Any]] = None) -> Scenario:
        """Creates a scenario for a given plan."""
        # Get plan with base assumptions
        plan = self.session.execute(
            select(Plan)
            .options(joinedload(Plan.base_assumptions))
            .where(Plan.plan_id == plan_id)
        ).scalar_one_or_none()
        if not plan:
            raise NoResultFound(f"Plan {plan_id} not found")
        scenario = Scenario(plan_id=plan_id, scenario_name=scenario_name, scenario_color=scenario_color)
        try:
            self.session.add(scenario)
            self.session.flush()  # Get scenario_id
            # Clone base assumptions and merge with any provided overrides
            base_assumption_values = {}
            if plan.base_assumptions:
                base_assumption_values = {
                    'retirement_age_1': plan.base_assumptions.retirement_age_1,
                    'retirement_age_2': plan.base_assumptions.retirement_age_2,
                    'default_growth_rate': plan.base_assumptions.default_growth_rate,
                    'inflation_rate': plan.base_assumptions.inflation_rate
                }
            # Merge with provided assumptions
            if assumptions:
                base_assumption_values.update(assumptions)
            # Validate rates
            if 'default_growth_rate' in base_assumption_values:
                validate_rate(base_assumption_values['default_growth_rate'], "default_growth_rate")
            if 'inflation_rate' in base_assumption_values:
                validate_rate(base_assumption_values['inflation_rate'], "inflation_rate")
            if 'annual_retirement_spending' in base_assumption_values:
                validate_positive_amount(base_assumption_values['annual_retirement_spending'], "annual_retirement_spending")
            # Create scenario assumptions
            self.session.add(ScenarioAssumption(
                scenario_id=scenario.scenario_id,
                **base_assumption_values
            ))
            self.session.commit()
            return scenario
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to create scenario", orig=e)
    def add_overrides(self, scenario_id: int, overrides: List[Dict[str, Any]]) -> List[ScenarioOverride]:
        """
        Bulk adds overrides for a scenario.
        overrides = [
            {
                'asset_id': 1,  # Optional - one of asset_id/liability_id/etc must be set
                'liability_id': None,
                'inflow_outflow_id': None,
                'retirement_income_plan_id': None,
                'override_field': 'value',  # What's being changed
                'override_value': '500000'  # New value
            },
            ...
        ]
        """
        scenario_overrides = []
        for override in overrides:
            if not any([override.get('asset_id'), override.get('liability_id'), 
                       override.get('inflow_outflow_id'), override.get('retirement_income_plan_id')]):
                raise ValueError("Override must have a valid target")
            scenario_override = ScenarioOverride(
                scenario_id=scenario_id,
                **override
            )
            self.session.add(scenario_override)
            scenario_overrides.append(scenario_override)
        try:
            self.session.commit()
            return scenario_overrides
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to create overrides", orig=e)
    def add_override(self, scenario_id: int, override_field: str, override_value: str,
                     asset_id: Optional[int] = None, liability_id: Optional[int] = None,
                     inflow_outflow_id: Optional[int] = None, retirement_income_plan_id: Optional[int] = None) -> ScenarioOverride:
        """Adds an override to a scenario for a specific financial component."""
        if not any([asset_id, liability_id, inflow_outflow_id, retirement_income_plan_id]):
            raise ValueError("Override must have a valid target")
        override = ScenarioOverride(
            scenario_id=scenario_id, 
            override_field=override_field, 
            override_value=override_value,
            asset_id=asset_id, 
            liability_id=liability_id, 
            inflow_outflow_id=inflow_outflow_id,
            retirement_income_plan_id=retirement_income_plan_id
        )
        try:
            self.session.add(override)
            self.session.commit()
            return override
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to create override", orig=e)
    def get_scenario(self, scenario_id: int, include_assumptions: bool = False, include_overrides: bool = False) -> Optional[Scenario]:
        """Retrieves a scenario by ID, optionally loading assumptions and overrides."""
        stmt = select(Scenario).where(Scenario.scenario_id == scenario_id)
        if include_assumptions:
            stmt = stmt.options(joinedload(Scenario.assumptions))
        if include_overrides:
            stmt = stmt.options(joinedload(Scenario.overrides))
        return self.session.execute(stmt).scalar_one_or_none()
    def get_plan_scenarios(self, plan_id: int) -> List[Scenario]:
        """Returns all scenarios linked to a plan."""
        return list(self.session.execute(select(Scenario).where(Scenario.plan_id == plan_id)).scalars().all())
    def update_scenario(self, scenario_id: int, update_data: Dict[str, Any],
                        assumption_updates: Optional[Dict[str, Any]] = None) -> Optional[Scenario]:
        """Updates a scenario and its assumptions if provided."""
        try:
            scenario = self.session.execute(
                update(Scenario).where(Scenario.scenario_id == scenario_id).values(**update_data).returning(Scenario)
            ).scalar_one_or_none()
            if not scenario:
                return None
            if assumption_updates:
                if 'default_growth_rate' in assumption_updates:
                    validate_rate(assumption_updates['default_growth_rate'], "default_growth_rate")
                if 'inflation_rate' in assumption_updates:
                    validate_rate(assumption_updates['inflation_rate'], "inflation_rate")
                if 'annual_retirement_spending' in assumption_updates:
                    validate_positive_amount(assumption_updates['annual_retirement_spending'], "annual_retirement_spending")
                self.session.execute(update(ScenarioAssumption).where(ScenarioAssumption.scenario_id == scenario_id).values(**assumption_updates))
            self.session.commit()
            return scenario
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to update scenario", orig=e)
    def update_override(self, override_id: int, override_field: str, override_value: str) -> Optional[ScenarioOverride]:
        """Updates an existing override's field and value."""
        try:
            result = self.session.execute(
                update(ScenarioOverride)
                .where(ScenarioOverride.override_id == override_id)
                .values(override_field=override_field, override_value=override_value)
                .returning(ScenarioOverride)
            )
            self.session.commit()
            return result.scalar_one_or_none()
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to update override", orig=e)
    def remove_override(self, override_id: int) -> bool:
        """Deletes a specific scenario override."""
        result = self.session.execute(delete(ScenarioOverride).where(ScenarioOverride.override_id == override_id))
        self.session.commit()
        return result.rowcount > 0
    def delete_scenario(self, scenario_id: int) -> bool:
        """Deletes a scenario by ID."""
        result = self.session.execute(delete(Scenario).where(Scenario.scenario_id == scenario_id))
        self.session.commit()
        return result.rowcount > 0
    def get_scenario_summary(self, scenario_id: int) -> Optional[Dict[str, Any]]:
        """Returns a summary of a scenario, including override counts."""
        scenario = self.get_scenario(scenario_id, include_assumptions=True, include_overrides=True)
        if not scenario:
            return None
        return {
            'scenario_id': scenario.scenario_id,
            'scenario_name': scenario.scenario_name,
            'plan_id': scenario.plan_id,
            'has_assumptions': scenario.assumptions is not None,
            'override_counts': {
                'asset_overrides': sum(1 for o in scenario.overrides if o.asset_id),
                'liability_overrides': sum(1 for o in scenario.overrides if o.liability_id),
                'cash_flow_overrides': sum(1 for o in scenario.overrides if o.inflow_outflow_id),
                'retirement_income_overrides': sum(1 for o in scenario.overrides if o.retirement_income_plan_id)
            },
            'created_at': scenario.created_at
        }
```

######## backend/database_operations/crud/__init__.py ########
```

```

######## backend/database_operations/crud/financial/assets_crud.py ########
```
# backend/database_operations/crud/financial/assets.py
"""
Full CRUD operations for assets following SQLAlchemy 2.0 style
Support for all three types of growth rate configurations:
Default (no override)
Simple override
Stepwise configuration
Proper validation of:
Asset values (positive)
Growth rates
Stepwise period configuration
Owner values
Comprehensive asset summary including growth configuration
Support for filtering assets by category
Proper error handling and transaction management
Clean handling of growth rate configuration updates
"""
from typing import List, Optional, Dict, Any, Union
from decimal import Decimal
from sqlalchemy import select, update, delete, and_
from sqlalchemy.orm import Session, joinedload
from sqlalchemy.exc import IntegrityError, NoResultFound
from ...models import Asset, AssetCategory, GrowthRateConfiguration, Plan
from ...validation.money_validation import validate_positive_amount, validate_rate, validate_owner
from ...utils.money_utils import to_decimal, to_float
from ...validation.growth_validation import validate_stepwise_periods, validate_growth_config_type
from ...validation.time_validation import validate_year_not_before_plan_creation
class AssetCRUD:
    """Handles CRUD operations for assets and growth rates."""
    def __init__(self, session: Session):
        self.session = session
    def create_asset(self, plan_id: int, asset_category_id: int, asset_name: str, value: Union[float, str, Decimal],
                     owner: str, include_in_nest_egg: bool = True, growth_config: Optional[Dict[str, Any]] = None) -> Asset:
        """Creates an asset with optional growth configuration."""
        if not self.session.execute(select(Plan).join(AssetCategory).where(
                and_(Plan.plan_id == plan_id, AssetCategory.asset_category_id == asset_category_id))).scalar_one_or_none():
            raise NoResultFound(f"Plan {plan_id} or category {asset_category_id} not found")
        decimal_value = to_decimal(value)
        validate_positive_amount(decimal_value, "asset_value")
        validate_owner(owner, "owner")
        asset = Asset(
            plan_id=plan_id, asset_category_id=asset_category_id, asset_name=asset_name,
            value=to_float(decimal_value), owner=owner, include_in_nest_egg=include_in_nest_egg
        )
        try:
            self.session.add(asset)
            self.session.flush()
            if growth_config:
                self._add_growth_configuration(asset.asset_id, growth_config)
            self.session.commit()
            return asset
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to create asset", orig=e)
    def get_asset(self, asset_id: int, include_growth_config: bool = False) -> Optional[Asset]:
        """Retrieves an asset by ID."""
        stmt = select(Asset).where(Asset.asset_id == asset_id)
        if include_growth_config:
            stmt = stmt.options(joinedload(Asset.growth_rates))
        return self.session.execute(stmt).scalar_one_or_none()
    def get_plan_assets(self, plan_id: int, category_id: Optional[int] = None) -> List[Asset]:
        """Retrieves all assets for a plan, optionally filtered by category."""
        stmt = select(Asset).where(Asset.plan_id == plan_id)
        if category_id:
            stmt = stmt.where(Asset.asset_category_id == category_id)
        return list(self.session.execute(stmt).scalars().all())
    def update_asset(self, asset_id: int, update_data: Dict[str, Any],
                     growth_config: Optional[Dict[str, Any]] = None) -> Optional[Asset]:
        """Updates an asset and its growth configuration if provided."""
        if "value" in update_data:
            decimal_value = to_decimal(update_data["value"])
            validate_positive_amount(decimal_value, "asset_value")
            update_data["value"] = to_float(decimal_value)
        if "owner" in update_data:
            validate_owner(update_data["owner"], "owner")
        try:
            result = self.session.execute(update(Asset)
                                          .where(Asset.asset_id == asset_id)
                                          .values(**update_data)
                                          .returning(Asset))
            asset = result.scalar_one_or_none()
            if asset and growth_config:
                self.session.execute(delete(GrowthRateConfiguration).where(GrowthRateConfiguration.asset_id == asset_id))
                self._add_growth_configuration(asset_id, growth_config)
            self.session.commit()
            return asset
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to update asset", orig=e)
    def delete_asset(self, asset_id: int) -> bool:
        """Deletes an asset by ID."""
        result = self.session.execute(delete(Asset).where(Asset.asset_id == asset_id))
        self.session.commit()
        return result.rowcount > 0
    def _add_growth_configuration(self, asset_id: int, config: Dict[str, Any]) -> None:
        """Adds a growth rate configuration for an asset."""
        plan = self.session.execute(select(Plan).join(Asset).where(Asset.asset_id == asset_id)).scalar_one()
        if not plan.plan_creation_year:
            raise ValueError("Plan creation year must be set before configuring growth rates")
        config_type = config.get("configuration_type")
        validate_growth_config_type(config_type, "configuration_type")
        if config_type == "STEPWISE":
            periods = config.get("periods", [])
            for period in periods:
                if not validate_year_not_before_plan_creation(period["start_year"], plan.plan_creation_year):
                    raise ValueError(f"Growth period cannot start before plan creation year {plan.plan_creation_year}")
            validate_stepwise_periods(periods, "growth_periods")
            for period in periods:
                validate_rate(to_decimal(period["growth_rate"]), "growth_rate")
                self.session.add(GrowthRateConfiguration(
                    asset_id=asset_id, configuration_type="STEPWISE",
                    start_year=period["start_year"], end_year=period["end_year"],
                    growth_rate=to_float(to_decimal(period["growth_rate"]))
                ))
        else:
            validate_rate(to_decimal(config["growth_rate"]), "growth_rate")
            self.session.add(GrowthRateConfiguration(
                asset_id=asset_id, configuration_type=config_type,
                start_year=plan.plan_creation_year, end_year=config.get("end_year"),
                growth_rate=to_float(to_decimal(config["growth_rate"]))
            ))
    def get_asset_summary(self, asset_id: int) -> Optional[Dict[str, Any]]:
        """Returns a summary of an asset, including growth configuration."""
        asset = self.get_asset(asset_id, include_growth_config=True)
        if not asset:
            return None
        growth_config = None
        if asset.growth_rates:
            if len(asset.growth_rates) == 1:
                config = asset.growth_rates[0]
                growth_config = {"type": config.configuration_type, "rate": config.growth_rate}
            else:
                growth_config = {
                    "type": "STEPWISE",
                    "periods": [{"start_year": config.start_year, "end_year": config.end_year, "rate": config.growth_rate}
                                for config in sorted(asset.growth_rates, key=lambda x: x.start_year)]
                }
        return {
            "asset_id": asset.asset_id,
            "asset_name": asset.asset_name,
            "category_id": asset.asset_category_id,
            "value": asset.value,
            "owner": asset.owner,
            "include_in_nest_egg": asset.include_in_nest_egg,
            "growth_configuration": growth_config
        }
```

######## backend/database_operations/crud/financial/cash_flows_crud.py ########
```
# backend/database_operations/crud/financial/cash_flows_crud.py
"""
Full CRUD operations for cash flows following SQLAlchemy 2.0 style.
Handles discrete event cash flows (like college expenses or inheritances).
Core functionality:
- Create/update/delete cash flows
- Basic validation
- Support for single-year and multi-year discrete events
- Optional inflation adjustment
"""
from typing import List, Optional, Dict, Any
from sqlalchemy import select, update, delete
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError, NoResultFound
from ...models import InflowOutflow, Plan
from ...validation.money_validation import validate_positive_amount
from ...validation.time_validation import validate_year_not_before_plan_creation
from ...utils.time_utils import get_years_between
class CashFlowCRUD:
    """Handles CRUD operations for inflow/outflow management."""
    def __init__(self, session: Session):
        self.session = session
    def create_cash_flow(self, plan_id: int, name: str, flow_type: str, annual_amount: float, start_year: int,
                         end_year: Optional[int] = None, apply_inflation: bool = False) -> InflowOutflow:
        """Creates a cash flow event for a financial plan."""
        plan = self.session.execute(select(Plan).where(Plan.plan_id == plan_id)).scalar_one_or_none()
        if not plan:
            raise NoResultFound(f"Plan {plan_id} not found")
        if flow_type not in {"inflow", "outflow"}:
            raise ValueError("Type must be 'inflow' or 'outflow'")
        validate_positive_amount(annual_amount, "annual_amount")
        end_year = end_year or start_year
        if not validate_year_not_before_plan_creation(start_year, plan.plan_creation_year):
            raise ValueError("Start year cannot be before plan creation year")
        if start_year > end_year:
            raise ValueError("Start year must be before or equal to end year")
        if get_years_between(start_year, end_year) > 30:
            raise ValueError("Cash flows must be limited duration events")
        cash_flow = InflowOutflow(
            plan_id=plan_id, name=name, type=flow_type, annual_amount=annual_amount,
            start_year=start_year, end_year=end_year, apply_inflation=apply_inflation
        )
        try:
            self.session.add(cash_flow)
            self.session.commit()
            return cash_flow
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to create cash flow", orig=e)
    def get_cash_flow(self, flow_id: int) -> Optional[InflowOutflow]:
        """Retrieves a cash flow by ID."""
        return self.session.execute(select(InflowOutflow).where(
            InflowOutflow.inflow_outflow_id == flow_id)).scalar_one_or_none()
    def get_plan_cash_flows(self, plan_id: int, flow_type: Optional[str] = None,
                            year: Optional[int] = None) -> List[InflowOutflow]:
        """Retrieves cash flows for a plan, optionally filtered by type and year."""
        stmt = select(InflowOutflow).where(InflowOutflow.plan_id == plan_id)
        if flow_type:
            stmt = stmt.where(InflowOutflow.type == flow_type)
        if year:
            stmt = stmt.where(InflowOutflow.start_year <= year, InflowOutflow.end_year >= year)
        return list(self.session.execute(stmt).scalars().all())
    def update_cash_flow(self, flow_id: int, update_data: Dict[str, Any]) -> Optional[InflowOutflow]:
        """Updates a cash flow event."""
        if "annual_amount" in update_data:
            validate_positive_amount(update_data["annual_amount"], "annual_amount")
        if "type" in update_data and update_data["type"] not in {"inflow", "outflow"}:
            raise ValueError("Type must be 'inflow' or 'outflow'")
        if "start_year" in update_data or "end_year" in update_data:
            current_flow = self.get_cash_flow(flow_id)
            if not current_flow:
                return None
            start_year = update_data.get("start_year", current_flow.start_year)
            end_year = update_data.get("end_year", current_flow.end_year)
            if start_year > end_year:
                raise ValueError("Start year must be before or equal to end year")
            if end_year - start_year > 30:
                raise ValueError("Cash flows must be limited duration events")
        try:
            result = self.session.execute(update(InflowOutflow)
                                          .where(InflowOutflow.inflow_outflow_id == flow_id)
                                          .values(**update_data)
                                          .returning(InflowOutflow))
            self.session.commit()
            return result.scalar_one_or_none()
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to update cash flow", orig=e)
    def delete_cash_flow(self, flow_id: int) -> bool:
        """Deletes a cash flow event."""
        result = self.session.execute(delete(InflowOutflow).where(
            InflowOutflow.inflow_outflow_id == flow_id))
        self.session.commit()
        return result.rowcount > 0
```

######## backend/database_operations/crud/financial/growth_rates_crud.py ########
```
# backend/database_operations/crud/financial/growth_rates.py
"""
Full CRUD operations for growth configurations following SQLAlchemy 2.0 style
Support for all three configuration types:
Default (base rate)
Override (fixed rate)
Stepwise (multiple periods)
Proper validation of:
Configuration types
Growth rates
Year sequences
Target specification
Support for multiple targets:
Assets
Retirement income
Scenarios
Special handling for stepwise configurations
Comprehensive configuration summary
Utility for determining applicable rate
Proper error handling and transaction management
"""
from typing import List, Optional, Dict, Any
from sqlalchemy import select, update, delete, and_
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
from ...models import GrowthRateConfiguration, Asset, RetirementIncomePlan, Scenario
from ...validation.money_validation import validate_rate
from ...validation.growth_validation import validate_stepwise_periods, validate_growth_config_type
from ...validation.time_validation import validate_year_not_before_plan_creation
class GrowthRateCRUD:
    """Handles CRUD operations for growth rate configurations."""
    def __init__(self, session: Session):
        self.session = session
    def create_growth_config(self, configuration_type: str, start_year: int, growth_rate: float,
                             end_year: Optional[int] = None, asset_id: Optional[int] = None,
                             retirement_income_plan_id: Optional[int] = None,
                             scenario_id: Optional[int] = None) -> GrowthRateConfiguration:
        """Creates a growth rate configuration for an asset, retirement income, or scenario."""
        validate_growth_config_type(configuration_type, "configuration_type")
        if sum(x is not None for x in [asset_id, retirement_income_plan_id, scenario_id]) != 1:
            raise ValueError("Must specify exactly one target (asset, retirement income, or scenario)")
        validate_rate(growth_rate, "growth_rate")
        if end_year is not None and start_year > end_year:
            raise ValueError("Start year must be before or equal to end year")
        config = GrowthRateConfiguration(
            configuration_type=configuration_type, start_year=start_year, end_year=end_year,
            growth_rate=growth_rate, asset_id=asset_id, retirement_income_plan_id=retirement_income_plan_id,
            scenario_id=scenario_id
        )
        try:
            self.session.add(config)
            self.session.commit()
            return config
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to create growth configuration", orig=e)
    def create_stepwise_config(self, periods: List[Dict[str, Any]], asset_id: Optional[int] = None,
                               retirement_income_plan_id: Optional[int] = None,
                               scenario_id: Optional[int] = None) -> List[GrowthRateConfiguration]:
        """Creates multiple stepwise growth rate configurations."""
        if sum(x is not None for x in [asset_id, retirement_income_plan_id, scenario_id]) != 1:
            raise ValueError("Must specify exactly one target (asset, retirement income, or scenario)")
        if not validate_stepwise_periods([(p["start_year"], p["end_year"]) for p in periods]):
            raise ValueError("Stepwise periods must be chronological and non-overlapping")
        for period in periods:
            validate_rate(period["growth_rate"], "growth_rate")
        try:
            configs = [GrowthRateConfiguration(
                configuration_type="STEPWISE", start_year=p["start_year"], end_year=p["end_year"],
                growth_rate=p["growth_rate"], asset_id=asset_id, retirement_income_plan_id=retirement_income_plan_id,
                scenario_id=scenario_id
            ) for p in periods]
            self.session.add_all(configs)
            self.session.commit()
            return configs
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to create stepwise configurations", orig=e)
    def get_growth_config(self, config_id: int) -> Optional[GrowthRateConfiguration]:
        """Retrieves a growth configuration by ID."""
        return self.session.execute(select(GrowthRateConfiguration).where(
            GrowthRateConfiguration.growth_rate_id == config_id)).scalar_one_or_none()
    def get_configurations_for_target(self, target_type: str, target_id: int) -> List[GrowthRateConfiguration]:
        """Retrieves all growth configurations for a given target."""
        target_map = {
            "asset": GrowthRateConfiguration.asset_id,
            "retirement_income": GrowthRateConfiguration.retirement_income_plan_id,
            "scenario": GrowthRateConfiguration.scenario_id
        }
        if target_type not in target_map:
            raise ValueError("Invalid target type")
        return list(self.session.execute(select(GrowthRateConfiguration)
                                         .where(target_map[target_type] == target_id)
                                         .order_by(GrowthRateConfiguration.start_year)).scalars().all())
    def update_growth_config(self, config_id: int, update_data: Dict[str, Any]) -> Optional[GrowthRateConfiguration]:
        """Updates a growth configuration."""
        if "configuration_type" in update_data and update_data["configuration_type"] not in {"DEFAULT", "OVERRIDE", "STEPWISE"}:
            raise ValueError("Invalid configuration type")
        if "growth_rate" in update_data:
            validate_rate(update_data["growth_rate"], "growth_rate")
        if "start_year" in update_data or "end_year" in update_data:
            config = self.get_growth_config(config_id)
            if not config:
                return None
            start_year = update_data.get("start_year", config.start_year)
            end_year = update_data.get("end_year", config.end_year)
            if end_year is not None and start_year > end_year:
                raise ValueError("Start year must be before or equal to end year")
        try:
            result = self.session.execute(update(GrowthRateConfiguration)
                                          .where(GrowthRateConfiguration.growth_rate_id == config_id)
                                          .values(**update_data)
                                          .returning(GrowthRateConfiguration))
            self.session.commit()
            return result.scalar_one_or_none()
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to update growth configuration", orig=e)
    def delete_growth_config(self, config_id: int) -> bool:
        """Deletes a growth configuration."""
        result = self.session.execute(delete(GrowthRateConfiguration)
                                      .where(GrowthRateConfiguration.growth_rate_id == config_id))
        self.session.commit()
        return result.rowcount > 0
    def get_growth_config_summary(self, config_id: int) -> Optional[Dict[str, Any]]:
        """Returns a summary of a growth configuration."""
        config = self.get_growth_config(config_id)
        if not config:
            return None
        target_type, target_id = None, None
        if config.asset_id:
            target_type, target_id = "asset", config.asset_id
        elif config.retirement_income_plan_id:
            target_type, target_id = "retirement_income", config.retirement_income_plan_id
        elif config.scenario_id:
            target_type, target_id = "scenario", config.scenario_id
        return {
            "config_id": config.growth_rate_id,
            "type": config.configuration_type,
            "growth_rate": config.growth_rate,
            "start_year": config.start_year,
            "end_year": config.end_year,
            "target_type": target_type,
            "target_id": target_id,
            "is_stepwise": config.configuration_type == "STEPWISE"
        }
    def get_applicable_rate(self, year: int, target_type: str, target_id: int, default_rate: float) -> float:
        """Returns the applicable growth rate for a specific year."""
        for config in self.get_configurations_for_target(target_type, target_id):
            if config.start_year <= year and (config.end_year is None or config.end_year >= year):
                return config.growth_rate
        return default_rate
```

######## backend/database_operations/crud/financial/liabilities_crud.py ########
```
# backend/database_operations/crud/financial/liabilities_crud.py
"""
Full CRUD operations for liabilities following SQLAlchemy 2.0 style
Simple interest rate handling (vs. complex growth rates for assets)
Proper validation of:
Liability values (positive)
Interest rates (if provided)
Owner values
Support for filtering liabilities by category
Comprehensive liability summary
Additional utility for calculating total liabilities
Proper error handling and transaction management
Support for nest egg inclusion/exclusion
The key difference from assets.py is the simpler growth model - liabilities just have an optional interest rate rather than the complex growth rate configurations used for assets.
"""
from datetime import datetime
from typing import List, Optional, Dict, Any
from sqlalchemy import select, update, delete, and_
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError, NoResultFound
from ...models import Liability, LiabilityCategory, Plan
from ...validation.money_validation import validate_positive_amount, validate_rate, validate_owner
class LiabilityCRUD:
    """Handles CRUD operations for liabilities."""
    def __init__(self, session: Session):
        self.session = session
    def create_liability(self, plan_id: int, liability_category_id: int, liability_name: str, value: float, owner: str,
                         interest_rate: Optional[float] = None, include_in_nest_egg: bool = True) -> Liability:
        """Creates a liability linked to a plan and category."""
        stmt = select(Plan).join(LiabilityCategory).where(
            and_(Plan.plan_id == plan_id, LiabilityCategory.liability_category_id == liability_category_id)
        )
        if not self.session.execute(stmt).scalar_one_or_none():
            raise NoResultFound(f"Plan {plan_id} or category {liability_category_id} not found")
        validate_positive_amount(value, "liability_value")
        if interest_rate is not None:
            validate_rate(interest_rate, "interest_rate")
        validate_owner(owner, "owner")
        liability = Liability(
            plan_id=plan_id, liability_category_id=liability_category_id, liability_name=liability_name,
            value=value, owner=owner, interest_rate=interest_rate, include_in_nest_egg=include_in_nest_egg
        )
        try:
            self.session.add(liability)
            self.session.commit()
            return liability
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to create liability", orig=e)
    def get_liability(self, liability_id: int) -> Optional[Liability]:
        """Retrieves a liability by ID."""
        return self.session.execute(
            select(Liability).join(Plan).where(Liability.liability_id == liability_id)
        ).scalar_one_or_none()
    def get_plan_liabilities(self, plan_id: int, category_id: Optional[int] = None) -> List[Liability]:
        """Returns all liabilities for a plan, optionally filtered by category."""
        stmt = select(Liability).join(Plan).where(Liability.plan_id == plan_id)
        if category_id:
            stmt = stmt.where(Liability.liability_category_id == category_id)
        return list(self.session.execute(stmt).scalars().all())
    def update_liability(self, liability_id: int, update_data: Dict[str, Any]) -> Optional[Liability]:
        """Updates a liability."""
        if 'value' in update_data:
            validate_positive_amount(update_data['value'], "liability_value")
        if 'interest_rate' in update_data and update_data['interest_rate'] is not None:
            validate_rate(update_data['interest_rate'], "interest_rate")
        if 'owner' in update_data and update_data['owner'] not in {"person1", "person2", "joint"}:
            raise ValueError("Invalid owner value")
        try:
            stmt = update(Liability).where(Liability.liability_id == liability_id).values(**update_data).returning(Liability)
            result = self.session.execute(stmt)
            self.session.commit()
            return result.scalar_one_or_none()
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to update liability", orig=e)
    def delete_liability(self, liability_id: int) -> bool:
        """Deletes a liability by ID."""
        result = self.session.execute(delete(Liability).where(Liability.liability_id == liability_id))
        self.session.commit()
        return result.rowcount > 0
    def get_liability_summary(self, liability_id: int) -> Optional[Dict[str, Any]]:
        """Returns a summary of a liability, including plan creation year."""
        result = self.session.execute(
            select(Liability, Plan.plan_creation_year).join(Plan).where(Liability.liability_id == liability_id)
        ).first()
        if not result:
            return None
        liability, plan_creation_year = result
        return {
            'liability_id': liability.liability_id,
            'liability_name': liability.liability_name,
            'category_id': liability.liability_category_id,
            'value': liability.value,
            'owner': liability.owner,
            'interest_rate': liability.interest_rate,
            'include_in_nest_egg': liability.include_in_nest_egg,
            'has_interest': liability.interest_rate is not None,
            'plan_creation_year': plan_creation_year
        }
    def get_total_liabilities(self, plan_id: int, include_in_nest_egg_only: bool = False) -> float:
        """Calculates total liability value for a plan."""
        stmt = select(Liability).join(Plan).where(Liability.plan_id == plan_id)
        if include_in_nest_egg_only:
            stmt = stmt.where(Liability.include_in_nest_egg.is_(True))
        liabilities = self.session.execute(stmt).scalars().all()
        return sum(liability.value for liability in liabilities)
```

######## backend/database_operations/crud/financial/retirement_income_crud.py ########
```
# backend/database_operations/crud/financial/retirement.py
"""
Full CRUD operations for retirement income following SQLAlchemy 2.0 style
Support for optional growth rate configuration
Proper validation of:
Income amounts (positive)
Owner values
Age sequence
Support for:
Filtering by owner
Inflation toggle
Nest egg inclusion/exclusion
Optional end age
Comprehensive income summary including:
Duration calculation
Lifetime income detection
Growth rate presence
Additional utility for calculating total income at specific age
Proper error handling and transaction management
"""
from typing import List, Optional, Dict, Any
from sqlalchemy import select, update, delete
from sqlalchemy.orm import Session, joinedload
from sqlalchemy.exc import IntegrityError, NoResultFound
from ...models import RetirementIncomePlan, Plan, GrowthRateConfiguration
from ...validation.money_validation import validate_positive_amount, validate_rate
from ...validation.time_validation import validate_positive_age, validate_age_sequence
from ...utils.time_utils import get_age_in_year
class RetirementIncomeCRUD:
    """Handles CRUD operations for retirement income plans."""
    def __init__(self, session: Session):
        self.session = session
    def create_retirement_income(self, plan_id: int, name: str, owner: str, annual_income: float, start_age: int,
                                 end_age: Optional[int] = None, include_in_nest_egg: bool = True,
                                 apply_inflation: bool = False, growth_config: Optional[Dict[str, Any]] = None) -> RetirementIncomePlan:
        """Creates a retirement income plan."""
        if not self.session.execute(select(Plan).where(Plan.plan_id == plan_id)).scalar_one_or_none():
            raise NoResultFound(f"Plan {plan_id} not found")
        validate_positive_amount(annual_income, "annual_income")
        if owner not in {"person1", "person2", "joint"}:
            raise ValueError("Invalid owner value")
        if not validate_positive_age(start_age):
            raise ValueError("Start age must be positive")
        if end_age is not None:
            if not validate_positive_age(end_age):
                raise ValueError("End age must be positive")
            if not validate_age_sequence(start_age, start_age, end_age):
                raise ValueError("Start age must be before or equal to end age")
        income_plan = RetirementIncomePlan(
            plan_id=plan_id, name=name, owner=owner, annual_income=annual_income, start_age=start_age,
            end_age=end_age, include_in_nest_egg=include_in_nest_egg, apply_inflation=apply_inflation
        )
        try:
            self.session.add(income_plan)
            self.session.flush()
            if growth_config:
                self._add_growth_configuration(income_plan.income_plan_id, growth_config)
            self.session.commit()
            return income_plan
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to create retirement income plan", orig=e)
    def get_retirement_income(self, income_id: int, include_growth_config: bool = False) -> Optional[RetirementIncomePlan]:
        """Retrieves a retirement income plan by ID."""
        stmt = select(RetirementIncomePlan).where(RetirementIncomePlan.income_plan_id == income_id)
        if include_growth_config:
            stmt = stmt.options(joinedload(RetirementIncomePlan.growth_rates))
        return self.session.execute(stmt).scalar_one_or_none()
    def get_plan_retirement_income(self, plan_id: int, owner: Optional[str] = None) -> List[RetirementIncomePlan]:
        """Returns all retirement income plans for a plan, optionally filtered by owner."""
        stmt = select(RetirementIncomePlan).where(RetirementIncomePlan.plan_id == plan_id)
        if owner:
            stmt = stmt.where(RetirementIncomePlan.owner == owner)
        return list(self.session.execute(stmt).scalars().all())
    def update_retirement_income(self, income_id: int, update_data: Dict[str, Any],
                                 growth_config: Optional[Dict[str, Any]] = None) -> Optional[RetirementIncomePlan]:
        """Updates a retirement income plan."""
        if 'annual_income' in update_data:
            validate_positive_amount(update_data['annual_income'], "annual_income")
        if 'owner' in update_data and update_data['owner'] not in {"person1", "person2", "joint"}:
            raise ValueError("Invalid owner value")
        if 'start_age' in update_data or 'end_age' in update_data:
            current_income = self.get_retirement_income(income_id)
            if not current_income:
                return None
            start_age = update_data.get('start_age', current_income.start_age)
            end_age = update_data.get('end_age', current_income.end_age)
            if end_age is not None and not validate_age_sequence(start_age, start_age, end_age):
                raise ValueError("Start age must be before or equal to end age")
        try:
            stmt = update(RetirementIncomePlan).where(RetirementIncomePlan.income_plan_id == income_id).values(**update_data).returning(RetirementIncomePlan)
            result = self.session.execute(stmt)
            income_plan = result.scalar_one_or_none()
            if not income_plan:
                return None
            if growth_config:
                self.session.execute(delete(GrowthRateConfiguration).where(GrowthRateConfiguration.retirement_income_plan_id == income_id))
                self._add_growth_configuration(income_id, growth_config)
            self.session.commit()
            return income_plan
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to update retirement income plan", orig=e)
    def delete_retirement_income(self, income_id: int) -> bool:
        """Deletes a retirement income plan."""
        result = self.session.execute(delete(RetirementIncomePlan).where(RetirementIncomePlan.income_plan_id == income_id))
        self.session.commit()
        return result.rowcount > 0
    def _add_growth_configuration(self, income_id: int, config: Dict[str, Any]) -> None:
        """Adds a growth rate configuration for a retirement income plan."""
        validate_rate(config.get('growth_rate'), "growth_rate")
        self.session.add(GrowthRateConfiguration(
            retirement_income_plan_id=income_id, configuration_type='OVERRIDE',
            start_year=config.get('start_year'), end_year=config.get('end_year'), growth_rate=config.get('growth_rate')
        ))
    def get_retirement_income_summary(self, income_id: int, include_years: bool = False) -> Optional[Dict[str, Any]]:
        """Returns a summary of a retirement income plan."""
        income = self.get_retirement_income(income_id, include_growth_config=True)
        if not income:
            return None
        summary = {
            'income_id': income.income_plan_id,
            'name': income.name,
            'owner': income.owner,
            'annual_income': income.annual_income,
            'start_age': income.start_age,
            'end_age': income.end_age,
            'include_in_nest_egg': income.include_in_nest_egg,
            'apply_inflation': income.apply_inflation,
            'has_growth_rate': bool(income.growth_rates)
        }
        if include_years:
            summary.update({
                'duration': (income.end_age - income.start_age + 1) if income.end_age else None,
                'is_lifetime': income.end_age is None
            })
        return summary
    def get_total_retirement_income(self, plan_id: int, age: int, include_in_nest_egg_only: bool = False) -> float:
        """Calculates total retirement income at a specific age."""
        stmt = select(RetirementIncomePlan).where(RetirementIncomePlan.plan_id == plan_id, RetirementIncomePlan.start_age <= age)
        if include_in_nest_egg_only:
            stmt = stmt.where(RetirementIncomePlan.include_in_nest_egg.is_(True))
        income_plans = self.session.execute(stmt).scalars().all()
        return sum(plan.annual_income for plan in income_plans if plan.end_age is None or plan.end_age >= age)
```

######## backend/database_operations/crud/financial/__init__.py ########
```
"""
Financial components CRUD operations.
This package contains modules for managing different types of financial components:
- assets: Asset categories and assets
- liabilities: Liability categories and liabilities
- cash_flows: Inflows and outflows
- retirement: Retirement income plans
- growth_rates: Growth rate configurations
"""
from .assets_crud import *
from .liabilities_crud import *
from .cash_flows_crud import *
from .retirement_income_crud import *
from .growth_rates_crud import * 
```

######## backend/database_operations/utils/money_utils.py ########
```
# backend/database_operations/utils/money_utils.py
from typing import Union, List
from decimal import Decimal, ROUND_HALF_UP, InvalidOperation, Context
# Precision settings
CALCULATION_PRECISION = 8
DISPLAY_PRECISION = 2
CALCULATION_CONTEXT = Context(prec=CALCULATION_PRECISION, rounding=ROUND_HALF_UP)
def to_decimal(amount: Union[float, str, Decimal]) -> Decimal:
    """Converts amount to Decimal with high precision."""
    try:
        return CALCULATION_CONTEXT.create_decimal(str(amount)) if not isinstance(amount, Decimal) else CALCULATION_CONTEXT.create_decimal(amount)
    except (InvalidOperation, ValueError) as e:
        raise ValueError(f"Invalid decimal conversion: {amount}") from e
def to_float(amount: Decimal) -> float:
    """Converts Decimal to float with 2 decimal place rounding."""
    return float(round_to_currency(amount))
def apply_annual_compound_rate(principal: Decimal, rate: Decimal) -> Decimal:
    """Applies annual compound rate to principal."""
    try:
        return principal * (to_decimal('1') + to_decimal(rate))
    except (InvalidOperation, ValueError) as e:
        raise ValueError(f"Invalid compound calculation: principal={principal}, rate={rate}") from e
def apply_annual_inflation(amount: Decimal, inflation_rate: Decimal) -> Decimal:
    """Adjusts amount for annual inflation."""
    return apply_annual_compound_rate(amount, inflation_rate)
def combine_amounts(amounts: List[Decimal]) -> Decimal:
    """Sums multiple Decimal amounts with precision."""
    try:
        return sum((to_decimal(amt) for amt in amounts), to_decimal('0'))
    except (InvalidOperation, ValueError) as e:
        raise ValueError(f"Invalid amounts for combination: {amounts}") from e
def round_to_currency(amount: Decimal) -> Decimal:
    """Rounds amount to 2 decimal places."""
    try:
        return amount.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
    except (InvalidOperation, ValueError) as e:
        raise ValueError(f"Invalid currency rounding: {amount}") from e
```

######## backend/database_operations/utils/time_utils.py ########
```
# backend/database_operations/utils/time_utils.py
from datetime import date
from typing import Dict, Tuple
# Handles computed values (age, years, mappings). No validation logic.
def get_start_year(plan_creation_year: int) -> int:
    """Returns the start year for projections (same as plan creation year)."""
    return plan_creation_year
def get_age_in_year(dob: date, year: int) -> int:
    """Returns age in a given year, adjusting for whether the birthday has passed."""
    return year - dob.year - (1 if (year, 1, 1) <= (dob.year, dob.month, dob.day) else 0)
def get_year_for_age(dob: date, target_age: int) -> int:
    """Returns the year when a person reaches a target age."""
    return dob.year + target_age
def map_age_to_years(dob: date, start_year: int, end_year: int) -> Dict[int, int]:
    """Creates a dictionary mapping ages to years."""
    return {get_age_in_year(dob, year): year for year in range(start_year, end_year + 1)}
def map_years_to_ages(dob: date, start_year: int, end_year: int) -> Dict[int, int]:
    """Creates a dictionary mapping years to ages."""
    return {year: get_age_in_year(dob, year) for year in range(start_year, end_year + 1)}
def get_retirement_year(dob: date, retirement_age: int) -> int:
    """Returns the year when retirement begins."""
    return get_year_for_age(dob, retirement_age)
def get_final_projection_year(dob: date, final_age: int) -> int:
    """Returns the last year of financial projections."""
    return get_year_for_age(dob, final_age)
def get_projection_period(dob: date, plan_creation_year: int, final_age: int) -> Tuple[int, int]:
    """Returns (start_year, end_year) for a projection."""
    return get_start_year(plan_creation_year), get_final_projection_year(dob, final_age)
def get_years_between(start_year: int, end_year: int) -> int:
    """Returns the number of years between two given years, inclusive."""
    return max(0, end_year - start_year + 1)
```

######## backend/database_operations/utils/__init__.py ########
```

```

######## backend/database_operations/validation/growth_validation.py ########
```
# backend/database_operations/validation/growth_validation.py
from typing import List, Dict, Any
def validate_stepwise_periods(periods: List[Dict[str, Any]], field_name: str) -> None:
    """Raises ValueError if periods overlap or are not in chronological order."""
    if not periods:
        return
    sorted_periods = sorted(periods, key=lambda x: x['start_year'])
    for i in range(len(sorted_periods) - 1):
        current, next_period = sorted_periods[i], sorted_periods[i + 1]
        if current.get('end_year') is None and i < len(sorted_periods) - 1:
            raise ValueError(f"{field_name} has an open-ended period that is not last")
        if current.get('end_year') is not None and current['end_year'] >= next_period['start_year']:
            raise ValueError(f"{field_name} contains overlapping periods")
def validate_growth_config_type(config_type: str, field_name: str) -> None:
    """Raises ValueError if config_type is not 'DEFAULT', 'OVERRIDE', or 'STEPWISE'."""
    if config_type not in {"DEFAULT", "OVERRIDE", "STEPWISE"}:
        raise ValueError(f"{field_name} must be 'DEFAULT', 'OVERRIDE', or 'STEPWISE'")
```

######## backend/database_operations/validation/money_validation.py ########
```
# backend/database_operations/validation/money_validation.py
from typing import Union
from decimal import Decimal
def validate_positive_amount(amount: Union[float, Decimal], field_name: str) -> None:
    """Raises ValueError if amount is not a positive number."""
    if not isinstance(amount, (float, Decimal)):
        raise ValueError(f"{field_name} must be numeric")
    if amount <= 0:
        raise ValueError(f"{field_name} must be positive")
def validate_rate(rate: Union[float, Decimal], field_name: str) -> None:
    """Raises ValueError if rate is not numeric."""
    if not isinstance(rate, (float, Decimal)):
        raise ValueError(f"{field_name} must be numeric")
def validate_owner(owner: str, field_name: str) -> None:
    """Raises ValueError if owner is not 'person1', 'person2', or 'joint'."""
    if owner not in {"person1", "person2", "joint"}:
        raise ValueError(f"{field_name} must be 'person1', 'person2', or 'joint'")
```

######## backend/database_operations/validation/scenario_timeline_validation.py ########
```
# ## Core Validations
# 1. Date of birth must be a valid past date.  
# 2. Retirement year must be after the start year.  
# 3. End year must be after retirement year.  
# 4. Start year must be before end year for inflows/outflows.  
# 5. Scenario overrides cannot create invalid timelines.  
# 6. Stepwise growth periods must be in chronological order and not overlap.
# backend/database_operations/validation/scenario_timeline_validation.py
from datetime import date
from typing import Dict, Optional, List
from ..models import InflowOutflow, GrowthRateConfiguration, RetirementIncomePlan
from ..utils.time_utils import get_year_for_age
def validate_projection_timeline(
    start_year: int,
    retirement_year: int, 
    end_year: int
) -> bool:
    if not all(isinstance(year, int) for year in [start_year, retirement_year, end_year]):
        return False
    return start_year < retirement_year < end_year
def validate_scenario_override_timeline(
    base_timeline: Dict[str, int],
    override_timeline: Dict[str, int]
) -> bool:
    start_year = override_timeline.get('start_year', base_timeline['start_year'])
    retirement_year = override_timeline.get('retirement_year', base_timeline['retirement_year'])
    end_year = override_timeline.get('end_year', base_timeline['end_year'])
    return validate_projection_timeline(start_year, retirement_year, end_year)
def validate_scenario_timeline_consistency(
    flows: List[InflowOutflow],
    growth_configs: List[GrowthRateConfiguration],
    income_plans: List[RetirementIncomePlan],
    start_year: int,
    retirement_year: int,
    end_year: int
) -> bool:
    if not validate_projection_timeline(start_year, retirement_year, end_year):
        return False
    try:
        for flow in flows:
            if flow.start_year < start_year:
                return False
            if flow.end_year and flow.end_year > end_year:
                return False
        for config in growth_configs:
            if config.start_year < start_year:
                return False
            if config.end_year and config.end_year > end_year:
                return False
        for income in income_plans:
            income_start = get_year_for_age(income.dob, income.start_age)
            if income_start < start_year:
                return False
            if income.end_age:
                income_end = get_year_for_age(income.dob, income.end_age)
                if income_end > end_year:
                    return False
        return True
    except Exception:
        return False
```

######## backend/database_operations/validation/time_validation.py ########
```
# backend/database_operations/validation/time_validation.py
from datetime import date
# time_validation.py: Strictly for validation checks. No computed values.
def validate_dob(dob: date) -> bool:
    """Returns True if dob is in the past."""
    return dob < date.today()
def validate_positive_age(age: int) -> bool:
    """Returns True if an age is a valid positive number."""
    return age > 0
def validate_age_sequence(start_age: int, retirement_age: int, final_age: int) -> bool:
    """Returns True if the sequence is logically valid: start_age < retirement_age < final_age."""
    return start_age > 0 and start_age < retirement_age < final_age
def validate_year_range(year: int, start_year: int, end_year: int) -> bool:
    """Returns True if a year is within the valid projection range."""
    return start_year <= year <= end_year if start_year <= end_year else False
def validate_year_not_before_plan_creation(year: int, plan_creation_year: int) -> bool:
    """Returns True if the given year is not before plan creation."""
    return year >= plan_creation_year
# In time_validation.py
def validate_timeline(start_year: int, retirement_year: int, end_year: int) -> None:
    if not (start_year < retirement_year < end_year):
        raise ValueError("Timeline must flow: start_year < retirement_year < end_year")
```

######## backend/database_operations/tests/conftest.py ########
```
# tests/conftest.py
import pytest
from datetime import date, datetime
from decimal import Decimal
from sqlalchemy import create_engine
from sqlalchemy.orm import Session, sessionmaker
from contextlib import contextmanager
from database_operations.models import Base, Household, Plan, BaseAssumption
from database_operations.connection import get_session
import database_operations.connection as connection  # Import the module to modify its global
# Override the global engine for tests
@pytest.fixture(scope="session", autouse=True)
def test_engine():
    """Create and configure the test database engine."""
    # Create test engine
    engine = create_engine("sqlite:///:memory:", echo=False)
    Base.metadata.create_all(engine)
    # Override the global engine in the connection module
    connection._engine = engine
    yield engine
    # Cleanup after all tests
    engine.dispose()
@pytest.fixture
def db_session(test_engine):
    """Creates a fresh test database session with automatic rollback."""
    connection = test_engine.connect()
    transaction = connection.begin()
    session = Session(bind=connection)
    try:
        yield session
    finally:
        session.close()
        transaction.rollback()
        connection.close()
@pytest.fixture
def base_household(db_session):
    """Creates a test household with one person."""
    household = Household(
        household_name="Test Household",
        person1_first_name="John",
        person1_last_name="Doe",
        person1_dob=date(1970, 1, 1)
    )
    db_session.add(household)
    db_session.commit()
    return household
@pytest.fixture
def base_plan(db_session, base_household):
    """Creates a test plan with basic assumptions."""
    plan = Plan(
        household_id=base_household.household_id,
        plan_name="Test Plan",
        plan_creation_year=datetime.now().year
    )
    db_session.add(plan)
    db_session.flush()
    assumptions = BaseAssumption(
        plan_id=plan.plan_id,
        retirement_age_1=65,
        final_age_1=95,
        default_growth_rate=Decimal('0.06'),
        inflation_rate=Decimal('0.03')
    )
    db_session.add(assumptions)
    db_session.commit()
    return plan
@pytest.fixture
def base_plan_with_facts(db_session, base_plan):
    """Creates a plan with sample assets, liabilities, and cash flows."""
    from database_operations.models import (
        AssetCategory, Asset, LiabilityCategory, Liability,
        InflowOutflow, RetirementIncomePlan
    )
    # Categories
    asset_cat = AssetCategory(
        plan_id=base_plan.plan_id,
        category_name="Retirement Accounts"
    )
    db_session.add(asset_cat)
    liability_cat = LiabilityCategory(
        plan_id=base_plan.plan_id,
        category_name="Mortgages"
    )
    db_session.add(liability_cat)
    db_session.flush()
    # Typical retirement portfolio components
    asset = Asset(
        plan_id=base_plan.plan_id,
        asset_category_id=asset_cat.asset_category_id,
        asset_name="401(k)",
        owner="person1",
        value=500000.00,
        include_in_nest_egg=True
    )
    db_session.add(asset)
    asset2 = Asset(
        plan_id=base_plan.plan_id,
        asset_category_id=asset_cat.asset_category_id,
        asset_name="House",
        owner="joint",
        value=400000.00,
        include_in_nest_egg=False  # Non-retirement asset
    )
    db_session.add(asset2)
    liability = Liability(
        plan_id=base_plan.plan_id,
        liability_category_id=liability_cat.liability_category_id,
        liability_name="Mortgage",
        owner="joint",
        value=300000.00,
        interest_rate=0.0375,
        include_in_nest_egg=True
    )
    db_session.add(liability)
    # Regular cash flows
    salary = InflowOutflow(
        plan_id=base_plan.plan_id,
        type="inflow",
        name="Salary",
        owner="person1",
        annual_amount=100000.00,
        start_year=base_plan.plan_creation_year,
        end_year=base_plan.plan_creation_year + 10,
        apply_inflation=True
    )
    db_session.add(salary)
    # Retirement income at retirement age
    social_security = RetirementIncomePlan(
        plan_id=base_plan.plan_id,
        name="Social Security",
        owner="person1",
        annual_income=30000.00,
        start_age=67,
        apply_inflation=True
    )
    db_session.add(social_security)
    db_session.commit()
    return base_plan
```

######## backend/database_operations/tests/test_crud_operations.py ########
```
# tests/test_crud_operations.py
import pytest
from decimal import Decimal
from datetime import date
from sqlalchemy.exc import IntegrityError
from sqlalchemy import event
from database_operations.crud.financial.assets_crud import AssetCRUD
from database_operations.crud.financial.liabilities_crud import LiabilityCRUD
from database_operations.crud.financial.cash_flows_crud import CashFlowCRUD
from database_operations.crud.plans_crud import PlanCRUD
from database_operations.models import Asset, Liability, Plan, CashFlow
def test_asset_crud_operations(db_session, base_plan_with_facts):
    """Test basic CRUD operations for assets."""
    crud = AssetCRUD(db_session)
    # Create
    asset = crud.create_asset(
        plan_id=base_plan_with_facts.plan_id,
        asset_category_id=1,  # From fixture
        asset_name="Roth IRA",
        value=100000.00,
        owner="person1"
    )
    assert asset.asset_name == "Roth IRA"
    # Read
    retrieved = crud.get_asset(asset.asset_id)
    assert retrieved is not None
    assert retrieved.value == 100000.00
    # Update
    updated = crud.update_asset(
        asset.asset_id,
        {"value": 150000.00}
    )
    assert updated.value == 150000.00
    # Delete
    assert crud.delete_asset(asset.asset_id)
def test_transaction_isolation(db_session, base_plan_with_facts):
    """Test transaction isolation levels and concurrent modifications."""
    crud = AssetCRUD(db_session)
    # Create initial asset
    asset = crud.create_asset(
        plan_id=base_plan_with_facts.plan_id,
        asset_category_id=1,
        asset_name="Test Asset",
        value=100000.00,
        owner="person1"
    )
    # Start a new transaction
    with db_session.begin_nested():
        # Modify asset within transaction
        crud.update_asset(
            asset.asset_id,
            {"value": 150000.00}
        )
        # Verify value is updated within transaction
        modified = crud.get_asset(asset.asset_id)
        assert modified.value == 150000.00
        # Rollback transaction
        db_session.rollback()
    # Verify original value is restored
    original = crud.get_asset(asset.asset_id)
    assert original.value == 100000.00
def test_complex_transaction_rollback(db_session, base_plan_with_facts):
    """Test rollback of complex operations involving multiple entities."""
    asset_crud = AssetCRUD(db_session)
    liability_crud = LiabilityCRUD(db_session)
    try:
        # Start transaction
        with db_session.begin_nested():
            # Create asset
            asset = asset_crud.create_asset(
                plan_id=base_plan_with_facts.plan_id,
                asset_category_id=1,
                asset_name="House",
                value=500000.00,
                owner="joint"
            )
            # Create related liability (mortgage)
            liability = liability_crud.create_liability(
                plan_id=base_plan_with_facts.plan_id,
                liability_category_id=1,
                liability_name="Mortgage",
                value=400000.00,
                owner="joint",
                interest_rate=0.035
            )
            # Simulate error condition
            raise ValueError("Simulated error")
    except ValueError:
        db_session.rollback()
    # Verify nothing was committed
    assert asset_crud.get_asset(asset.asset_id) is None
    assert liability_crud.get_liability(liability.liability_id) is None
def test_concurrent_modifications(db_session, base_plan_with_facts):
    """Test handling of concurrent modifications to the same entity."""
    crud = AssetCRUD(db_session)
    # Create test asset
    asset = crud.create_asset(
        plan_id=base_plan_with_facts.plan_id,
        asset_category_id=1,
        asset_name="Test Asset",
        value=100000.00,
        owner="person1"
    )
    # Simulate concurrent sessions
    session1 = db_session
    session2 = db_session.session_factory()
    try:
        # Modify in session 1
        crud1 = AssetCRUD(session1)
        crud1.update_asset(asset.asset_id, {"value": 150000.00})
        # Modify in session 2
        crud2 = AssetCRUD(session2)
        with pytest.raises(Exception):  # Expect concurrent modification error
            crud2.update_asset(asset.asset_id, {"value": 200000.00})
    finally:
        session2.close()
def test_database_constraints(db_session, base_plan_with_facts):
    """Test enforcement of database constraints."""
    crud = AssetCRUD(db_session)
    # Test foreign key constraint
    with pytest.raises(IntegrityError):
        crud.create_asset(
            plan_id=999999,  # Non-existent plan
            asset_category_id=1,
            asset_name="Invalid Asset",
            value=100000.00,
            owner="person1"
        )
    # Test unique constraint
    asset1 = crud.create_asset(
        plan_id=base_plan_with_facts.plan_id,
        asset_category_id=1,
        asset_name="Unique Asset",
        value=100000.00,
        owner="person1"
    )
    with pytest.raises(IntegrityError):
        # Attempt to create asset with same name in same plan
        crud.create_asset(
            plan_id=base_plan_with_facts.plan_id,
            asset_category_id=1,
            asset_name="Unique Asset",  # Duplicate name
            value=200000.00,
            owner="person1"
        )
def test_cascade_operations(db_session, base_plan_with_facts):
    """Test cascade behavior for related entities."""
    plan_crud = PlanCRUD(db_session)
    asset_crud = AssetCRUD(db_session)
    # Create plan with assets
    plan = plan_crud.create_plan(
        household_id=base_plan_with_facts.household_id,
        plan_name="Cascade Test Plan"
    )
    asset = asset_crud.create_asset(
        plan_id=plan.plan_id,
        asset_category_id=1,
        asset_name="Test Asset",
        value=100000.00,
        owner="person1"
    )
    # Delete plan and verify cascade
    plan_crud.delete_plan(plan.plan_id)
    # Verify asset was cascade deleted
    assert asset_crud.get_asset(asset.asset_id) is None
def test_transaction_deadlock_handling(db_session, base_plan_with_facts):
    """Test handling of potential deadlock scenarios."""
    asset_crud = AssetCRUD(db_session)
    liability_crud = LiabilityCRUD(db_session)
    # Create test entities
    asset = asset_crud.create_asset(
        plan_id=base_plan_with_facts.plan_id,
        asset_category_id=1,
        asset_name="Deadlock Test Asset",
        value=100000.00,
        owner="person1"
    )
    liability = liability_crud.create_liability(
        plan_id=base_plan_with_facts.plan_id,
        liability_category_id=1,
        liability_name="Deadlock Test Liability",
        value=50000.00,
        owner="person1",
        interest_rate=0.035
    )
    # Simulate deadlock scenario
    session1 = db_session
    session2 = db_session.session_factory()
    try:
        with session1.begin_nested():
            # Update asset in session 1
            asset_crud1 = AssetCRUD(session1)
            asset_crud1.update_asset(asset.asset_id, {"value": 150000.00})
            with session2.begin_nested():
                # Try to update liability in session 2
                liability_crud2 = LiabilityCRUD(session2)
                liability_crud2.update_liability(
                    liability.liability_id,
                    {"value": 60000.00}
                )
                # This should raise a deadlock error
                with pytest.raises(Exception):
                    asset_crud2 = AssetCRUD(session2)
                    asset_crud2.update_asset(asset.asset_id, {"value": 200000.00})
    finally:
        session2.close()
def test_bulk_operations(db_session, base_plan_with_facts):
    """Test handling of bulk create/update operations."""
    crud = AssetCRUD(db_session)
    # Bulk create assets
    assets_data = [
        {
            "plan_id": base_plan_with_facts.plan_id,
            "asset_category_id": 1,
            "asset_name": f"Bulk Asset {i}",
            "value": 100000.00 * i,
            "owner": "person1"
        }
        for i in range(1, 6)
    ]
    created_assets = crud.bulk_create_assets(assets_data)
    assert len(created_assets) == 5
    # Bulk update assets
    updates = [
        {"asset_id": asset.asset_id, "value": asset.value * 1.1}
        for asset in created_assets
    ]
    updated_assets = crud.bulk_update_assets(updates)
    assert len(updated_assets) == 5
    assert all(
        updated.value > original.value 
        for updated, original in zip(updated_assets, created_assets)
    )
def test_audit_trail(db_session, base_plan_with_facts):
    """Test audit trail for CRUD operations."""
    crud = AssetCRUD(db_session)
    # Create asset with audit
    asset = crud.create_asset(
        plan_id=base_plan_with_facts.plan_id,
        asset_category_id=1,
        asset_name="Audit Test Asset",
        value=100000.00,
        owner="person1"
    )
    assert asset.created_at is not None
    # Update asset
    updated = crud.update_asset(
        asset.asset_id,
        {"value": 150000.00}
    )
    assert updated.updated_at is not None
    assert updated.updated_at > updated.created_at
```

######## backend/database_operations/tests/test_growth_calculations.py ########
```
# tests/test_growth_calculations.py
from decimal import Decimal
import pytest
from datetime import date
from database_operations.calculations.base_facts.growth_handler_calcs import GrowthRateHandler
from database_operations.models import GrowthRateConfiguration
from database_operations.utils.time_utils import get_year_for_age
def test_default_growth_application():
    """Test application of default growth rate."""
    handler = GrowthRateHandler()
    result = handler.apply_growth(
        value=Decimal('100000'),
        year=2025,
        default_rate=Decimal('0.06'),
        growth_configs=[]  # No configurations = use default
    )
    assert result.final_value == Decimal('106000')
    assert result.growth_amount == Decimal('6000')
    assert result.rate_source == 'default'
def test_stepwise_growth_handling():
    """Test stepwise growth rate application."""
    handler = GrowthRateHandler()
    configs = [
        GrowthRateConfiguration(
            configuration_type='STEPWISE',
            start_year=2025,
            end_year=2027,
            growth_rate=Decimal('0.08')
        ),
        GrowthRateConfiguration(
            configuration_type='STEPWISE',
            start_year=2028,
            end_year=2030,
            growth_rate=Decimal('0.06')
        )
    ]
    # Test first period
    result = handler.apply_growth(
        value=Decimal('100000'),
        year=2025,
        default_rate=Decimal('0.05'),
        growth_configs=configs
    )
    assert result.final_value == Decimal('108000')
    assert result.rate_source == 'stepwise'
    # Test gap year (should use default)
    result = handler.apply_growth(
        value=Decimal('100000'),
        year=2031,
        default_rate=Decimal('0.05'),
        growth_configs=configs
    )
    assert result.rate_source == 'default'
    assert result.final_value == Decimal('105000')
def test_growth_rate_period_boundaries():
    """Test growth rate calculations at period boundaries."""
    handler = GrowthRateHandler()
    configs = [
        GrowthRateConfiguration(
            configuration_type='STEPWISE',
            start_year=2025,
            end_year=2027,
            growth_rate=Decimal('0.08')
        )
    ]
    # Test exactly at start year
    result = handler.apply_growth(
        value=Decimal('100000'),
        year=2025,
        default_rate=Decimal('0.05'),
        growth_configs=configs
    )
    assert result.rate_source == 'stepwise'
    assert result.final_value == Decimal('108000')
    # Test exactly at end year
    result = handler.apply_growth(
        value=Decimal('100000'),
        year=2027,
        default_rate=Decimal('0.05'),
        growth_configs=configs
    )
    assert result.rate_source == 'stepwise'
    assert result.final_value == Decimal('108000')
    # Test one year before start
    result = handler.apply_growth(
        value=Decimal('100000'),
        year=2024,
        default_rate=Decimal('0.05'),
        growth_configs=configs
    )
    assert result.rate_source == 'default'
    assert result.final_value == Decimal('105000')
    # Test one year after end
    result = handler.apply_growth(
        value=Decimal('100000'),
        year=2028,
        default_rate=Decimal('0.05'),
        growth_configs=configs
    )
    assert result.rate_source == 'default'
    assert result.final_value == Decimal('105000')
def test_overlapping_growth_periods():
    """Test handling of overlapping growth period configurations."""
    handler = GrowthRateHandler()
    configs = [
        GrowthRateConfiguration(
            configuration_type='STEPWISE',
            start_year=2025,
            end_year=2027,
            growth_rate=Decimal('0.08')
        ),
        GrowthRateConfiguration(
            configuration_type='STEPWISE',
            start_year=2026,
            end_year=2028,
            growth_rate=Decimal('0.06')
        )
    ]
    # Test in overlap period (should use first configured rate)
    result = handler.apply_growth(
        value=Decimal('100000'),
        year=2026,
        default_rate=Decimal('0.05'),
        growth_configs=configs
    )
    assert result.rate_source == 'stepwise'
    assert result.final_value == Decimal('108000')  # Uses first rate (0.08)
def test_growth_rate_transitions():
    """Test growth rate transitions between periods."""
    handler = GrowthRateHandler()
    configs = [
        GrowthRateConfiguration(
            configuration_type='STEPWISE',
            start_year=2025,
            end_year=2026,
            growth_rate=Decimal('0.08')
        ),
        GrowthRateConfiguration(
            configuration_type='STEPWISE',
            start_year=2028,
            end_year=2029,
            growth_rate=Decimal('0.06')
        )
    ]
    # Test transition to default rate
    result = handler.apply_growth(
        value=Decimal('100000'),
        year=2027,  # Gap year
        default_rate=Decimal('0.05'),
        growth_configs=configs
    )
    assert result.rate_source == 'default'
    assert result.final_value == Decimal('105000')
    # Test transition back to stepwise
    result = handler.apply_growth(
        value=Decimal('100000'),
        year=2028,
        default_rate=Decimal('0.05'),
        growth_configs=configs
    )
    assert result.rate_source == 'stepwise'
    assert result.final_value == Decimal('106000')
def test_negative_growth_rates():
    """Test handling of negative growth rates."""
    handler = GrowthRateHandler()
    configs = [
        GrowthRateConfiguration(
            configuration_type='STEPWISE',
            start_year=2025,
            end_year=2026,
            growth_rate=Decimal('-0.05')  # 5% decline
        )
    ]
    result = handler.apply_growth(
        value=Decimal('100000'),
        year=2025,
        default_rate=Decimal('0.05'),
        growth_configs=configs
    )
    assert result.final_value == Decimal('95000')
    assert result.growth_amount == Decimal('-5000')
def test_zero_value_growth():
    """Test growth calculations with zero initial value."""
    handler = GrowthRateHandler()
    result = handler.apply_growth(
        value=Decimal('0'),
        year=2025,
        default_rate=Decimal('0.06'),
        growth_configs=[]
    )
    assert result.final_value == Decimal('0')
    assert result.growth_amount == Decimal('0')
def test_compound_growth_accuracy():
    """Test accuracy of compound growth calculations over multiple periods."""
    handler = GrowthRateHandler()
    initial_value = Decimal('100000')
    rate = Decimal('0.05')
    # Calculate 5 years of compound growth
    value = initial_value
    for _ in range(5):
        result = handler.apply_growth(
            value=value,
            year=2025,
            default_rate=rate,
            growth_configs=[]
        )
        value = result.final_value
    # Compare with direct compound calculation: 100000 * (1.05)^5
    expected = initial_value * (Decimal('1.05') ** Decimal('5'))
    assert abs(value - expected) < Decimal('0.01')
def test_mixed_growth_periods():
    """Test realistic market cycle scenarios."""
    handler = GrowthRateHandler()
    configs = [
        GrowthRateConfiguration(
            configuration_type='STEPWISE',
            start_year=2025,
            end_year=2026,
            growth_rate=Decimal('-0.15')  # Market decline
        ),
        GrowthRateConfiguration(
            configuration_type='STEPWISE',
            start_year=2027,
            end_year=2028,
            growth_rate=Decimal('0.20')   # Recovery
        )
    ]
    # Test full cycle impact
    value = Decimal('100000')
    for year in range(2025, 2029):
        result = handler.apply_growth(
            value=value,
            year=year,
            default_rate=Decimal('0.06'),
            growth_configs=configs
        )
        value = result.final_value
    # Verify recovery math is correct
    # 100k * (1 - 0.15) * (1 - 0.15) * (1 + 0.20) * (1 + 0.20)
    expected = Decimal('100000') * (Decimal('0.85') ** 2) * (Decimal('1.20') ** 2)
    assert abs(value - expected) < Decimal('0.01')
def test_growth_rate_precision():
    """Test handling of precise decimal growth rates."""
    handler = GrowthRateHandler()
    configs = [
        GrowthRateConfiguration(
            configuration_type='STEPWISE',
            start_year=2025,
            end_year=2026,
            growth_rate=Decimal('0.0567')  # Precise rate
        )
    ]
    result = handler.apply_growth(
        value=Decimal('100000'),
        year=2025,
        default_rate=Decimal('0.05'),
        growth_configs=configs
    )
    expected = Decimal('100000') * (Decimal('1') + Decimal('0.0567'))
    assert abs(result.final_value - expected) < Decimal('0.01')
```

######## backend/database_operations/tests/test_growth_configurations.py ########
```
# tests/test_growth_configurations.py
from decimal import Decimal
import pytest
from database_operations.crud.financial.growth_rates_crud import GrowthRateCRUD
from database_operations.validation.growth_validation import validate_stepwise_periods
def test_validate_stepwise_periods():
    """Test validation of stepwise growth period configurations."""
    # Valid configurations
    valid_periods = [
        {"start_year": 2025, "end_year": 2027},
        {"start_year": 2028, "end_year": 2030}
    ]
    assert validate_stepwise_periods(valid_periods, "test") is None
    # Overlapping periods
    invalid_periods = [
        {"start_year": 2025, "end_year": 2028},
        {"start_year": 2027, "end_year": 2030}
    ]
    with pytest.raises(ValueError, match="test contains overlapping periods"):
        validate_stepwise_periods(invalid_periods, "test")
def test_growth_rate_crud(db_session, base_plan_with_facts):
    """Test CRUD operations for growth rate configurations."""
    crud = GrowthRateCRUD(db_session)
    # Test creating override growth rate
    config = crud.create_growth_config(
        configuration_type="OVERRIDE",
        start_year=2025,
        growth_rate=0.08,
        asset_id=1  # From base_plan_with_facts fixture
    )
    assert config.growth_rate == 0.08
    assert config.configuration_type == "OVERRIDE"
def test_stepwise_growth_configuration(db_session, base_plan_with_facts):
    """Test creation and validation of stepwise growth configurations."""
    crud = GrowthRateCRUD(db_session)
    # Create valid stepwise configuration
    configs = crud.create_stepwise_config([
        {
            "start_year": 2025,
            "end_year": 2027,
            "growth_rate": 0.08
        },
        {
            "start_year": 2028,
            "end_year": 2030,
            "growth_rate": 0.06
        }
    ], asset_id=1)
    assert len(configs) == 2
    assert configs[0].configuration_type == "STEPWISE"
    assert configs[0].growth_rate == 0.08
```

######## backend/database_operations/tests/test_retirement_calculations.py ########
```
# tests/test_retirement_calculations.py
from decimal import Decimal
from datetime import date
import pytest
from database_operations.calculations.base_facts.retirement_income_calcs import RetirementIncomeCalculator
from database_operations.models import RetirementIncomePlan, RetirementIncomeType
from database_operations.utils.time_utils import get_age_in_year, get_year_for_age
def test_retirement_income_activation():
    """Test retirement income activation based on age."""
    calc = RetirementIncomeCalculator()
    income = RetirementIncomePlan(
        name="Social Security",
        owner="person1",
        annual_income=Decimal('30000'),
        start_age=67,
        dob=date(1970, 1, 1)
    )
    # Before retirement age
    result = calc.calculate_income_amount(
        income=income,
        year=2025,  # Age 55
        inflation_rate=Decimal('0.03'),
        plan_start_year=2025
    )
    assert not result.is_active
    assert result.adjusted_amount == Decimal('0')
    # At retirement age
    result = calc.calculate_income_amount(
        income=income,
        year=2037,  # Age 67
        inflation_rate=Decimal('0.03'),
        plan_start_year=2025
    )
    assert result.is_active
    assert result.adjusted_amount > Decimal('30000')  # Inflation adjusted
def test_multiple_income_stream_interactions():
    """Test interactions between multiple retirement income streams."""
    calc = RetirementIncomeCalculator()
    # Create multiple income streams with different characteristics
    incomes = [
        RetirementIncomePlan(
            name="Social Security",
            owner="person1",
            annual_income=Decimal('30000'),
            start_age=67,
            income_type=RetirementIncomeType.SOCIAL_SECURITY,
            dob=date(1970, 1, 1),
            apply_inflation=True
        ),
        RetirementIncomePlan(
            name="Pension",
            owner="person1",
            annual_income=Decimal('40000'),
            start_age=65,
            income_type=RetirementIncomeType.PENSION,
            dob=date(1970, 1, 1),
            apply_inflation=False
        ),
        RetirementIncomePlan(
            name="Part-time Work",
            owner="person1",
            annual_income=Decimal('20000'),
            start_age=65,
            end_age=70,
            income_type=RetirementIncomeType.OTHER,
            dob=date(1970, 1, 1),
            apply_inflation=True
        )
    ]
    # Test before any income starts (age 60)
    results = calc.calculate_multiple_income_streams(
        income_streams=incomes,
        year=2030,
        inflation_rate=Decimal('0.03'),
        plan_start_year=2025
    )
    assert sum(r.adjusted_amount for r in results) == Decimal('0')
    # Test when pension and part-time work active (age 65)
    results = calc.calculate_multiple_income_streams(
        income_streams=incomes,
        year=2035,
        inflation_rate=Decimal('0.03'),
        plan_start_year=2025
    )
    active_results = [r for r in results if r.is_active]
    assert len(active_results) == 2
    # Test when all income streams active (age 67)
    results = calc.calculate_multiple_income_streams(
        income_streams=incomes,
        year=2037,
        inflation_rate=Decimal('0.03'),
        plan_start_year=2025
    )
    active_results = [r for r in results if r.is_active]
    assert len(active_results) == 3
    # Test after part-time work ends (age 71)
    results = calc.calculate_multiple_income_streams(
        income_streams=incomes,
        year=2041,
        inflation_rate=Decimal('0.03'),
        plan_start_year=2025
    )
    active_results = [r for r in results if r.is_active]
    assert len(active_results) == 2
def test_long_term_inflation_impact():
    """Test long-term inflation effects on retirement income."""
    calc = RetirementIncomeCalculator()
    # Test income with inflation adjustment
    income_with_inflation = RetirementIncomePlan(
        name="Social Security",
        owner="person1",
        annual_income=Decimal('30000'),
        start_age=67,
        dob=date(1970, 1, 1),
        apply_inflation=True
    )
    # Test income without inflation adjustment
    income_without_inflation = RetirementIncomePlan(
        name="Fixed Pension",
        owner="person1",
        annual_income=Decimal('30000'),
        start_age=67,
        dob=date(1970, 1, 1),
        apply_inflation=False
    )
    # Calculate values after 30 years of inflation
    start_year = 2037  # Retirement year
    end_year = 2067    # 30 years later
    inflation_rate = Decimal('0.03')
    # With inflation
    result_with_inflation = calc.calculate_income_amount(
        income=income_with_inflation,
        year=end_year,
        inflation_rate=inflation_rate,
        plan_start_year=start_year
    )
    # Without inflation
    result_without_inflation = calc.calculate_income_amount(
        income=income_without_inflation,
        year=end_year,
        inflation_rate=inflation_rate,
        plan_start_year=start_year
    )
    # Verify inflation impact
    assert result_with_inflation.adjusted_amount > result_without_inflation.adjusted_amount
    expected_with_inflation = Decimal('30000') * (1 + inflation_rate) ** 30
    assert abs(result_with_inflation.adjusted_amount - expected_with_inflation) < Decimal('0.01')
def test_retirement_income_edge_cases():
    """Test edge cases in retirement income calculations."""
    calc = RetirementIncomeCalculator()
    # Test income starting exactly at plan start
    immediate_income = RetirementIncomePlan(
        name="Immediate Income",
        owner="person1",
        annual_income=Decimal('30000'),
        start_age=55,  # Current age
        dob=date(1970, 1, 1),
        apply_inflation=True
    )
    result = calc.calculate_income_amount(
        income=immediate_income,
        year=2025,  # Plan start year
        inflation_rate=Decimal('0.03'),
        plan_start_year=2025
    )
    assert result.is_active
    assert result.adjusted_amount == Decimal('30000')
    # Test income with maximum age
    max_age_income = RetirementIncomePlan(
        name="Max Age Test",
        owner="person1",
        annual_income=Decimal('30000'),
        start_age=65,
        end_age=120,  # Maximum age
        dob=date(1970, 1, 1),
        apply_inflation=True
    )
    # Test at age 119
    result = calc.calculate_income_amount(
        income=max_age_income,
        year=2089,  # Age 119
        inflation_rate=Decimal('0.03'),
        plan_start_year=2025
    )
    assert result.is_active
    # Test at age 121
    result = calc.calculate_income_amount(
        income=max_age_income,
        year=2091,  # Age 121
        inflation_rate=Decimal('0.03'),
        plan_start_year=2025
    )
    assert not result.is_active
def test_income_type_specific_calculations():
    """Test calculations specific to different income types."""
    calc = RetirementIncomeCalculator()
    # Test Social Security with special inflation rules
    social_security = RetirementIncomePlan(
        name="Social Security",
        owner="person1",
        annual_income=Decimal('30000'),
        start_age=67,
        income_type=RetirementIncomeType.SOCIAL_SECURITY,
        dob=date(1970, 1, 1),
        apply_inflation=True
    )
    # Test pension with no inflation
    pension = RetirementIncomePlan(
        name="Pension",
        owner="person1",
        annual_income=Decimal('40000'),
        start_age=65,
        income_type=RetirementIncomeType.PENSION,
        dob=date(1970, 1, 1),
        apply_inflation=False
    )
    # Calculate and compare different income types
    year = 2037  # When both are active
    ss_result = calc.calculate_income_amount(
        income=social_security,
        year=year,
        inflation_rate=Decimal('0.03'),
        plan_start_year=2025
    )
    pension_result = calc.calculate_income_amount(
        income=pension,
        year=year,
        inflation_rate=Decimal('0.03'),
        plan_start_year=2025
    )
    assert ss_result.is_active
    assert pension_result.is_active
    assert ss_result.income_type == RetirementIncomeType.SOCIAL_SECURITY
    assert pension_result.income_type == RetirementIncomeType.PENSION
def test_partial_year_activation():
    """Test retirement income activation for partial years."""
    calc = RetirementIncomeCalculator()
    # Test mid-year birthday activation
    mid_year_income = RetirementIncomePlan(
        name="Mid-Year Test",
        owner="person1",
        annual_income=Decimal('30000'),
        start_age=65,
        dob=date(1970, 6, 15),  # Mid-year birthday
        apply_inflation=True
    )
    # Test exact activation year
    activation_year = get_year_for_age(mid_year_income.dob, mid_year_income.start_age)
    result = calc.calculate_income_amount(
        income=mid_year_income,
        year=activation_year,
        inflation_rate=Decimal('0.03'),
        plan_start_year=2025
    )
    assert result.is_active
    assert result.partial_year_factor == Decimal('0.5')  # Half year
    assert result.adjusted_amount == Decimal('15000')  # Half of annual amount
def test_income_calculation_precision():
    """Test precision handling in income calculations."""
    calc = RetirementIncomeCalculator()
    # Test precise income amounts
    precise_income = RetirementIncomePlan(
        name="Precise Test",
        owner="person1",
        annual_income=Decimal('30123.45'),
        start_age=65,
        dob=date(1970, 1, 1),
        apply_inflation=True
    )
    result = calc.calculate_income_amount(
        income=precise_income,
        year=2035,
        inflation_rate=Decimal('0.03'),
        plan_start_year=2025
    )
    # Verify precision maintained
    assert isinstance(result.adjusted_amount, Decimal)
    assert result.adjusted_amount.as_tuple().exponent <= -2  # At least 2 decimal places
```

######## backend/database_operations/tests/test_scenario_calculations.py ########
```
# tests/test_scenario_calculations.py
from decimal import Decimal
from database_operations.calculations.scenario_calcs import ScenarioCalculator
from database_operations.models import Scenario, ScenarioAssumption
def test_basic_scenario_calculation(db_session, base_plan_with_facts):
    """Test basic scenario calculation with retirement spending."""
    calc = ScenarioCalculator()
    # Create scenario with retirement spending
    scenario = Scenario(
        plan_id=base_plan_with_facts.plan_id,
        scenario_name="Test Scenario"
    )
    db_session.add(scenario)
    db_session.flush()
    # Add scenario assumptions
    assumptions = ScenarioAssumption(
        scenario_id=scenario.scenario_id,
        retirement_age_1=65,
        default_growth_rate=Decimal('0.06'),
        inflation_rate=Decimal('0.03'),
        annual_retirement_spending=Decimal('50000')
    )
    db_session.add(assumptions)
    db_session.commit()
    # Calculate one year
    year = base_plan_with_facts.plan_creation_year
    result = calc.calculate_scenario_year(
        scenario_id=scenario.scenario_id,
        year=year,
        prior_result=None
    )
    assert result is not None
    # No retirement spending yet (before retirement)
    assert result.retirement_spending == Decimal('0')
    # Verify portfolio values are calculated
    assert result.scenario_portfolio.asset_values is not None
    assert result.scenario_portfolio.liability_values is not None
```

######## backend/database_operations/tests/test_scenario_creation.py ########
```
# tests/test_scenario_creation.py
import pytest
from decimal import Decimal
from datetime import date
from database_operations.crud.scenarios_crud import ScenarioCRUD
from database_operations.models import (
    Asset, Liability, InflowOutflow, RetirementIncomePlan,
    GrowthRateConfiguration, ScenarioOverride
)
@pytest.fixture
def complex_base_plan(db_session, base_plan_with_facts):
    """Creates a plan with multiple assets, liabilities, and configurations."""
    # Add additional growth rate configurations
    growth_config = GrowthRateConfiguration(
        asset_id=1,  # From base_plan_with_facts
        configuration_type='STEPWISE',
        start_year=2025,
        end_year=2027,
        growth_rate=Decimal('0.08')
    )
    db_session.add(growth_config)
    # Add additional retirement income
    pension = RetirementIncomePlan(
        plan_id=base_plan_with_facts.plan_id,
        name="Private Pension",
        owner="person1",
        annual_income=Decimal('25000'),
        start_age=65,
        apply_inflation=True
    )
    db_session.add(pension)
    # Add more complex cash flows
    bonus = InflowOutflow(
        plan_id=base_plan_with_facts.plan_id,
        type="inflow",
        name="Annual Bonus",
        owner="person1",
        annual_amount=Decimal('10000'),
        start_year=2025,
        end_year=2035,
        apply_inflation=True
    )
    db_session.add(bonus)
    db_session.commit()
    return base_plan_with_facts
def test_create_basic_scenario(db_session, base_plan):
    """Test basic scenario creation with assumption inheritance."""
    crud = ScenarioCRUD(db_session)
    scenario = crud.create_scenario(
        plan_id=base_plan.plan_id,
        scenario_name="Test Scenario"
    )
    # Verify scenario creation
    assert scenario is not None
    assert scenario.plan_id == base_plan.plan_id
    # Verify assumption inheritance
    scenario_with_assumptions = crud.get_scenario(
        scenario.scenario_id,
        include_assumptions=True
    )
    assert scenario_with_assumptions.assumptions is not None
    assert scenario_with_assumptions.assumptions.retirement_age_1 == base_plan.base_assumptions.retirement_age_1
    assert scenario_with_assumptions.assumptions.default_growth_rate == base_plan.base_assumptions.default_growth_rate
def test_create_scenario_with_retirement_spending(db_session, base_plan):
    """Test scenario creation with retirement spending."""
    crud = ScenarioCRUD(db_session)
    scenario = crud.create_scenario(
        plan_id=base_plan.plan_id,
        scenario_name="Retirement Test",
        assumptions={
            'annual_retirement_spending': Decimal('50000')
        }
    )
    scenario_assumptions = crud.get_scenario(
        scenario.scenario_id,
        include_assumptions=True
    ).assumptions
    assert scenario_assumptions.annual_retirement_spending == Decimal('50000')
def test_complete_scenario_inheritance(db_session, complex_base_plan):
    """Test comprehensive inheritance of all plan components."""
    crud = ScenarioCRUD(db_session)
    # Create scenario with single asset override
    scenario = crud.create_scenario(
        plan_id=complex_base_plan.plan_id,
        scenario_name="Inheritance Test"
    )
    # Override single asset value
    asset_override = ScenarioOverride(
        scenario_id=scenario.scenario_id,
        target_type="asset",
        target_id=1,
        field="value",
        value=Decimal('600000')
    )
    db_session.add(asset_override)
    db_session.commit()
    # Verify all components
    scenario_details = crud.get_scenario_details(scenario.scenario_id)
    # Check assets inheritance
    assert len(scenario_details.assets) == len(complex_base_plan.assets)
    modified_asset = next(a for a in scenario_details.assets if a.asset_id == 1)
    assert modified_asset.value == Decimal('600000')
    # Check unmodified assets maintain original values
    unmodified_assets = [a for a in scenario_details.assets if a.asset_id != 1]
    for asset in unmodified_assets:
        base_asset = next(a for a in complex_base_plan.assets if a.asset_id == asset.asset_id)
        assert asset.value == base_asset.value
    # Verify growth rate configurations inheritance
    assert len(scenario_details.growth_configurations) == len(complex_base_plan.growth_configurations)
    # Check liabilities inheritance
    assert len(scenario_details.liabilities) == len(complex_base_plan.liabilities)
    # Check cash flows inheritance
    assert len(scenario_details.cash_flows) == len(complex_base_plan.cash_flows)
    # Check retirement income inheritance
    assert len(scenario_details.retirement_income_plans) == len(complex_base_plan.retirement_income_plans)
def test_scenario_asset_inheritance(db_session, complex_base_plan):
    """Test detailed asset inheritance with growth configurations."""
    crud = ScenarioCRUD(db_session)
    # Create scenario with growth rate override
    scenario = crud.create_scenario(
        plan_id=complex_base_plan.plan_id,
        scenario_name="Asset Growth Test"
    )
    # Override growth rate configuration
    growth_override = ScenarioOverride(
        scenario_id=scenario.scenario_id,
        target_type="growth_rate",
        target_id=1,
        field="growth_rate",
        value=Decimal('0.09')
    )
    db_session.add(growth_override)
    db_session.commit()
    # Verify growth rate inheritance and override
    scenario_details = crud.get_scenario_details(scenario.scenario_id)
    modified_growth = next(
        g for g in scenario_details.growth_configurations 
        if g.asset_id == 1 and g.configuration_type == 'STEPWISE'
    )
    assert modified_growth.growth_rate == Decimal('0.09')
    # Verify other growth configurations remain unchanged
    unmodified_growth = [
        g for g in scenario_details.growth_configurations 
        if g.asset_id != 1 or g.configuration_type != 'STEPWISE'
    ]
    for growth in unmodified_growth:
        base_growth = next(
            g for g in complex_base_plan.growth_configurations 
            if g.asset_id == growth.asset_id
        )
        assert growth.growth_rate == base_growth.growth_rate
def test_scenario_override_validation(db_session, base_plan):
    """Test that scenario overrides are properly validated."""
    crud = ScenarioCRUD(db_session)
    scenario = crud.create_scenario(
        plan_id=base_plan.plan_id,
        scenario_name="Override Test"
    )
    # Should raise error when no target specified
    with pytest.raises(ValueError, match="Override must have a valid target"):
        crud.add_override(
            scenario_id=scenario.scenario_id,
            override_field="value",
            override_value="100000"
        )
    # Should raise error for invalid target type
    with pytest.raises(ValueError, match="Invalid target type"):
        crud.add_override(
            scenario_id=scenario.scenario_id,
            target_type="invalid_type",
            target_id=1,
            override_field="value",
            override_value="100000"
        )
    # Should raise error for non-existent target
    with pytest.raises(ValueError, match="Target not found"):
        crud.add_override(
            scenario_id=scenario.scenario_id,
            target_type="asset",
            target_id=999,
            override_field="value",
            override_value="100000"
        )
def test_scenario_assumption_inheritance(db_session, complex_base_plan):
    """Test inheritance and override of scenario assumptions."""
    crud = ScenarioCRUD(db_session)
    # Create scenario with modified assumptions
    scenario = crud.create_scenario(
        plan_id=complex_base_plan.plan_id,
        scenario_name="Assumption Test",
        assumptions={
            'retirement_age_1': 67,
            'default_growth_rate': Decimal('0.07')
        }
    )
    # Verify modified assumptions
    scenario_assumptions = crud.get_scenario(
        scenario.scenario_id,
        include_assumptions=True
    ).assumptions
    assert scenario_assumptions.retirement_age_1 == 67
    assert scenario_assumptions.default_growth_rate == Decimal('0.07')
    # Verify unmodified assumptions match base plan
    assert scenario_assumptions.inflation_rate == complex_base_plan.base_assumptions.inflation_rate
    assert scenario_assumptions.final_age_1 == complex_base_plan.base_assumptions.final_age_1
```

######## backend/database_operations/tests/test_timeline_validations.py ########
```
# tests/test_timeline_validations.py
from datetime import date, timedelta
import pytest
from database_operations.validation.scenario_timeline_validation import validate_projection_timeline
from database_operations.utils.time_utils import (
    get_age_in_year, 
    get_year_for_age,
    validate_year_not_before_plan_creation,
    map_age_to_years
)
def test_projection_timeline_validation():
    """Test validation of basic timeline constraints."""
    start_year = 2025
    # Valid timeline
    assert validate_projection_timeline(
        start_year=start_year,
        retirement_year=2035,
        end_year=2045
    )
    # Invalid: retirement before start
    assert not validate_projection_timeline(
        start_year=start_year,
        retirement_year=2024,
        end_year=2045
    )
    # Invalid: end before retirement
    assert not validate_projection_timeline(
        start_year=start_year,
        retirement_year=2035,
        end_year=2034
    )
def test_partial_year_transitions():
    """Test timeline validation with partial year transitions."""
    # Test mid-year retirement transitions
    dob = date(1970, 6, 15)  # Mid-year birthday
    start_year = 2025
    retirement_age = 65
    # Calculate exact retirement date
    retirement_year = get_year_for_age(dob, retirement_age)
    # Verify retirement year calculation accounts for mid-year birthday
    assert get_age_in_year(dob, retirement_year) == retirement_age
    # Test retirement year validation
    assert validate_projection_timeline(
        start_year=start_year,
        retirement_year=retirement_year,
        end_year=retirement_year + 10
    )
    # Test with different birth months
    early_year_dob = date(1970, 1, 1)
    late_year_dob = date(1970, 12, 31)
    early_retirement_year = get_year_for_age(early_year_dob, retirement_age)
    late_retirement_year = get_year_for_age(late_year_dob, retirement_age)
    # Verify age calculations for different birth months
    assert get_age_in_year(early_year_dob, early_retirement_year) == retirement_age
    assert get_age_in_year(late_year_dob, late_retirement_year) == retirement_age
def test_age_based_timeline_edge_cases():
    """Test timeline validation for age-based edge cases."""
    dob = date(1970, 1, 1)
    start_year = 2025
    # Test retirement at exact year boundary
    retirement_age = 65
    retirement_year = get_year_for_age(dob, retirement_age)
    # Verify timeline with exact boundary retirement
    assert validate_projection_timeline(
        start_year=start_year,
        retirement_year=retirement_year,
        end_year=retirement_year + 30
    )
    # Test maximum age scenarios
    max_age = 120
    end_year = get_year_for_age(dob, max_age)
    # Verify timeline with maximum age
    assert validate_projection_timeline(
        start_year=start_year,
        retirement_year=retirement_year,
        end_year=end_year
    )
    # Test century boundary transition
    century_boundary_dob = date(1999, 12, 31)
    century_retirement_age = 65
    century_retirement_year = get_year_for_age(century_boundary_dob, century_retirement_age)
    assert validate_projection_timeline(
        start_year=2025,
        retirement_year=century_retirement_year,
        end_year=century_retirement_year + 30
    )
def test_timeline_modification_validation():
    """Test validation of timeline modifications."""
    dob = date(1970, 1, 1)
    start_year = 2025
    original_retirement_age = 65
    original_retirement_year = get_year_for_age(dob, original_retirement_age)
    # Test moving retirement earlier
    early_retirement_age = 62
    early_retirement_year = get_year_for_age(dob, early_retirement_age)
    assert validate_projection_timeline(
        start_year=start_year,
        retirement_year=early_retirement_year,
        end_year=original_retirement_year + 30
    )
    # Test moving retirement later
    late_retirement_age = 70
    late_retirement_year = get_year_for_age(dob, late_retirement_age)
    assert validate_projection_timeline(
        start_year=start_year,
        retirement_year=late_retirement_year,
        end_year=late_retirement_year + 25
    )
    # Test extending end date
    extended_end_year = late_retirement_year + 35
    assert validate_projection_timeline(
        start_year=start_year,
        retirement_year=late_retirement_year,
        end_year=extended_end_year
    )
def test_age_year_mapping_validation():
    """Test validation of age-to-year mapping scenarios."""
    dob = date(1970, 1, 1)
    start_year = 2025
    end_year = 2055
    # Generate complete age-to-year mapping
    age_year_map = map_age_to_years(dob, start_year, end_year)
    # Verify all ages are present
    start_age = get_age_in_year(dob, start_year)
    end_age = get_age_in_year(dob, end_year)
    assert len(age_year_map) == (end_age - start_age + 1)
    assert all(age in age_year_map for age in range(start_age, end_age + 1))
    # Verify correct year mapping
    for age, year in age_year_map.items():
        assert get_age_in_year(dob, year) == age
def test_invalid_timeline_scenarios():
    """Test various invalid timeline scenarios."""
    start_year = 2025
    # Test invalid year order
    with pytest.raises(ValueError):
        validate_projection_timeline(
            start_year=2030,  # Start after retirement
            retirement_year=2025,
            end_year=2045
        )
    # Test same year retirement
    with pytest.raises(ValueError):
        validate_projection_timeline(
            start_year=2025,
            retirement_year=2025,  # Same as start
            end_year=2045
        )
    # Test same year end
    with pytest.raises(ValueError):
        validate_projection_timeline(
            start_year=2025,
            retirement_year=2035,
            end_year=2035  # Same as retirement
        )
def test_timeline_consistency_across_scenarios():
    """Test timeline consistency when used across multiple scenarios."""
    dob = date(1970, 1, 1)
    start_year = 2025
    retirement_age = 65
    retirement_year = get_year_for_age(dob, retirement_age)
    end_year = retirement_year + 30
    # Base timeline
    assert validate_projection_timeline(
        start_year=start_year,
        retirement_year=retirement_year,
        end_year=end_year
    )
    # Scenario variations
    variations = [
        (retirement_age - 3, 30),  # Early retirement
        (retirement_age + 3, 27),  # Late retirement
        (retirement_age, 35),      # Extended end date
        (retirement_age, 25)       # Shorter end date
    ]
    for var_retirement_age, years_after_retirement in variations:
        var_retirement_year = get_year_for_age(dob, var_retirement_age)
        var_end_year = var_retirement_year + years_after_retirement
        assert validate_projection_timeline(
            start_year=start_year,
            retirement_year=var_retirement_year,
            end_year=var_end_year
        )
def test_leap_year_handling():
    """Test timeline validation with leap year considerations."""
    # Test DOB on Feb 29
    leap_year_dob = date(1972, 2, 29)  # Leap year
    start_year = 2025
    retirement_age = 65
    retirement_year = get_year_for_age(leap_year_dob, retirement_age)
    # Verify correct age calculation for leap year birth date
    assert get_age_in_year(leap_year_dob, retirement_year) == retirement_age
    # Verify timeline validation works correctly with leap year DOB
    assert validate_projection_timeline(
        start_year=start_year,
        retirement_year=retirement_year,
        end_year=retirement_year + 30
    )
```

######## backend/database_operations/tests/test_time_handeling.py ########
```
# tests/test_time_handling.py
from datetime import date
import pytest
from database_operations.utils.time_utils import (
    get_age_in_year,
    get_year_for_age,
    validate_year_not_before_plan_creation
)
def test_age_year_conversion():
    """Test conversion between ages and years."""
    dob = date(1970, 1, 1)
    # Basic age calculation
    assert get_age_in_year(dob, 2025) == 55
    # Year for age calculation
    assert get_year_for_age(dob, 65) == 2035
    # Verify consistency
    retirement_age = 65
    retirement_year = get_year_for_age(dob, retirement_age)
    assert get_age_in_year(dob, retirement_year) == retirement_age
def test_plan_creation_year_validation():
    """Test validation of years against plan creation."""
    plan_creation_year = 2025
    # Valid years
    assert validate_year_not_before_plan_creation(2025, plan_creation_year)
    assert validate_year_not_before_plan_creation(2026, plan_creation_year)
    # Invalid years
    assert not validate_year_not_before_plan_creation(2024, plan_creation_year)
def test_age_calculations_with_partial_years():
    """Test age calculations considering month/day."""
    dob = date(1970, 6, 15)
    # Should be 54 at start of 2025
    assert get_age_in_year(dob, 2025) == 54
    # Different DOB timing
    early_dob = date(1970, 1, 1)
    late_dob = date(1970, 12, 31)
    assert get_age_in_year(early_dob, 2025) == 55
    assert get_age_in_year(late_dob, 2025) == 54
```

######## backend/database_operations/tests/__init__.py ########
```
"""Test package for database operations.""" 
```

