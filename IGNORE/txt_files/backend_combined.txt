######## backend/main.py ########
```
"""
Main entry point for the FIPLI application.
This file handles initialization of core components like the database.
"""
from database_operations.connection import init_database, get_session
def initialize_application():
    """Initialize all required components of the application."""
    print("Initializing FIPLI application...")
    # Initialize the database first
    print("Initializing database...")
    engine = init_database()
    print("Database initialized successfully!")
    return engine
def main():
    """Main entry point of the application."""
    try:
        engine = initialize_application()
        # At this point, the database is initialized and ready to use
        # You can add more startup logic here as needed
        print("FIPLI application started successfully!")
        return engine
    except Exception as e:
        print(f"Error starting application: {str(e)}")
        raise
if __name__ == "__main__":
    # This means "only run this if you're running this file directly"
    main() 
```

######## backend/database_operations/connection.py ########
```
# backend\database_operations\connection.py
from pathlib import Path
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session
from sqlalchemy.engine import Engine
from sqlalchemy.pool import StaticPool
from .models import init_tables
# Get the absolute path to the database file
DB_PATH = Path(__file__).parent / "database" / "fiply2_database.db"
# Global engine instance
_engine = None
def init_database() -> Engine:
    """Initialize the database engine and tables. Call this once when your application starts."""
    global _engine
    if _engine is None:
        # Create database directory if it doesn't exist
        DB_PATH.parent.mkdir(parents=True, exist_ok=True)
        # Create SQLite database engine with 2.0 style
        _engine = create_engine(
            f"sqlite:///{DB_PATH}",
            echo=False,  # Set to True for SQL query logging
            future=True,  # Use SQLAlchemy 2.0 style
            poolclass=StaticPool,  # Better for SQLite
            connect_args={"check_same_thread": False}  # Allow multi-threading for SQLite
        )
        # Initialize tables
        init_tables(_engine)
    return _engine
def get_engine() -> Engine:
    """Get the database engine. Make sure init_database() was called first."""
    global _engine
    if _engine is None:
        raise RuntimeError("Database not initialized. Call init_database() first.")
    return _engine
def get_session() -> Session:
    """Create and return a new database session."""
    engine = get_engine()  # This will raise an error if init_database() wasn't called
    # 2.0 style session creation
    SessionLocal = sessionmaker(
        bind=engine,
        autocommit=False,
        autoflush=False,
        future=True  # Use 2.0 style
    )
    return SessionLocal()
```

######## backend/database_operations/models.py ########
```
# backend\database_operations\models.py
from datetime import datetime, date
from typing import Optional, List
from sqlalchemy import Integer, String, Float, Date, DateTime, ForeignKey, Text, Boolean
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship
from sqlalchemy.ext.asyncio import AsyncAttrs
class Base(AsyncAttrs, DeclarativeBase):
    """Base class for all SQLAlchemy models."""
    pass
class Household(Base):
    """Represents a household in the financial planning system."""
    __tablename__ = "households"
    household_id: Mapped[int] = mapped_column(Integer, primary_key=True)
    household_name: Mapped[str] = mapped_column(Text, nullable=False)
    person1_first_name: Mapped[str] = mapped_column(Text, nullable=False)
    person1_last_name: Mapped[str] = mapped_column(Text, nullable=False)
    person1_dob: Mapped[date] = mapped_column(Date, nullable=False)
    person2_first_name: Mapped[Optional[str]] = mapped_column(Text)
    person2_last_name: Mapped[Optional[str]] = mapped_column(Text)
    person2_dob: Mapped[Optional[date]] = mapped_column(Date)
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.now)
    updated_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.now, onupdate=datetime.now)
    plans: Mapped[List["Plan"]] = relationship(back_populates="household", cascade="all, delete-orphan")
class Plan(Base):
    """Financial plan model."""
    __tablename__ = "plans"
    plan_id: Mapped[int] = mapped_column(Integer, primary_key=True)
    household_id: Mapped[int] = mapped_column(ForeignKey("households.household_id", ondelete="CASCADE"), nullable=False)
    plan_name: Mapped[str] = mapped_column(Text, nullable=False)
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.now)
    updated_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.now, onupdate=datetime.now)
    reference_person: Mapped[int] = mapped_column(Integer, nullable=False, default=1)
    plan_creation_year: Mapped[Optional[int]] = mapped_column(Integer)
    # Relationships
    household: Mapped["Household"] = relationship("Household", back_populates="plans")
    base_assumptions: Mapped[Optional["BaseAssumption"]] = relationship(
        back_populates="plan", 
        uselist=False,
        cascade="all, delete-orphan"
    )
    scenarios: Mapped[List["Scenario"]] = relationship(
        back_populates="plan",
        cascade="all, delete-orphan"
    )
    asset_categories: Mapped[List["AssetCategory"]] = relationship(
        back_populates="plan", 
        cascade="all, delete-orphan"
    )
    liability_categories: Mapped[List["LiabilityCategory"]] = relationship(
        back_populates="plan", 
        cascade="all, delete-orphan"
    )
    assets: Mapped[List["Asset"]] = relationship(
        back_populates="plan", 
        cascade="all, delete-orphan"
    )
    liabilities: Mapped[List["Liability"]] = relationship(
        back_populates="plan", 
        cascade="all, delete-orphan"
    )
    inflows_outflows: Mapped[List["InflowOutflow"]] = relationship(
        back_populates="plan", 
        cascade="all, delete-orphan"
    )
    retirement_income_plans: Mapped[List["RetirementIncomePlan"]] = relationship(
        back_populates="plan", 
        cascade="all, delete-orphan"
    )
class BaseAssumption(Base):
    """Stores global assumptions for a plan."""
    __tablename__ = "base_assumptions"
    plan_id: Mapped[int] = mapped_column(ForeignKey("plans.plan_id", ondelete="CASCADE"), primary_key=True)
    retirement_age_1: Mapped[Optional[int]] = mapped_column(Integer)
    retirement_age_2: Mapped[Optional[int]] = mapped_column(Integer)
    final_age_1: Mapped[Optional[int]] = mapped_column(Integer)
    final_age_2: Mapped[Optional[int]] = mapped_column(Integer)
    final_age_selector: Mapped[Optional[int]] = mapped_column(Integer)
    default_growth_rate: Mapped[Optional[float]] = mapped_column(Float)
    inflation_rate: Mapped[Optional[float]] = mapped_column(Float)
    plan: Mapped["Plan"] = relationship("Plan", back_populates="base_assumptions")
class Scenario(Base):
    """Represents a what-if scenario for a plan."""
    __tablename__ = "scenarios"
    scenario_id: Mapped[int] = mapped_column(Integer, primary_key=True)
    plan_id: Mapped[int] = mapped_column(ForeignKey("plans.plan_id", ondelete="CASCADE"), nullable=False)
    scenario_name: Mapped[str] = mapped_column(Text, nullable=False)
    scenario_color: Mapped[Optional[str]] = mapped_column(Text)
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.now)
    plan: Mapped["Plan"] = relationship("Plan", back_populates="scenarios")
    assumptions: Mapped[Optional["ScenarioAssumption"]] = relationship(
        back_populates="scenario", 
        uselist=False,
        cascade="all, delete-orphan"
    )
    overrides: Mapped[List["ScenarioOverride"]] = relationship(
        back_populates="scenario", 
        cascade="all, delete-orphan"
    )
    growth_rates: Mapped[List["GrowthRateConfiguration"]] = relationship(
        back_populates="scenario", 
        cascade="all, delete-orphan"
    )
class ScenarioAssumption(Base):
    """Stores scenario-specific assumptions."""
    __tablename__ = "scenario_assumptions"
    scenario_id: Mapped[int] = mapped_column(ForeignKey("scenarios.scenario_id", ondelete="CASCADE"), primary_key=True)
    retirement_age_1: Mapped[Optional[int]] = mapped_column(Integer)
    retirement_age_2: Mapped[Optional[int]] = mapped_column(Integer)
    default_growth_rate: Mapped[Optional[float]] = mapped_column(Float)
    inflation_rate: Mapped[Optional[float]] = mapped_column(Float)
    annual_retirement_spending: Mapped[Optional[float]] = mapped_column(Float)
    scenario: Mapped["Scenario"] = relationship("Scenario", back_populates="assumptions")
class ScenarioOverride(Base):
    """Stores granular overrides for financial components within scenarios."""
    __tablename__ = "scenario_overrides"
    override_id: Mapped[int] = mapped_column(Integer, primary_key=True)
    scenario_id: Mapped[int] = mapped_column(ForeignKey("scenarios.scenario_id", ondelete="CASCADE"), nullable=False)
    asset_id: Mapped[Optional[int]] = mapped_column(ForeignKey("assets.asset_id", ondelete="CASCADE"))
    liability_id: Mapped[Optional[int]] = mapped_column(ForeignKey("liabilities.liability_id", ondelete="CASCADE"))
    inflow_outflow_id: Mapped[Optional[int]] = mapped_column(ForeignKey("inflows_outflows.inflow_outflow_id", ondelete="CASCADE"))
    retirement_income_plan_id: Mapped[Optional[int]] = mapped_column(ForeignKey("retirement_income_plans.income_plan_id", ondelete="CASCADE"))
    override_field: Mapped[str] = mapped_column(Text, nullable=False)
    override_value: Mapped[str] = mapped_column(Text, nullable=False)
    scenario = relationship("Scenario", back_populates="overrides")
    asset = relationship("Asset", back_populates="overrides")
    liability = relationship("Liability", back_populates="overrides")
    inflow_outflow = relationship("InflowOutflow", back_populates="overrides")
    retirement_income_plan = relationship("RetirementIncomePlan", back_populates="overrides")
class AssetCategory(Base):
    """Represents categories for organizing assets."""
    __tablename__ = "asset_categories"
    asset_category_id: Mapped[int] = mapped_column(Integer, primary_key=True)
    plan_id: Mapped[int] = mapped_column(ForeignKey("plans.plan_id", ondelete="CASCADE"), nullable=False)
    category_name: Mapped[str] = mapped_column(Text, nullable=False)
    category_order: Mapped[int] = mapped_column(Integer, default=0)
    plan = relationship("Plan", back_populates="asset_categories")
    assets = relationship("Asset", back_populates="category")
class Asset(Base):
    """Represents assets associated with a plan."""
    __tablename__ = "assets"
    asset_id: Mapped[int] = mapped_column(Integer, primary_key=True)
    plan_id: Mapped[int] = mapped_column(ForeignKey("plans.plan_id", ondelete="CASCADE"), nullable=False)
    asset_category_id: Mapped[int] = mapped_column(ForeignKey("asset_categories.asset_category_id", ondelete="CASCADE"), nullable=False)
    asset_name: Mapped[str] = mapped_column(Text, nullable=False)
    owner: Mapped[str] = mapped_column(Text, nullable=False)  # 'person1', 'person2', or 'joint'
    value: Mapped[float] = mapped_column(Float, nullable=False)
    include_in_nest_egg: Mapped[bool] = mapped_column(Boolean, default=True)
    plan = relationship("Plan", back_populates="assets")
    category = relationship("AssetCategory", back_populates="assets")
    overrides = relationship("ScenarioOverride", back_populates="asset")
    growth_rates = relationship("GrowthRateConfiguration", back_populates="asset")
class LiabilityCategory(Base):
    """Represents categories for organizing liabilities."""
    __tablename__ = "liability_categories"
    liability_category_id: Mapped[int] = mapped_column(Integer, primary_key=True)
    plan_id: Mapped[int] = mapped_column(ForeignKey("plans.plan_id", ondelete="CASCADE"), nullable=False)
    category_name: Mapped[str] = mapped_column(Text, nullable=False)
    category_order: Mapped[int] = mapped_column(Integer, default=0)
    plan = relationship("Plan", back_populates="liability_categories")
    liabilities = relationship("Liability", back_populates="category")
class Liability(Base):
    """Represents liabilities associated with a plan."""
    __tablename__ = "liabilities"
    liability_id: Mapped[int] = mapped_column(Integer, primary_key=True)
    plan_id: Mapped[int] = mapped_column(ForeignKey("plans.plan_id", ondelete="CASCADE"), nullable=False)
    liability_category_id: Mapped[int] = mapped_column(ForeignKey("liability_categories.liability_category_id", ondelete="CASCADE"), nullable=False)
    liability_name: Mapped[str] = mapped_column(Text, nullable=False)
    owner: Mapped[str] = mapped_column(Text, nullable=False)  # 'person1', 'person2', or 'joint'
    value: Mapped[float] = mapped_column(Float, nullable=False)
    interest_rate: Mapped[Optional[float]] = mapped_column(Float)
    include_in_nest_egg: Mapped[bool] = mapped_column(Boolean, default=True)
    plan = relationship("Plan", back_populates="liabilities")
    category = relationship("LiabilityCategory", back_populates="liabilities")
    overrides = relationship("ScenarioOverride", back_populates="liability")
class InflowOutflow(Base):
    """Represents recurring cash flows (income or expenses)."""
    __tablename__ = "inflows_outflows"
    inflow_outflow_id: Mapped[int] = mapped_column(Integer, primary_key=True)
    plan_id: Mapped[int] = mapped_column(ForeignKey("plans.plan_id", ondelete="CASCADE"), nullable=False)
    type: Mapped[str] = mapped_column(Text, nullable=False)  # 'inflow' or 'outflow'
    name: Mapped[str] = mapped_column(Text, nullable=False)
    owner: Mapped[str] = mapped_column(Text, nullable=False)  # 'person1', 'person2', or 'joint'
    annual_amount: Mapped[float] = mapped_column(Float, nullable=False)
    start_year: Mapped[int] = mapped_column(Integer, nullable=False)
    end_year: Mapped[Optional[int]] = mapped_column(Integer)
    apply_inflation: Mapped[bool] = mapped_column(Boolean, default=False)
    plan = relationship("Plan", back_populates="inflows_outflows")
    overrides = relationship("ScenarioOverride", back_populates="inflow_outflow")
class RetirementIncomePlan(Base):
    """Represents retirement income sources like Social Security or pensions."""
    __tablename__ = "retirement_income_plans"
    income_plan_id: Mapped[int] = mapped_column(Integer, primary_key=True)
    plan_id: Mapped[int] = mapped_column(ForeignKey("plans.plan_id", ondelete="CASCADE"), nullable=False)
    name: Mapped[str] = mapped_column(Text, nullable=False)
    owner: Mapped[str] = mapped_column(Text, nullable=False)  # 'person1', 'person2', or 'joint'
    annual_income: Mapped[float] = mapped_column(Float, nullable=False)
    start_age: Mapped[int] = mapped_column(Integer, nullable=False)
    end_age: Mapped[Optional[int]] = mapped_column(Integer)
    include_in_nest_egg: Mapped[bool] = mapped_column(Boolean, default=True)
    apply_inflation: Mapped[bool] = mapped_column(Boolean, default=False)
    plan = relationship("Plan", back_populates="retirement_income_plans")
    overrides = relationship("ScenarioOverride", back_populates="retirement_income_plan")
    growth_rates = relationship("GrowthRateConfiguration", back_populates="retirement_income_plan")
class GrowthRateConfiguration(Base):
    """Manages growth rates for assets and retirement income plans."""
    __tablename__ = "growth_rate_configurations"
    growth_rate_id: Mapped[int] = mapped_column(Integer, primary_key=True)
    asset_id: Mapped[Optional[int]] = mapped_column(ForeignKey("assets.asset_id", ondelete="CASCADE"))
    retirement_income_plan_id: Mapped[Optional[int]] = mapped_column(ForeignKey("retirement_income_plans.income_plan_id", ondelete="CASCADE"))
    scenario_id: Mapped[Optional[int]] = mapped_column(ForeignKey("scenarios.scenario_id", ondelete="CASCADE"))
    configuration_type: Mapped[str] = mapped_column(Text, nullable=False)  # 'DEFAULT', 'OVERRIDE', or 'STEPWISE'
    start_year: Mapped[int] = mapped_column(Integer, nullable=False)
    end_year: Mapped[Optional[int]] = mapped_column(Integer)
    growth_rate: Mapped[float] = mapped_column(Float, nullable=False)
    asset = relationship("Asset", back_populates="growth_rates")
    retirement_income_plan = relationship("RetirementIncomePlan", back_populates="growth_rates")
    scenario = relationship("Scenario", back_populates="growth_rates")
def init_tables(engine):
    """Initialize database tables. Should be called after engine is created."""
    Base.metadata.create_all(bind=engine)
```

######## backend/database_operations/__init__.py ########
```
# backend/database_operations/__init__.py
```

######## backend/database_operations/calculations/scenario_calcs.py ########
```
"""
## Scenarios
- Clone of base facts
- Inherits all base facts and base assumptions
- Can override any base fact as well as the fact's parameters
- Unique: Has retirement spending
- Retirement spending:
  - Starts at retirement year
  - Always inflation adjusted
  - Common use: Max sustainable spend
## Base Facts Aggregation
Base facts must remain unchanged while scenarios can modify:
- Asset values and growth
- Liability values and interest
- Cash flow amounts and timing
- Retirement income amounts and timing
- Base assumptions
## Value Display Principles
- All values shown in current dollars
- Inflation adjustments compound annually
Key features of this implementation:
1. Proper inheritance of base facts
2. Support for all types of overrides
3. Always-inflating retirement spending
4. Clear tracking of override impacts
5. Maintains base fact integrity
6. Comprehensive validation
"""
from dataclasses import dataclass
from decimal import Decimal
from typing import List, Dict, Optional
from copy import deepcopy
from ..models import ScenarioAssumption, ScenarioOverride
from .base_facts.base_facts_calcs import BaseFacts, YearlyCalculationResult, PortfolioValues
from ..utils.money_utils import to_decimal, apply_annual_inflation
@dataclass
class ScenarioFact:
    """Holds scenario-specific data and overrides."""
    scenario_id: int
    name: str
    base_facts: BaseFacts
    retirement_spending: Decimal
    assumption_overrides: Optional[ScenarioAssumption]
    component_overrides: List[ScenarioOverride]
@dataclass
class ScenarioCalculationResult:
    """Stores results of scenario calculations."""
    base_result: YearlyCalculationResult
    scenario_portfolio: PortfolioValues
    retirement_spending: Decimal
    adjusted_spending: Decimal
    spending_impact: Decimal
    override_impacts: Dict[str, Decimal]
    metadata: Dict
class ScenarioCalculator:
    """Calculates scenario outcomes with overrides and spending adjustments."""
    def calculate_scenario_year(self, scenario: ScenarioFact, year: int,
                                base_result: YearlyCalculationResult,
                                prior_scenario_result: Optional[ScenarioCalculationResult] = None) -> ScenarioCalculationResult:
        """Computes scenario values based on base results."""
        portfolio = deepcopy(base_result.ending_portfolio)
        override_impacts = self._apply_component_overrides(portfolio, scenario.component_overrides)
        retirement_spending = adjusted_spending = spending_impact = Decimal('0')
        if self._is_retirement_spending_active(scenario, year):
            retirement_spending = scenario.retirement_spending
            adjusted_spending = apply_annual_inflation(retirement_spending, self._get_inflation_rate(scenario),
                                                       year - scenario.base_facts.start_year)
            spending_impact = adjusted_spending - retirement_spending
            portfolio = self._apply_retirement_spending(portfolio, adjusted_spending)
        return ScenarioCalculationResult(
            base_result=base_result,
            scenario_portfolio=portfolio,
            retirement_spending=retirement_spending,
            adjusted_spending=adjusted_spending,
            spending_impact=spending_impact,
            override_impacts=override_impacts,
            metadata=self._generate_calculation_metadata(scenario, year, override_impacts, spending_impact)
        )
    def _apply_component_overrides(self, portfolio: PortfolioValues, overrides: List[ScenarioOverride]) -> Dict[str, Decimal]:
        """Applies scenario component overrides to portfolio."""
        impacts = {key: Decimal('0') for key in ["asset_value", "liability_value", "cash_flow", "retirement_income"]}
        for override in overrides:
            original_value = self._get_original_value(portfolio, override)
            new_value = to_decimal(override.override_value)
            impact = new_value - original_value
            if override.asset_id:
                impacts["asset_value"] += impact
                portfolio.asset_values[override.asset_id] = new_value
            elif override.liability_id:
                impacts["liability_value"] += impact
                portfolio.liability_values[override.liability_id] = new_value
        return impacts
    def _apply_retirement_spending(self, portfolio: PortfolioValues, spending_amount: Decimal) -> PortfolioValues:
        """Deducts retirement spending from portfolio values."""
        portfolio.retirement_portfolio_value -= spending_amount
        return self._update_portfolio_totals(portfolio)
    def _is_retirement_spending_active(self, scenario: ScenarioFact, year: int) -> bool:
        """Checks if retirement spending applies in a given year."""
        retirement_year = (scenario.assumption_overrides.retirement_age_1
                           if scenario.assumption_overrides and scenario.assumption_overrides.retirement_age_1
                           else scenario.base_facts.retirement_year)
        return year >= retirement_year
    def _get_inflation_rate(self, scenario: ScenarioFact) -> Decimal:
        """Retrieves applicable inflation rate, considering overrides."""
        return (scenario.assumption_overrides.inflation_rate
                if scenario.assumption_overrides and scenario.assumption_overrides.inflation_rate is not None
                else to_decimal(scenario.base_facts.base_assumptions.inflation_rate))
    def _get_original_value(self, portfolio: PortfolioValues, override: ScenarioOverride) -> Decimal:
        """Fetches the original value for a given override target."""
        return (portfolio.asset_values.get(override.asset_id, Decimal('0')) if override.asset_id
                else portfolio.liability_values.get(override.liability_id, Decimal('0')) if override.liability_id
                else Decimal('0'))
    def _update_portfolio_totals(self, portfolio: PortfolioValues) -> PortfolioValues:
        """Recalculates total net worth after adjustments."""
        portfolio.total_net_worth = sum(portfolio.asset_values.values()) - sum(portfolio.liability_values.values())
        return portfolio
    def _generate_calculation_metadata(self, scenario: ScenarioFact, year: int,
                                       override_impacts: Dict[str, Decimal], spending_impact: Decimal) -> Dict:
        """Generates metadata for a scenario calculation."""
        return {
            "scenario_name": scenario.name,
            "year": year,
            "override_count": len(scenario.component_overrides),
            "total_override_impact": sum(override_impacts.values()),
            "spending_impact": spending_impact
        }
    def validate_scenario_facts(self, scenario: ScenarioFact) -> None:
        """Ensures scenario inputs are valid before calculations."""
        if scenario.retirement_spending < 0:
            raise ValueError("Retirement spending cannot be negative")
        if scenario.assumption_overrides and scenario.assumption_overrides.retirement_age_1 is not None:
            if scenario.assumption_overrides.retirement_age_1 < 0:
                raise ValueError("Invalid retirement age override")
        for override in scenario.component_overrides:
            if not any([override.asset_id, override.liability_id, override.inflow_outflow_id, override.retirement_income_plan_id]):
                raise ValueError(f"Override {override.override_id} has no target")
    def generate_override_summary(self, scenario: ScenarioFact) -> Dict[str, int]:
        """Generates a summary of scenario overrides."""
        summary = {key: 0 for key in ["asset_overrides", "liability_overrides", "cash_flow_overrides", "retirement_income_overrides"]}
        for override in scenario.component_overrides:
            if override.asset_id:
                summary["asset_overrides"] += 1
            elif override.liability_id:
                summary["liability_overrides"] += 1
            elif override.inflow_outflow_id:
                summary["cash_flow_overrides"] += 1
            elif override.retirement_income_plan_id:
                summary["retirement_income_overrides"] += 1
        return summary
```

######## backend/database_operations/calculations/__init__.py ########
```
"""Financial calculations package.""" 
```

######## backend/database_operations/calculations/base_facts/assets_calcs.py ########
```
"""
## Assets
- Value  
- Optional category assignment  
- Growth handling:  
  1. Default: Uses base assumption growth rate  
  2. Override: Asset-specific fixed rate  
  3. Stepwise: Multiple rates over time periods (start year / end year)  
  4. Gaps in stepwise fall to default  
- Optional inflation toggle
## Growth Rate System
- Assets can have default, fixed, or stepwise growth rates
- Stepwise: Multiple rates over time periods
- Gaps in stepwise fall to default
This implementation:
1. Handles the three types of growth rates (default, override, stepwise)
2. Properly falls back to default rate when needed
3. Manages category aggregation
4. Tracks which assets are included in retirement portfolio
5. Provides detailed calculation metadata
6. Validates configurations and prevents overlapping periods
"""
from dataclasses import dataclass
from decimal import Decimal
from typing import List, Dict, Optional
from ...models import GrowthRateConfiguration
from ...utils.money_utils import to_decimal, apply_annual_compound_rate, combine_amounts, round_to_currency
from ...validation.money_validation import validate_positive_amount, validate_rate
from ...validation.growth_validation import validate_growth_config_type, validate_stepwise_periods
@dataclass
class AssetFact:
    """Stores asset details and growth configurations."""
    asset_id: int
    value: Decimal
    category_id: int
    include_in_nest_egg: bool
    growth_configs: List[GrowthRateConfiguration]
    owner: str
    name: str
@dataclass
class AssetCalculationResult:
    """Stores results of asset growth calculations."""
    asset_id: int
    starting_value: Decimal
    ending_value: Decimal
    applied_growth_rate: Decimal
    category_id: int
    growth_amount: Decimal
    included_in_nest_egg: bool
    metadata: Dict
class AssetCalculator:
    """Handles asset valuation with growth rate application."""
    def calculate_asset_value(self, asset: AssetFact, year: int, default_rate: Decimal,
                              plan_creation_year: int) -> AssetCalculationResult:
        """Calculates asset value applying growth rates."""
        if year < plan_creation_year:
            raise ValueError(f"Cannot calculate asset value before plan creation year {plan_creation_year}")
        starting_value = asset.value
        growth_rate = self._get_applicable_growth_rate(asset.growth_configs, year, default_rate)
        ending_value = apply_annual_compound_rate(starting_value, growth_rate)
        growth_amount = ending_value - starting_value
        return AssetCalculationResult(
            asset_id=asset.asset_id,
            starting_value=starting_value,
            ending_value=ending_value,
            applied_growth_rate=growth_rate,
            category_id=asset.category_id,
            growth_amount=growth_amount,
            included_in_nest_egg=asset.include_in_nest_egg,
            metadata=self._generate_metadata(asset, year, growth_rate, growth_amount)
        )
    def calculate_multiple_assets(self, assets: List[AssetFact], year: int, default_rate: Decimal,
                                  plan_creation_year: int) -> List[AssetCalculationResult]:
        """Calculates values for multiple assets."""
        self.validate_asset_facts(assets)
        return [self.calculate_asset_value(asset, year, default_rate, plan_creation_year) for asset in assets]
    def aggregate_by_category(self, results: List[AssetCalculationResult]) -> Dict[int, Decimal]:
        """Aggregates assets by category."""
        totals: Dict[int, Decimal] = {}
        for result in results:
            totals[result.category_id] = combine_amounts([totals.get(result.category_id, Decimal('0')), result.ending_value])
        return totals
    def calculate_nest_egg_value(self, results: List[AssetCalculationResult]) -> Decimal:
        """Computes total value of nest-egg eligible assets."""
        return combine_amounts([r.ending_value for r in results if r.included_in_nest_egg])
    def _get_applicable_growth_rate(self, growth_configs: List[GrowthRateConfiguration], year: int,
                                    default_rate: Decimal) -> Decimal:
        """Determines applicable growth rate based on hierarchy."""
        for config in sorted(growth_configs, key=lambda c: c.configuration_type == 'OVERRIDE', reverse=True):
            if config.configuration_type == 'STEPWISE' and config.start_year <= year <= (config.end_year or year):
                return to_decimal(config.growth_rate)
            if config.configuration_type == 'OVERRIDE':
                return to_decimal(config.growth_rate)
        return default_rate
    def validate_asset_facts(self, assets: List[AssetFact]) -> None:
        """Validates asset values and growth configurations."""
        for asset in assets:
            validate_positive_amount(asset.value, f"asset_{asset.asset_id}_value")
            for config in asset.growth_configs:
                validate_growth_config_type(config.configuration_type, f"asset_{asset.asset_id}_growth_type")
            stepwise_periods = [{"start_year": c.start_year, "end_year": c.end_year}
                                for c in asset.growth_configs if c.configuration_type == 'STEPWISE']
            if stepwise_periods:
                validate_stepwise_periods(stepwise_periods, f"asset_{asset.asset_id}_growth_periods")
    def _generate_metadata(self, asset: AssetFact, year: int, applied_rate: Decimal, growth_amount: Decimal) -> Dict:
        """Generates metadata about asset valuation."""
        return {
            "asset_name": asset.name,
            "owner": asset.owner,
            "year": year,
            "applied_growth_rate": str(round_to_currency(applied_rate)),
            "growth_amount": str(round_to_currency(growth_amount)),
            "rate_type": self._determine_rate_type(asset.growth_configs, year)
        }
    def _determine_rate_type(self, growth_configs: List[GrowthRateConfiguration], year: int) -> str:
        """Determines the type of applied growth rate."""
        for config in growth_configs:
            if config.configuration_type == 'STEPWISE' and config.start_year <= year <= (config.end_year or year):
                return 'STEPWISE'
            if config.configuration_type == 'OVERRIDE':
                return 'OVERRIDE'
        return 'DEFAULT'
```

######## backend/database_operations/calculations/base_facts/base_facts_calcs.py ########
```
# backend/database_operations/calculations/base_facts/base_facts_calculator.py
"""
## Annual Calculation Order
1. Start with prior year-end values  
2. Apply scheduled inflows (inflation-adjusted if enabled)  
3. Apply scheduled outflows (inflation-adjusted if enabled)  
4. Apply retirement income  
5. Apply retirement spending  
6. Apply asset growth using `GrowthRateHandler`:  
   - Asset-specific rates applied through `_apply_all_growth`  
   - Default rates applied if no asset-specific rate exists  
7. Apply liability interest  
8. Calculate year-end total  
## Value Display Principles
- All values shown in current dollars
- Inflation adjustments compound annually
- Growth is calculated exclusively via `GrowthRateHandler`  
- No partial year or day counting  
- No cash flow timing within year  
- All events occur at year boundaries  
- Portfolio values represent year-end totals  
## Growth Calculation Updates
- Growth calculations are now centralized in `GrowthRateHandler`  
- `_apply_all_growth` is the single method for applying growth to all assets  
- Liability interest remains separate but follows similar compound application  
"""
from dataclasses import dataclass
from decimal import Decimal
from typing import List, Dict, Optional
from ...models import Asset, Liability, InflowOutflow, RetirementIncomePlan, BaseAssumption
from ...utils.money_utils import to_decimal, apply_annual_compound_rate, apply_annual_inflation
from .growth_handler_calcs import GrowthRateHandler
@dataclass
class BaseFacts:
    """Stores base financial data for projections."""
    assets: List[Asset]
    liabilities: List[Liability]
    inflows_outflows: List[InflowOutflow]
    retirement_income: List[RetirementIncomePlan]
    base_assumptions: BaseAssumption
    start_year: int
    retirement_year: int
    end_year: int
@dataclass
class PortfolioValues:
    """Represents financial portfolio status."""
    asset_values: Dict[int, Decimal]
    liability_values: Dict[int, Decimal]
    asset_category_totals: Dict[str, Decimal]
    liability_category_totals: Dict[str, Decimal]
    retirement_portfolio_value: Decimal
    total_net_worth: Decimal
@dataclass
class CashFlowResults:
    """Tracks cash movements in a given year."""
    inflows: Dict[int, Decimal]
    outflows: Dict[int, Decimal]
    net_inflows: Decimal
    net_outflows: Decimal
    total_net_flow: Decimal
@dataclass
class IncomeResults:
    """Records annual retirement income."""
    income_streams: Dict[int, Decimal]
    total_income: Decimal
@dataclass
class YearlyCalculationResult:
    """Stores full results of an annual projection."""
    year: int
    starting_portfolio: PortfolioValues
    cash_flows: CashFlowResults
    income: IncomeResults
    ending_portfolio: PortfolioValues
    metadata: Dict
class BaseFactsCalculator:
    """Executes annual financial projections."""
    def __init__(self):
        self.growth_handler = GrowthRateHandler()
    def calculate_year(self, year: int, base_facts: BaseFacts,
                       prior_result: Optional[YearlyCalculationResult]) -> YearlyCalculationResult:
        """Computes portfolio projections for a given year."""
        starting_portfolio = self._carry_forward_values(prior_result) if prior_result else self._initialize_starting_values(base_facts)
        cash_flows = self.process_cash_flows(year, base_facts)
        income = self.process_retirement_income(year, base_facts)
        interim_portfolio = self._apply_flows_to_portfolio(starting_portfolio, cash_flows, income, base_facts)
        grown_portfolio = self._apply_all_growth(interim_portfolio, year, base_facts)
        final_portfolio = self.apply_liability_interest(grown_portfolio, base_facts)
        final_portfolio = self._update_portfolio_totals(final_portfolio, base_facts)
        return YearlyCalculationResult(
            year=year,
            starting_portfolio=starting_portfolio,
            cash_flows=cash_flows,
            income=income,
            ending_portfolio=final_portfolio,
            metadata=self._generate_calculation_metadata(year, final_portfolio, cash_flows)
        )
    def _apply_all_growth(self, portfolio: PortfolioValues, year: int, base_facts: BaseFacts) -> PortfolioValues:
        """Applies growth to all assets."""
        for asset in base_facts.assets:
            growth_result = self.growth_handler.apply_growth(
                portfolio.asset_values[asset.asset_id],
                asset.asset_id,
                year,
                to_decimal(base_facts.base_assumptions.default_growth_rate),
                asset.growth_rates
            )
            portfolio.asset_values[asset.asset_id] = growth_result.final_value
        return self._update_portfolio_totals(portfolio, base_facts)
    def apply_liability_interest(self, portfolio: PortfolioValues, base_facts: BaseFacts) -> PortfolioValues:
        """Applies interest to liabilities."""
        for liability in base_facts.liabilities:
            if liability.interest_rate:
                portfolio.liability_values[liability.liability_id] = apply_annual_compound_rate(
                    portfolio.liability_values[liability.liability_id], to_decimal(liability.interest_rate)
                )
        return self._update_portfolio_totals(portfolio, base_facts)
    def process_cash_flows(self, year: int, base_facts: BaseFacts) -> CashFlowResults:
        """Calculates cash inflows and outflows for a year."""
        inflows, outflows = {}, {}
        for flow in base_facts.inflows_outflows:
            if flow.start_year <= year <= (flow.end_year or flow.start_year):
                amount = to_decimal(flow.annual_amount)
                if flow.apply_inflation:
                    amount = apply_annual_inflation(amount, to_decimal(base_facts.base_assumptions.inflation_rate),
                                                    year - base_facts.start_year)
                (inflows if flow.type == 'inflow' else outflows)[flow.inflow_outflow_id] = amount
        return CashFlowResults(
            inflows=inflows,
            outflows=outflows,
            net_inflows=sum(inflows.values()),
            net_outflows=sum(outflows.values()),
            total_net_flow=sum(inflows.values()) - sum(outflows.values())
        )
    def process_retirement_income(self, year: int, base_facts: BaseFacts) -> IncomeResults:
        """Computes retirement income for a year."""
        if year < base_facts.retirement_year:
            return IncomeResults(income_streams={}, total_income=Decimal('0'))
        income_streams = {income.income_plan_id: to_decimal(income.annual_income) for income in base_facts.retirement_income
                          if self._is_income_active(income, year)}
        return IncomeResults(
            income_streams=income_streams,
            total_income=sum(income_streams.values())
        )
    def _update_portfolio_totals(self, portfolio: PortfolioValues, base_facts: BaseFacts) -> PortfolioValues:
        """Updates portfolio totals including net worth and category values."""
        portfolio.total_net_worth = sum(portfolio.asset_values.values()) - sum(portfolio.liability_values.values())
        portfolio.retirement_portfolio_value = sum(value for asset in base_facts.assets
                                                   if asset.include_in_nest_egg and (value := portfolio.asset_values[asset.asset_id]))
        portfolio.asset_category_totals = {asset.asset_category_id: sum(portfolio.asset_values[a.asset_id]
                                                                         for a in base_facts.assets
                                                                         if a.asset_category_id == asset.asset_category_id)
                                           for asset in base_facts.assets}
        portfolio.liability_category_totals = {liability.liability_category_id: sum(portfolio.liability_values[l.liability_id]
                                                                                    for l in base_facts.liabilities
                                                                                    if l.liability_category_id == liability.liability_category_id)
                                               for liability in base_facts.liabilities}
        return portfolio
    def _apply_flows_to_portfolio(self, portfolio: PortfolioValues, cash_flows: CashFlowResults, income: IncomeResults,
                                  base_facts: BaseFacts) -> PortfolioValues:
        """Adjusts portfolio for cash flow and income events."""
        portfolio.retirement_portfolio_value += sum(cash_flows.inflows.values()) - sum(cash_flows.outflows.values()) + income.total_income
        return self._update_portfolio_totals(portfolio, base_facts)
    def generate_projection(self, base_facts: BaseFacts) -> List[YearlyCalculationResult]:
        """Generates complete financial projection timeline."""
        self.validate_inputs(base_facts)
        results, prior_result = [], None
        for year in range(base_facts.start_year, base_facts.end_year + 1):
            result = self.calculate_year(year, base_facts, prior_result)
            results.append(result)
            prior_result = result
        return results
    def validate_inputs(self, base_facts: BaseFacts) -> None:
        """Ensures all financial inputs are valid."""
        if not base_facts.assets and not base_facts.liabilities:
            raise ValueError("At least one asset or liability is required.")
        if base_facts.start_year >= base_facts.retirement_year or base_facts.retirement_year >= base_facts.end_year:
            raise ValueError("Invalid timeline sequence.")
    def _is_income_active(self, income: RetirementIncomePlan, year: int) -> bool:
        """Checks if a retirement income stream is active in a given year."""
        return income.start_year <= year <= (income.end_year or income.start_year)
    def _generate_calculation_metadata(self, year: int, portfolio: PortfolioValues, flows: CashFlowResults) -> Dict:
        """Creates metadata about a given year's calculations."""
        return {
            "year": year,
            "total_inflows": flows.net_inflows,
            "total_outflows": flows.net_outflows,
            "ending_portfolio_value": portfolio.retirement_portfolio_value
        }
```

######## backend/database_operations/calculations/base_facts/cash_flows_calcs.py ########
```
"""
Handles calculations for discrete event cash flows.
Follows core principles:
- Annual periods only
- No intra-year calculations
- Optional inflation adjustment
"""
from dataclasses import dataclass
from decimal import Decimal
from typing import List, Dict, Optional
from enum import Enum
from ...utils.money_utils import to_decimal, apply_annual_inflation
class FlowType(Enum):
    """Represents cash flow types."""
    INFLOW = 'inflow'
    OUTFLOW = 'outflow'
@dataclass
class CashFlowFact:
    """Defines a discrete cash flow event."""
    flow_id: int
    name: str
    flow_type: FlowType
    annual_amount: Decimal
    start_year: int
    end_year: int
    apply_inflation: bool
    owner: str
@dataclass
class CashFlowCalculationResult:
    """Stores results of cash flow calculations."""
    flow_id: int
    flow_name: str
    flow_type: FlowType
    base_amount: Decimal
    adjusted_amount: Decimal
    is_active: bool
    metadata: Dict
@dataclass
class AggregatedFlows:
    """Aggregates inflows and outflows, including inflation-adjusted values."""
    total_inflows: Decimal
    total_outflows: Decimal
    inflation_adjusted_inflows: Decimal
    inflation_adjusted_outflows: Decimal
    net_flow: Decimal
class CashFlowCalculator:
    """Handles cash flow calculations and aggregation."""
    def calculate_flow_amount(self, flow: CashFlowFact, year: int,
                              inflation_rate: Decimal, plan_start_year: int) -> CashFlowCalculationResult:
        """Computes cash flow for a given year."""
        is_active = flow.start_year <= year <= flow.end_year
        base_amount = flow.annual_amount if is_active else Decimal('0')
        adjusted_amount = apply_annual_inflation(base_amount, inflation_rate, year - plan_start_year) \
            if is_active and flow.apply_inflation else base_amount
        return CashFlowCalculationResult(
            flow_id=flow.flow_id,
            flow_name=flow.name,
            flow_type=flow.flow_type,
            base_amount=base_amount,
            adjusted_amount=adjusted_amount,
            is_active=is_active,
            metadata=self._generate_metadata(flow, year)
        )
    def calculate_multiple_flows(self, flows: List[CashFlowFact], year: int,
                                 inflation_rate: Decimal, plan_start_year: int) -> List[CashFlowCalculationResult]:
        """Computes cash flows for multiple events."""
        return [self.calculate_flow_amount(flow, year, inflation_rate, plan_start_year) for flow in flows]
    def aggregate_flows(self, results: List[CashFlowCalculationResult]) -> AggregatedFlows:
        """Aggregates inflows, outflows, and net cash flow."""
        inflows, outflows, adj_inflows, adj_outflows = Decimal('0'), Decimal('0'), Decimal('0'), Decimal('0')
        for result in results:
            if result.is_active:
                if result.flow_type == FlowType.INFLOW:
                    inflows += result.base_amount
                    adj_inflows += result.adjusted_amount
                else:
                    outflows += result.base_amount
                    adj_outflows += result.adjusted_amount
        return AggregatedFlows(
            total_inflows=inflows,
            total_outflows=outflows,
            inflation_adjusted_inflows=adj_inflows,
            inflation_adjusted_outflows=adj_outflows,
            net_flow=adj_inflows - adj_outflows
        )
    def validate_cash_flows(self, flows: List[CashFlowFact]) -> None:
        """Ensures all cash flows have valid amounts and timelines."""
        for flow in flows:
            if flow.annual_amount <= 0:
                raise ValueError(f"Cash flow {flow.flow_id} has invalid amount.")
            if flow.start_year > flow.end_year:
                raise ValueError(f"Cash flow {flow.flow_id} has an invalid year sequence.")
    def calculate_total_flow_amount(self, annual_amount: Decimal, start_year: int, end_year: Optional[int],
                                    inflation_rate: Optional[Decimal] = None, apply_inflation: bool = False) -> Decimal:
        """Computes total cash flow over a period, optionally applying inflation."""
        duration = (end_year or start_year) - start_year + 1
        if not apply_inflation or not inflation_rate:
            return annual_amount * duration
        return sum(apply_annual_inflation(annual_amount, inflation_rate, year) for year in range(duration))
    def calculate_total_inflation_impact(self, results: List[CashFlowCalculationResult]) -> Dict[FlowType, Decimal]:
        """Computes the total impact of inflation on cash flows."""
        impact = {FlowType.INFLOW: Decimal('0'), FlowType.OUTFLOW: Decimal('0')}
        for result in results:
            if result.is_active:
                impact[result.flow_type] += result.adjusted_amount - result.base_amount
        return impact
    def _generate_metadata(self, flow: CashFlowFact, year: int) -> Dict:
        """Creates metadata for a cash flow calculation."""
        return {
            "flow_name": flow.name,
            "flow_type": flow.flow_type.value,
            "owner": flow.owner,
            "year": year,
            "is_single_year": flow.start_year == flow.end_year
        }
```

######## backend/database_operations/calculations/base_facts/growth_handler_calcs.py ########
```
# backend/database_operations/calculations/base_facts/growth_handler.py
"""
Moved from the prior assets_helpers.py file to this file.
"""
"""
## Assets
- Growth handling:  
  1. Default: Uses base assumption growth rate  
  2. Override: Asset-specific fixed rate  
  3. Stepwise: Multiple rates over time periods
  4. Gaps in stepwise fall to default
- Optional inflation toggle
## Growth Rate System
- Assets can have default, fixed, or stepwise growth rates
- Stepwise: Multiple rates over time periods
- Gaps in stepwise fall to default
"""
from decimal import Decimal
from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass
from ...models import GrowthRateConfiguration
from ...utils.money_utils import to_decimal, apply_annual_compound_rate
from ...validation.money_validation import validate_rate
@dataclass
class GrowthResult:
    """Stores growth calculation results."""
    final_value: Decimal
    growth_amount: Decimal
    applied_rate: Decimal
    rate_source: str  # 'default', 'override', or 'stepwise'
    period_start: Optional[int] = None
    period_end: Optional[int] = None
class GrowthRateHandler:
    """Handles asset growth rate calculations."""
    def apply_growth(self, value: Decimal, year: int, default_rate: Decimal,
                     growth_configs: List[GrowthRateConfiguration]) -> GrowthResult:
        """Applies growth to a value based on the highest priority rate."""
        rate, source, period = self._get_applicable_rate(growth_configs, year, default_rate)
        final_value = apply_annual_compound_rate(value, rate)
        return GrowthResult(
            final_value=final_value,
            growth_amount=final_value - value,
            applied_rate=rate,
            rate_source=source,
            period_start=period[0] if period else None,
            period_end=period[1] if period else None
        )
    def _get_applicable_rate(self, configs: List[GrowthRateConfiguration], year: int,
                             default_rate: Decimal) -> Tuple[Decimal, str, Optional[Tuple[int, int]]]:
        """Determines the highest priority growth rate."""
        for config in sorted(configs, key=lambda c: (c.configuration_type != 'STEPWISE', c.start_year)):
            if config.start_year <= year and (config.end_year is None or config.end_year >= year):
                return to_decimal(config.growth_rate), config.configuration_type.lower(), (
                    config.start_year, config.end_year) if config.configuration_type == 'STEPWISE' else None
        return default_rate, 'default', None
    def validate_stepwise_configurations(self, configs: List[GrowthRateConfiguration]) -> None:
        """Ensures stepwise growth configurations do not overlap."""
        stepwise_configs = sorted([c for c in configs if c.configuration_type == 'STEPWISE'], key=lambda x: x.start_year)
        for i in range(len(stepwise_configs) - 1):
            if stepwise_configs[i].end_year and stepwise_configs[i].end_year >= stepwise_configs[i + 1].start_year:
                raise ValueError(f"Overlapping growth periods: {stepwise_configs[i].start_year}-{stepwise_configs[i].end_year} "
                                 f"and {stepwise_configs[i + 1].start_year}-{stepwise_configs[i + 1].end_year}")
            validate_rate(stepwise_configs[i].growth_rate)
```

######## backend/database_operations/calculations/base_facts/liabilities_calcs.py ########
```
"""
Liability calculation module.
Unlike assets which use a complex growth rate system, liabilities use a simple interest model.
Key differences:
- No default growth rate usage
- Optional simple interest rate
- Fixed value if no rate specified
"""
from decimal import Decimal
from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass
from ...utils.money_utils import to_decimal, apply_annual_compound_rate
from ...utils.time_utils import validate_year_not_before_plan_creation
@dataclass
class LiabilityFact:
    """Stores liability details for calculations."""
    liability_id: int
    value: Decimal
    interest_rate: Optional[Decimal]
    category_id: int
    include_in_nest_egg: bool
    plan_creation_year: Optional[int]
@dataclass
class LiabilityCalculationResult:
    """Stores liability calculation results."""
    liability_id: int
    starting_value: Decimal
    ending_value: Decimal
    interest_amount: Decimal
    category_id: int
    has_interest: bool
    metadata: Dict
class LiabilityCalculator:
    """Performs liability calculations using a simple interest model."""
    @staticmethod
    def calculate_liability_value(liability: LiabilityFact, year: int) -> LiabilityCalculationResult:
        """Computes liability value for a given year."""
        if liability.plan_creation_year:
            validate_year_not_before_plan_creation(year, liability.plan_creation_year)
        starting_value = liability.value
        ending_value, interest_amount = LiabilityCalculator.apply_interest(starting_value, liability.interest_rate)
        return LiabilityCalculationResult(
            liability_id=liability.liability_id,
            starting_value=starting_value,
            ending_value=ending_value,
            interest_amount=interest_amount,
            category_id=liability.category_id,
            has_interest=liability.interest_rate is not None,
            metadata=LiabilityCalculator.generate_metadata(liability, year, starting_value, ending_value)
        )
    @staticmethod
    def calculate_multiple_liabilities(liabilities: List[LiabilityFact], year: int) -> List[LiabilityCalculationResult]:
        """Computes liability values for multiple liabilities."""
        return [LiabilityCalculator.calculate_liability_value(liability, year) for liability in liabilities]
    @staticmethod
    def aggregate_by_category(results: List[LiabilityCalculationResult]) -> Dict[int, Decimal]:
        """Sums liabilities by category."""
        totals = {}
        for result in results:
            totals[result.category_id] = totals.get(result.category_id, Decimal('0')) + result.ending_value
        return totals
    @staticmethod
    def calculate_nest_egg_total(results: List[LiabilityCalculationResult]) -> Decimal:
        """Computes total liabilities marked as included in the nest egg."""
        return sum(result.ending_value for result in results if result.include_in_nest_egg)
    @staticmethod
    def apply_interest(value: Decimal, rate: Optional[Decimal]) -> Tuple[Decimal, Decimal]:
        """Applies simple interest for one period."""
        if rate is None:
            return value, Decimal('0')
        ending_value = apply_annual_compound_rate(value, rate)
        return ending_value, ending_value - value
    @staticmethod
    def calculate_weighted_average_rate(liabilities: List[Tuple[Decimal, Optional[Decimal]]]) -> Optional[Decimal]:
        """Computes weighted average interest rate across liabilities."""
        total_value = sum(value for value, rate in liabilities if rate)
        weighted_sum = sum(value * rate for value, rate in liabilities if rate)
        return weighted_sum / total_value if total_value else None
    @staticmethod
    def project_liability_value(current_value: Decimal, interest_rate: Optional[Decimal], years: int) -> Decimal:
        """Projects liability value over a number of years."""
        return apply_annual_compound_rate(current_value, interest_rate, years) if interest_rate else current_value
    @staticmethod
    def validate_liability_values(liabilities: List[Tuple[int, Decimal]]) -> None:
        """Ensures all liabilities have positive values."""
        for lid, value in liabilities:
            if value <= 0:
                raise ValueError(f"Liability {lid} has invalid value: {value}")
    @staticmethod
    def calculate_total_interest(results: List[Tuple[Decimal, Decimal]]) -> Decimal:
        """Computes total interest across all liabilities."""
        return sum(ending - starting for starting, ending in results)
    @staticmethod
    def identify_fixed_value_liabilities(liabilities: List[Tuple[int, Optional[Decimal]]]) -> List[int]:
        """Identifies liabilities with no interest rate."""
        return [lid for lid, rate in liabilities if rate is None]
    @staticmethod
    def identify_high_interest_liabilities(liabilities: List[Tuple[int, Optional[Decimal]]], threshold: Decimal) -> List[int]:
        """Identifies liabilities with interest rates exceeding a threshold."""
        return [lid for lid, rate in liabilities if rate and rate > threshold]
    @staticmethod
    def generate_metadata(liability: LiabilityFact, year: int, start_value: Decimal, end_value: Decimal) -> Dict:
        """Creates metadata for liability calculations."""
        return {
            "liability_id": liability.liability_id,
            "year": year,
            "starting_value": str(start_value),
            "ending_value": str(end_value),
            "interest_amount": str(end_value - start_value),
            "has_interest": liability.interest_rate is not None,
            "interest_rate": str(liability.interest_rate) if liability.interest_rate else None,
            "is_fixed_value": liability.interest_rate is None,
            "plan_creation_year": liability.plan_creation_year
        }
```

######## backend/database_operations/calculations/base_facts/retirement_income_calcs.py ########
```
"""
## Retirement Income
- Start year, end year
- Amount
- Optional inflation toggle
- Input in absolute years (derived dynamically from selected person's retirement age)
- For SS/Pension/Deferred Comp, etc.
- Separate from scheduled inflows
## Time Handling Principles
- DOB is the only true date input
- All calculations reference absolute years internally
- Conversion rules:
  - Years ↔ Age: Derived dynamically from DOB when needed
  - Store values as entered and convert as needed
## Value Display Principles
- Inflation adjustments compound annually
- No partial year or day counting
- All events assumed to occur at year boundaries
1. Proper age-based activation of income streams
2. Support for lifetime income (no end age)
3. Optional inflation adjustments
4. Clear separation from scheduled inflows
5. Proper handling of DOB for age calculations
6. Utilities for analyzing income streams by type
""" 
from dataclasses import dataclass
from decimal import Decimal
from typing import List, Dict, Optional
from datetime import date
from ...utils.money_utils import to_decimal, apply_annual_inflation
from ...utils.time_utils import get_age_at_year
@dataclass
class RetirementIncomeFact:
    """Represents a retirement income stream."""
    income_id: int
    name: str
    owner: str
    annual_income: Decimal
    start_age: int
    end_age: Optional[int]
    include_in_nest_egg: bool
    apply_inflation: bool
    dob: date
@dataclass
class IncomeCalculationResult:
    """Stores results of income calculations."""
    income_id: int
    income_name: str
    base_amount: Decimal
    adjusted_amount: Decimal
    inflation_adjustment: Decimal
    is_active: bool
    included_in_nest_egg: bool
    metadata: Dict
class RetirementIncomeCalculator:
    """Handles retirement income calculations."""
    def calculate_income_amount(self, income: RetirementIncomeFact, year: int,
                                inflation_rate: Decimal, plan_start_year: int) -> IncomeCalculationResult:
        """Calculates income for a given year."""
        current_age = get_age_at_year(income.dob, year)
        is_active = self._is_income_active(income, current_age)
        if not is_active:
            return IncomeCalculationResult(
                income_id=income.income_id,
                income_name=income.name,
                base_amount=income.annual_income,
                adjusted_amount=Decimal('0'),
                inflation_adjustment=Decimal('0'),
                is_active=False,
                included_in_nest_egg=income.include_in_nest_egg,
                metadata=self._generate_metadata(income, year, current_age, Decimal('0'))
            )
        base_amount = income.annual_income
        inflation_adjustment = apply_annual_inflation(base_amount, inflation_rate, year - plan_start_year) - base_amount
        adjusted_amount = base_amount + inflation_adjustment if income.apply_inflation else base_amount
        return IncomeCalculationResult(
            income_id=income.income_id,
            income_name=income.name,
            base_amount=base_amount,
            adjusted_amount=adjusted_amount,
            inflation_adjustment=inflation_adjustment,
            is_active=True,
            included_in_nest_egg=income.include_in_nest_egg,
            metadata=self._generate_metadata(income, year, current_age, inflation_adjustment)
        )
    def calculate_multiple_income_streams(self, income_streams: List[RetirementIncomeFact], year: int,
                                          inflation_rate: Decimal, plan_start_year: int) -> List[IncomeCalculationResult]:
        """Calculates income for multiple streams."""
        return [self.calculate_income_amount(income, year, inflation_rate, plan_start_year) for income in income_streams]
    def aggregate_by_source(self, results: List[IncomeCalculationResult]) -> Dict[str, Decimal]:
        """Totals income by source."""
        totals = {}
        for result in results:
            if result.is_active:
                totals[result.income_name] = totals.get(result.income_name, Decimal('0')) + result.adjusted_amount
        return totals
    def calculate_total_income(self, results: List[IncomeCalculationResult], nest_egg_only: bool = False) -> Decimal:
        """Calculates total income."""
        return sum(r.adjusted_amount for r in results if r.is_active and (not nest_egg_only or r.included_in_nest_egg))
    def calculate_total_inflation_impact(self, results: List[IncomeCalculationResult]) -> Decimal:
        """Calculates total inflation impact."""
        return sum(r.inflation_adjustment for r in results if r.is_active)
    def _is_income_active(self, income: RetirementIncomeFact, current_age: int) -> bool:
        """Checks if income is active for the given age."""
        return income.start_age <= current_age <= (income.end_age or 100)
    def _generate_metadata(self, income: RetirementIncomeFact, year: int, current_age: int,
                           inflation_adjustment: Decimal) -> Dict:
        """Creates metadata for income calculations."""
        return {
            "income_name": income.name,
            "owner": income.owner,
            "year": year,
            "current_age": current_age,
            "inflation_enabled": income.apply_inflation,
            "inflation_adjustment": str(inflation_adjustment),
            "start_age": income.start_age,
            "end_age": income.end_age or "Lifetime",
            "is_lifetime_income": income.end_age is None
        }
    def validate_retirement_income_facts(self, income_streams: List[RetirementIncomeFact]) -> None:
        """Validates income streams before calculation."""
        for income in income_streams:
            if income.annual_income <= 0:
                raise ValueError(f"Income stream {income.income_id} has invalid amount")
            if income.end_age is not None and income.start_age > income.end_age:
                raise ValueError(f"Income stream {income.income_id} has invalid age sequence")
    def get_lifetime_income_streams(self, results: List[IncomeCalculationResult]) -> List[IncomeCalculationResult]:
        """Returns lifetime income streams."""
        return [r for r in results if r.metadata["is_lifetime_income"]]
    def get_fixed_term_income_streams(self, results: List[IncomeCalculationResult]) -> List[IncomeCalculationResult]:
        """Returns fixed-term income streams."""
        return [r for r in results if not r.metadata["is_lifetime_income"]]
```

######## backend/database_operations/calculations/base_facts/__init__.py ########
```

```

######## backend/database_operations/crud/base_assumptions_crud.py ########
```
# backend/database_operations/crud/base_assumptions_crud.py
"""
Full CRUD operations for base assumptions following SQLAlchemy 2.0 style
Comprehensive validation:
Retirement and final ages within bounds
Valid age sequences for both people
Growth and inflation rates
Final age selector logic
Dynamic year calculations based on DOB and ages
Proper error handling and transaction management
Support for optional person 2 data
Validation against household data through plan relationship
Utility method for getting absolute year mappings
"""
from datetime import datetime
from typing import Optional, Dict, Any
from decimal import Decimal
from sqlalchemy import select, update, delete
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError, NoResultFound
from ..models import BaseAssumption, Plan
from ..validation.time_validation import (
    validate_positive_age,
    validate_age_sequence,
    validate_year_not_before_plan_creation
)
from ..utils.time_utils import get_age_in_year
from ..validation.money_validation import validate_rate
from ..utils.time_utils import get_start_year, get_retirement_year, get_final_projection_year
class BaseAssumptionCRUD:
    """CRUD operations for plan base assumptions."""
    def __init__(self, session: Session):
        self.session = session
    def create_base_assumptions(
        self,
        plan_id: int,
        retirement_age_1: int,
        final_age_1: int,
        default_growth_rate: float,
        inflation_rate: float,
        retirement_age_2: Optional[int] = None,
        final_age_2: Optional[int] = None,
        final_age_selector: int = 1,
    ) -> BaseAssumption:
        """
        Create base assumptions for a plan.
        Args:
            plan_id: ID of plan these assumptions belong to
            retirement_age_1: Retirement age for person 1
            final_age_1: Final age (life expectancy) for person 1
            default_growth_rate: Default annual growth rate for assets
            inflation_rate: Annual inflation rate
            retirement_age_2: Optional retirement age for person 2
            final_age_2: Optional final age for person 2
            final_age_selector: Which person's final age to use (1 or 2)
        Returns:
            Newly created BaseAssumption instance
        Raises:
            ValueError: If validation fails
            NoResultFound: If plan_id doesn't exist
            IntegrityError: If database constraint violated
        """
        # Verify plan exists
        stmt = select(Plan).where(Plan.plan_id == plan_id)
        plan = self.session.execute(stmt).scalar_one_or_none()
        if not plan:
            raise NoResultFound(f"Plan {plan_id} not found")
        # Validate retirement and final ages for person 1
        if not validate_positive_age(retirement_age_1):
            raise ValueError("Invalid retirement age for person 1")
        if not validate_positive_age(final_age_1):
            raise ValueError("Invalid final age for person 1")
        current_age = get_age_in_year(plan.household.person1_dob, datetime.now().year)
        if not validate_age_sequence(current_age, retirement_age_1, final_age_1):
            raise ValueError("Invalid age sequence for person 1")
        # Validate person 2 ages if provided
        if retirement_age_2 is not None:
            if not validate_positive_age(retirement_age_2):
                raise ValueError("Invalid retirement age for person 2")
            if final_age_2 is not None:
                if not validate_positive_age(final_age_2):
                    raise ValueError("Invalid final age for person 2")
                current_age_2 = get_age_in_year(plan.household.person2_dob, datetime.now().year)
                if not validate_age_sequence(current_age_2, retirement_age_2, final_age_2):
                    raise ValueError("Invalid age sequence for person 2")
        # Validate rates
        validate_rate(default_growth_rate, "default_growth_rate")
        validate_rate(inflation_rate, "inflation_rate")
        # Validate final age selector
        if final_age_selector not in [1, 2]:
            raise ValueError("final_age_selector must be 1 or 2")
        if final_age_selector == 2 and final_age_2 is None:
            raise ValueError("Cannot select person 2's final age when it's not provided")
        # Create base assumptions instance
        base_assumptions = BaseAssumption(
            plan_id=plan_id,
            retirement_age_1=retirement_age_1,
            retirement_age_2=retirement_age_2,
            final_age_1=final_age_1,
            final_age_2=final_age_2,
            final_age_selector=final_age_selector,
            default_growth_rate=default_growth_rate,
            inflation_rate=inflation_rate
        )
        try:
            self.session.add(base_assumptions)
            self.session.commit()
            return base_assumptions
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to create base assumptions", orig=e)
    def get_base_assumptions(self, plan_id: int) -> Optional[BaseAssumption]:
        """
        Retrieve base assumptions for a plan.
        Args:
            plan_id: ID of plan to get assumptions for
        Returns:
            BaseAssumption instance if found, None otherwise
        """
        stmt = select(BaseAssumption).where(BaseAssumption.plan_id == plan_id)
        return self.session.execute(stmt).scalar_one_or_none()
    def update_base_assumptions(
        self,
        plan_id: int,
        update_data: Dict[str, Any]
    ) -> Optional[BaseAssumption]:
        """
        Update base assumptions.
        Args:
            plan_id: ID of plan whose assumptions to update
            update_data: Dictionary of fields to update and their new values
        Returns:
            Updated BaseAssumption instance if found, None otherwise
        Raises:
            ValueError: If validation fails
            IntegrityError: If database constraint violated
        """
        # Get current assumptions and plan for validation
        stmt = select(BaseAssumption, Plan).join(Plan).where(BaseAssumption.plan_id == plan_id)
        result = self.session.execute(stmt).first()
        if not result:
            return None
        current_assumptions, plan = result
        # Validate rates if provided
        if 'default_growth_rate' in update_data:
            validate_rate(update_data['default_growth_rate'], "default_growth_rate")
        if 'inflation_rate' in update_data:
            validate_rate(update_data['inflation_rate'], "inflation_rate")
        # Validate ages if provided
        retirement_age_1 = update_data.get('retirement_age_1', current_assumptions.retirement_age_1)
        final_age_1 = update_data.get('final_age_1', current_assumptions.final_age_1)
        retirement_age_2 = update_data.get('retirement_age_2', current_assumptions.retirement_age_2)
        final_age_2 = update_data.get('final_age_2', current_assumptions.final_age_2)
        if 'retirement_age_1' in update_data or 'final_age_1' in update_data:
            if not validate_age_sequence(plan.household.person1_dob.year, retirement_age_1, final_age_1):
                raise ValueError("Invalid age sequence for person 1")
        if (retirement_age_2 is not None and 
            ('retirement_age_2' in update_data or 'final_age_2' in update_data)):
            if not validate_age_sequence(plan.household.person2_dob.year, retirement_age_2, final_age_2):
                raise ValueError("Invalid age sequence for person 2")
        try:
            # Perform the update
            stmt = (
                update(BaseAssumption)
                .where(BaseAssumption.plan_id == plan_id)
                .values(**update_data)
                .returning(BaseAssumption)
            )
            result = self.session.execute(stmt)
            self.session.commit()
            return result.scalar_one()
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to update base assumptions", orig=e)
    def delete_base_assumptions(self, plan_id: int) -> bool:
        """
        Delete base assumptions for a plan.
        Args:
            plan_id: ID of plan whose assumptions to delete
        Returns:
            True if assumptions were deleted, False if not found
        """
        stmt = delete(BaseAssumption).where(BaseAssumption.plan_id == plan_id)
        result = self.session.execute(stmt)
        self.session.commit()
        return result.rowcount > 0
    def get_year_mappings(self, plan_id: int) -> Dict[str, int]:
        """
        Get absolute year mappings for key plan dates.
        Args:
            plan_id: ID of plan to get mappings for
        Returns:
            Dictionary containing start_year, retirement_year, and end_year
        Raises:
            NoResultFound: If plan or assumptions not found
        """
        stmt = (
            select(BaseAssumption, Plan)
            .join(Plan)
            .where(BaseAssumption.plan_id == plan_id)
        )
        result = self.session.execute(stmt).first()
        if not result:
            raise NoResultFound(f"Base assumptions not found for plan {plan_id}")
        assumptions, plan = result
        # Determine which DOB to use based on final_age_selector
        if assumptions.final_age_selector == 1:
            dob = plan.household.person1_dob
            retirement_age = assumptions.retirement_age_1
            final_age = assumptions.final_age_1
        else:
            dob = plan.household.person2_dob
            retirement_age = assumptions.retirement_age_2
            final_age = assumptions.final_age_2
        # Calculate years using new utility functions
        start_year = get_start_year(plan.plan_creation_year)
        retirement_year = get_retirement_year(dob, retirement_age)
        end_year = get_final_projection_year(dob, final_age)
        return {
            'start_year': start_year,
            'retirement_year': retirement_year,
            'end_year': end_year
        }
```

######## backend/database_operations/crud/households_crud.py ########
```
# backend/database_operations/crud/households.py
"""
Full CRUD operations following SQLAlchemy 2.0 style
Proper validation of DOBs as required by core logic
Handles both required Person 1 and optional Person 2 data
Maintains created_at and updated_at timestamps
Cascade deletion of related plans (through SQLAlchemy relationship)
Proper error handling and transaction management
Additional utility method for household summary including plan count
"""
from datetime import date, datetime
from typing import List, Optional, Dict, Any
from sqlalchemy import select, update, delete
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
from ..models import Household
from ..validation.time_validation import validate_dob
class HouseholdCRUD:
    """Handles CRUD operations for households."""
    def __init__(self, session: Session):
        self.session = session
    def create_household(self, household_name: str, person1_first_name: str, person1_last_name: str, person1_dob: date,
                         person2_first_name: Optional[str] = None, person2_last_name: Optional[str] = None, person2_dob: Optional[date] = None) -> Household:
        """Creates a household with up to two members."""
        if not validate_dob(person1_dob):
            raise ValueError("Invalid date of birth for person 1")
        if person2_dob and not validate_dob(person2_dob):
            raise ValueError("Invalid date of birth for person 2")
        household = Household(
            household_name=household_name, person1_first_name=person1_first_name, person1_last_name=person1_last_name,
            person1_dob=person1_dob, person2_first_name=person2_first_name, person2_last_name=person2_last_name, person2_dob=person2_dob
        )
        try:
            self.session.add(household)
            self.session.commit()
            return household
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to create household", orig=e)
    def get_household(self, household_id: int) -> Optional[Household]:
        """Retrieves a household by ID."""
        return self.session.execute(select(Household).where(Household.household_id == household_id)).scalar_one_or_none()
    def get_all_households(self) -> List[Household]:
        """Returns all households."""
        return list(self.session.execute(select(Household)).scalars().all())
    def update_household(self, household_id: int, update_data: Dict[str, Any]) -> Optional[Household]:
        """Updates a household's information."""
        if 'person1_dob' in update_data and not validate_dob(update_data['person1_dob']):
            raise ValueError("Invalid date of birth for person 1")
        if 'person2_dob' in update_data and update_data['person2_dob'] and not validate_dob(update_data['person2_dob']):
            raise ValueError("Invalid date of birth for person 2")
        try:
            update_data['updated_at'] = datetime.now()
            result = self.session.execute(
                update(Household).where(Household.household_id == household_id).values(**update_data).returning(Household)
            )
            self.session.commit()
            return result.scalar_one_or_none()
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to update household", orig=e)
    def delete_household(self, household_id: int) -> bool:
        """Deletes a household by ID."""
        result = self.session.execute(delete(Household).where(Household.household_id == household_id))
        self.session.commit()
        return result.rowcount > 0
    def get_household_summary(self, household_id: int) -> Optional[Dict[str, Any]]:
        """Returns a summary of a household, including plan count."""
        household = self.get_household(household_id)
        if not household:
            return None
        return {
            'household_id': household.household_id,
            'household_name': household.household_name,
            'person1_name': f"{household.person1_first_name} {household.person1_last_name}",
            'person2_name': f"{household.person2_first_name} {household.person2_last_name}" if household.person2_first_name else None,
            'plan_count': len(household.plans),
            'created_at': household.created_at,
            'updated_at': household.updated_at
        }
```

######## backend/database_operations/crud/plans_crud.py ########
```
# backend/database_operations/crud/plans.py
"""
Full CRUD operations for plans following SQLAlchemy 2.0 style
Optional eager loading of relationships for detailed queries
Household existence verification on plan creation
Comprehensive plan summary including related entity counts
Timeline validation based on core logic requirements
Proper error handling and transaction management
Maintains created_at and updated_at timestamps
Cascade deletion handled through SQLAlchemy relationships
"""
from datetime import datetime
from typing import List, Optional, Dict, Any
from sqlalchemy import select, update, delete
from sqlalchemy.orm import Session, joinedload
from sqlalchemy.exc import IntegrityError, NoResultFound
from ..models import Plan, Household, BaseAssumption
from ..validation.scenario_timeline_validation import validate_projection_timeline
class PlanCRUD:
    """Handles CRUD operations for financial plans."""
    def __init__(self, session: Session):
        self.session = session
    def create_plan(self, household_id: int, plan_name: str) -> Plan:
        """Creates a financial plan for a household."""
        if not self.session.execute(select(Household).where(Household.household_id == household_id)).scalar_one_or_none():
            raise NoResultFound(f"Household {household_id} not found")
        plan = Plan(
            household_id=household_id, 
            plan_name=plan_name,
            plan_creation_year=datetime.now().year
        )
        try:
            self.session.add(plan)
            self.session.commit()
            return plan
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to create plan", orig=e)
    def get_plan(self, plan_id: int, include_relationships: bool = False) -> Optional[Plan]:
        """Retrieves a plan by ID, optionally loading related data."""
        stmt = select(Plan).where(Plan.plan_id == plan_id)
        if include_relationships:
            stmt = stmt.options(
                joinedload(Plan.base_assumptions), joinedload(Plan.scenarios),
                joinedload(Plan.asset_categories), joinedload(Plan.liability_categories),
                joinedload(Plan.assets), joinedload(Plan.liabilities),
                joinedload(Plan.inflows_outflows), joinedload(Plan.retirement_income_plans)
            )
        return self.session.execute(stmt).scalar_one_or_none()
    def get_household_plans(self, household_id: int) -> List[Plan]:
        """Returns all plans for a household."""
        return list(self.session.execute(select(Plan).where(Plan.household_id == household_id)).scalars().all())
    def update_plan(self, plan_id: int, update_data: Dict[str, Any]) -> Optional[Plan]:
        """Updates a financial plan."""
        try:
            update_data['updated_at'] = datetime.now()
            result = self.session.execute(
                update(Plan).where(Plan.plan_id == plan_id).values(**update_data).returning(Plan)
            )
            self.session.commit()
            return result.scalar_one_or_none()
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to update plan", orig=e)
    def delete_plan(self, plan_id: int) -> bool:
        """Deletes a plan by ID."""
        result = self.session.execute(delete(Plan).where(Plan.plan_id == plan_id))
        self.session.commit()
        return result.rowcount > 0
    def get_plan_summary(self, plan_id: int) -> Optional[Dict[str, Any]]:
        """Returns a summary of a plan including related entity counts."""
        plan = self.get_plan(plan_id, include_relationships=True)
        if not plan:
            return None
        return {
            'plan_id': plan.plan_id,
            'plan_name': plan.plan_name,
            'household_id': plan.household_id,
            'scenario_count': len(plan.scenarios),
            'asset_count': len(plan.assets),
            'liability_count': len(plan.liabilities),
            'cash_flow_count': len(plan.inflows_outflows),
            'retirement_income_count': len(plan.retirement_income_plans),
            'has_base_assumptions': plan.base_assumptions is not None,
            'created_at': plan.created_at,
            'updated_at': plan.updated_at
        }
    def validate_plan_timeline(self, plan_id: int) -> bool:
        """Validates if a plan's timeline is logically consistent."""
        plan = self.get_plan(plan_id)
        if not plan or not plan.base_assumptions:
            return False
        start_year = datetime.now().year
        return validate_projection_timeline(
            start_year, plan.base_assumptions.retirement_age_1, plan.base_assumptions.final_age_1
        )
```

######## backend/database_operations/crud/scenarios_crud.py ########
```
from datetime import datetime
from typing import List, Optional, Dict, Any
from sqlalchemy import select, update, delete
from sqlalchemy.orm import Session, joinedload
from sqlalchemy.exc import IntegrityError, NoResultFound
from ..models import Scenario, ScenarioAssumption, ScenarioOverride, Plan
from ..validation.money_validation import validate_positive_amount, validate_rate
from ..validation.time_validation import validate_year_range, validate_year_not_before_plan_creation
class ScenarioCRUD:
    """Handles CRUD operations for scenarios."""
    def __init__(self, session: Session):
        self.session = session
    def create_scenario(self, plan_id: int, scenario_name: str, scenario_color: Optional[str] = None,
                        assumptions: Optional[Dict[str, Any]] = None) -> Scenario:
        """Creates a scenario for a given plan."""
        # Get plan with base assumptions
        plan = self.session.execute(
            select(Plan)
            .options(joinedload(Plan.base_assumptions))
            .where(Plan.plan_id == plan_id)
        ).scalar_one_or_none()
        if not plan:
            raise NoResultFound(f"Plan {plan_id} not found")
        scenario = Scenario(plan_id=plan_id, scenario_name=scenario_name, scenario_color=scenario_color)
        try:
            self.session.add(scenario)
            self.session.flush()  # Get scenario_id
            # Clone base assumptions and merge with any provided overrides
            base_assumption_values = {}
            if plan.base_assumptions:
                base_assumption_values = {
                    'retirement_age_1': plan.base_assumptions.retirement_age_1,
                    'retirement_age_2': plan.base_assumptions.retirement_age_2,
                    'default_growth_rate': plan.base_assumptions.default_growth_rate,
                    'inflation_rate': plan.base_assumptions.inflation_rate
                }
            # Merge with provided assumptions
            if assumptions:
                base_assumption_values.update(assumptions)
            # Validate rates
            if 'default_growth_rate' in base_assumption_values:
                validate_rate(base_assumption_values['default_growth_rate'], "default_growth_rate")
            if 'inflation_rate' in base_assumption_values:
                validate_rate(base_assumption_values['inflation_rate'], "inflation_rate")
            if 'annual_retirement_spending' in base_assumption_values:
                validate_positive_amount(base_assumption_values['annual_retirement_spending'], "annual_retirement_spending")
            # Create scenario assumptions
            self.session.add(ScenarioAssumption(
                scenario_id=scenario.scenario_id,
                **base_assumption_values
            ))
            self.session.commit()
            return scenario
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to create scenario", orig=e)
    def add_overrides(self, scenario_id: int, overrides: List[Dict[str, Any]]) -> List[ScenarioOverride]:
        """
        Bulk adds overrides for a scenario.
        overrides = [
            {
                'asset_id': 1,  # Optional - one of asset_id/liability_id/etc must be set
                'liability_id': None,
                'inflow_outflow_id': None,
                'retirement_income_plan_id': None,
                'override_field': 'value',  # What's being changed
                'override_value': '500000'  # New value
            },
            ...
        ]
        """
        scenario_overrides = []
        for override in overrides:
            if not any([override.get('asset_id'), override.get('liability_id'), 
                       override.get('inflow_outflow_id'), override.get('retirement_income_plan_id')]):
                raise ValueError("Override must have a valid target")
            scenario_override = ScenarioOverride(
                scenario_id=scenario_id,
                **override
            )
            self.session.add(scenario_override)
            scenario_overrides.append(scenario_override)
        try:
            self.session.commit()
            return scenario_overrides
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to create overrides", orig=e)
    def add_override(self, scenario_id: int, override_field: str, override_value: str,
                     asset_id: Optional[int] = None, liability_id: Optional[int] = None,
                     inflow_outflow_id: Optional[int] = None, retirement_income_plan_id: Optional[int] = None) -> ScenarioOverride:
        """Adds an override to a scenario for a specific financial component."""
        if not any([asset_id, liability_id, inflow_outflow_id, retirement_income_plan_id]):
            raise ValueError("Override must have a valid target")
        override = ScenarioOverride(
            scenario_id=scenario_id, 
            override_field=override_field, 
            override_value=override_value,
            asset_id=asset_id, 
            liability_id=liability_id, 
            inflow_outflow_id=inflow_outflow_id,
            retirement_income_plan_id=retirement_income_plan_id
        )
        try:
            self.session.add(override)
            self.session.commit()
            return override
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to create override", orig=e)
    def get_scenario(self, scenario_id: int, include_assumptions: bool = False, include_overrides: bool = False) -> Optional[Scenario]:
        """Retrieves a scenario by ID, optionally loading assumptions and overrides."""
        stmt = select(Scenario).where(Scenario.scenario_id == scenario_id)
        if include_assumptions:
            stmt = stmt.options(joinedload(Scenario.assumptions))
        if include_overrides:
            stmt = stmt.options(joinedload(Scenario.overrides))
        return self.session.execute(stmt).scalar_one_or_none()
    def get_plan_scenarios(self, plan_id: int) -> List[Scenario]:
        """Returns all scenarios linked to a plan."""
        return list(self.session.execute(select(Scenario).where(Scenario.plan_id == plan_id)).scalars().all())
    def update_scenario(self, scenario_id: int, update_data: Dict[str, Any],
                        assumption_updates: Optional[Dict[str, Any]] = None) -> Optional[Scenario]:
        """Updates a scenario and its assumptions if provided."""
        try:
            scenario = self.session.execute(
                update(Scenario).where(Scenario.scenario_id == scenario_id).values(**update_data).returning(Scenario)
            ).scalar_one_or_none()
            if not scenario:
                return None
            if assumption_updates:
                if 'default_growth_rate' in assumption_updates:
                    validate_rate(assumption_updates['default_growth_rate'], "default_growth_rate")
                if 'inflation_rate' in assumption_updates:
                    validate_rate(assumption_updates['inflation_rate'], "inflation_rate")
                if 'annual_retirement_spending' in assumption_updates:
                    validate_positive_amount(assumption_updates['annual_retirement_spending'], "annual_retirement_spending")
                self.session.execute(update(ScenarioAssumption).where(ScenarioAssumption.scenario_id == scenario_id).values(**assumption_updates))
            self.session.commit()
            return scenario
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to update scenario", orig=e)
    def update_override(self, override_id: int, override_field: str, override_value: str) -> Optional[ScenarioOverride]:
        """Updates an existing override's field and value."""
        try:
            result = self.session.execute(
                update(ScenarioOverride)
                .where(ScenarioOverride.override_id == override_id)
                .values(override_field=override_field, override_value=override_value)
                .returning(ScenarioOverride)
            )
            self.session.commit()
            return result.scalar_one_or_none()
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to update override", orig=e)
    def remove_override(self, override_id: int) -> bool:
        """Deletes a specific scenario override."""
        result = self.session.execute(delete(ScenarioOverride).where(ScenarioOverride.override_id == override_id))
        self.session.commit()
        return result.rowcount > 0
    def delete_scenario(self, scenario_id: int) -> bool:
        """Deletes a scenario by ID."""
        result = self.session.execute(delete(Scenario).where(Scenario.scenario_id == scenario_id))
        self.session.commit()
        return result.rowcount > 0
    def get_scenario_summary(self, scenario_id: int) -> Optional[Dict[str, Any]]:
        """Returns a summary of a scenario, including override counts."""
        scenario = self.get_scenario(scenario_id, include_assumptions=True, include_overrides=True)
        if not scenario:
            return None
        return {
            'scenario_id': scenario.scenario_id,
            'scenario_name': scenario.scenario_name,
            'plan_id': scenario.plan_id,
            'has_assumptions': scenario.assumptions is not None,
            'override_counts': {
                'asset_overrides': sum(1 for o in scenario.overrides if o.asset_id),
                'liability_overrides': sum(1 for o in scenario.overrides if o.liability_id),
                'cash_flow_overrides': sum(1 for o in scenario.overrides if o.inflow_outflow_id),
                'retirement_income_overrides': sum(1 for o in scenario.overrides if o.retirement_income_plan_id)
            },
            'created_at': scenario.created_at
        }
```

######## backend/database_operations/crud/__init__.py ########
```

```

######## backend/database_operations/crud/financial/assets_crud.py ########
```
# backend/database_operations/crud/financial/assets.py
"""
Full CRUD operations for assets following SQLAlchemy 2.0 style
Support for all three types of growth rate configurations:
Default (no override)
Simple override
Stepwise configuration
Proper validation of:
Asset values (positive)
Growth rates
Stepwise period configuration
Owner values
Comprehensive asset summary including growth configuration
Support for filtering assets by category
Proper error handling and transaction management
Clean handling of growth rate configuration updates
"""
from typing import List, Optional, Dict, Any, Union
from decimal import Decimal
from sqlalchemy import select, update, delete, and_
from sqlalchemy.orm import Session, joinedload
from sqlalchemy.exc import IntegrityError, NoResultFound
from ...models import Asset, AssetCategory, GrowthRateConfiguration, Plan
from ...validation.money_validation import validate_positive_amount, validate_rate, validate_owner
from ...utils.money_utils import to_decimal, to_float
from ...validation.growth_validation import validate_stepwise_periods, validate_growth_config_type
from ...validation.time_validation import validate_year_not_before_plan_creation
class AssetCRUD:
    """Handles CRUD operations for assets and growth rates."""
    def __init__(self, session: Session):
        self.session = session
    def create_asset(self, plan_id: int, asset_category_id: int, asset_name: str, value: Union[float, str, Decimal],
                     owner: str, include_in_nest_egg: bool = True, growth_config: Optional[Dict[str, Any]] = None) -> Asset:
        """Creates an asset with optional growth configuration."""
        if not self.session.execute(select(Plan).join(AssetCategory).where(
                and_(Plan.plan_id == plan_id, AssetCategory.asset_category_id == asset_category_id))).scalar_one_or_none():
            raise NoResultFound(f"Plan {plan_id} or category {asset_category_id} not found")
        decimal_value = to_decimal(value)
        validate_positive_amount(decimal_value, "asset_value")
        validate_owner(owner, "owner")
        asset = Asset(
            plan_id=plan_id, asset_category_id=asset_category_id, asset_name=asset_name,
            value=to_float(decimal_value), owner=owner, include_in_nest_egg=include_in_nest_egg
        )
        try:
            self.session.add(asset)
            self.session.flush()
            if growth_config:
                self._add_growth_configuration(asset.asset_id, growth_config)
            self.session.commit()
            return asset
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to create asset", orig=e)
    def get_asset(self, asset_id: int, include_growth_config: bool = False) -> Optional[Asset]:
        """Retrieves an asset by ID."""
        stmt = select(Asset).where(Asset.asset_id == asset_id)
        if include_growth_config:
            stmt = stmt.options(joinedload(Asset.growth_rates))
        return self.session.execute(stmt).scalar_one_or_none()
    def get_plan_assets(self, plan_id: int, category_id: Optional[int] = None) -> List[Asset]:
        """Retrieves all assets for a plan, optionally filtered by category."""
        stmt = select(Asset).where(Asset.plan_id == plan_id)
        if category_id:
            stmt = stmt.where(Asset.asset_category_id == category_id)
        return list(self.session.execute(stmt).scalars().all())
    def update_asset(self, asset_id: int, update_data: Dict[str, Any],
                     growth_config: Optional[Dict[str, Any]] = None) -> Optional[Asset]:
        """Updates an asset and its growth configuration if provided."""
        if "value" in update_data:
            decimal_value = to_decimal(update_data["value"])
            validate_positive_amount(decimal_value, "asset_value")
            update_data["value"] = to_float(decimal_value)
        if "owner" in update_data:
            validate_owner(update_data["owner"], "owner")
        try:
            result = self.session.execute(update(Asset)
                                          .where(Asset.asset_id == asset_id)
                                          .values(**update_data)
                                          .returning(Asset))
            asset = result.scalar_one_or_none()
            if asset and growth_config:
                self.session.execute(delete(GrowthRateConfiguration).where(GrowthRateConfiguration.asset_id == asset_id))
                self._add_growth_configuration(asset_id, growth_config)
            self.session.commit()
            return asset
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to update asset", orig=e)
    def delete_asset(self, asset_id: int) -> bool:
        """Deletes an asset by ID."""
        result = self.session.execute(delete(Asset).where(Asset.asset_id == asset_id))
        self.session.commit()
        return result.rowcount > 0
    def _add_growth_configuration(self, asset_id: int, config: Dict[str, Any]) -> None:
        """Adds a growth rate configuration for an asset."""
        plan = self.session.execute(select(Plan).join(Asset).where(Asset.asset_id == asset_id)).scalar_one()
        if not plan.plan_creation_year:
            raise ValueError("Plan creation year must be set before configuring growth rates")
        config_type = config.get("configuration_type")
        validate_growth_config_type(config_type, "configuration_type")
        if config_type == "STEPWISE":
            periods = config.get("periods", [])
            for period in periods:
                if not validate_year_not_before_plan_creation(period["start_year"], plan.plan_creation_year):
                    raise ValueError(f"Growth period cannot start before plan creation year {plan.plan_creation_year}")
            validate_stepwise_periods(periods, "growth_periods")
            for period in periods:
                validate_rate(to_decimal(period["growth_rate"]), "growth_rate")
                self.session.add(GrowthRateConfiguration(
                    asset_id=asset_id, configuration_type="STEPWISE",
                    start_year=period["start_year"], end_year=period["end_year"],
                    growth_rate=to_float(to_decimal(period["growth_rate"]))
                ))
        else:
            validate_rate(to_decimal(config["growth_rate"]), "growth_rate")
            self.session.add(GrowthRateConfiguration(
                asset_id=asset_id, configuration_type=config_type,
                start_year=plan.plan_creation_year, end_year=config.get("end_year"),
                growth_rate=to_float(to_decimal(config["growth_rate"]))
            ))
    def get_asset_summary(self, asset_id: int) -> Optional[Dict[str, Any]]:
        """Returns a summary of an asset, including growth configuration."""
        asset = self.get_asset(asset_id, include_growth_config=True)
        if not asset:
            return None
        growth_config = None
        if asset.growth_rates:
            if len(asset.growth_rates) == 1:
                config = asset.growth_rates[0]
                growth_config = {"type": config.configuration_type, "rate": config.growth_rate}
            else:
                growth_config = {
                    "type": "STEPWISE",
                    "periods": [{"start_year": config.start_year, "end_year": config.end_year, "rate": config.growth_rate}
                                for config in sorted(asset.growth_rates, key=lambda x: x.start_year)]
                }
        return {
            "asset_id": asset.asset_id,
            "asset_name": asset.asset_name,
            "category_id": asset.asset_category_id,
            "value": asset.value,
            "owner": asset.owner,
            "include_in_nest_egg": asset.include_in_nest_egg,
            "growth_configuration": growth_config
        }
```

######## backend/database_operations/crud/financial/cash_flows_crud.py ########
```
# backend/database_operations/crud/financial/cash_flows_crud.py
"""
Full CRUD operations for cash flows following SQLAlchemy 2.0 style.
Handles discrete event cash flows (like college expenses or inheritances).
Core functionality:
- Create/update/delete cash flows
- Basic validation
- Support for single-year and multi-year discrete events
- Optional inflation adjustment
"""
from typing import List, Optional, Dict, Any
from sqlalchemy import select, update, delete
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError, NoResultFound
from ...models import InflowOutflow, Plan
from ...validation.money_validation import validate_positive_amount
from ...validation.time_validation import validate_year_not_before_plan_creation
from ...utils.time_utils import get_years_between
class CashFlowCRUD:
    """Handles CRUD operations for inflow/outflow management."""
    def __init__(self, session: Session):
        self.session = session
    def create_cash_flow(self, plan_id: int, name: str, flow_type: str, annual_amount: float, start_year: int,
                         end_year: Optional[int] = None, apply_inflation: bool = False) -> InflowOutflow:
        """Creates a cash flow event for a financial plan."""
        plan = self.session.execute(select(Plan).where(Plan.plan_id == plan_id)).scalar_one_or_none()
        if not plan:
            raise NoResultFound(f"Plan {plan_id} not found")
        if flow_type not in {"inflow", "outflow"}:
            raise ValueError("Type must be 'inflow' or 'outflow'")
        validate_positive_amount(annual_amount, "annual_amount")
        end_year = end_year or start_year
        if not validate_year_not_before_plan_creation(start_year, plan.plan_creation_year):
            raise ValueError("Start year cannot be before plan creation year")
        if start_year > end_year:
            raise ValueError("Start year must be before or equal to end year")
        if get_years_between(start_year, end_year) > 30:
            raise ValueError("Cash flows must be limited duration events")
        cash_flow = InflowOutflow(
            plan_id=plan_id, name=name, type=flow_type, annual_amount=annual_amount,
            start_year=start_year, end_year=end_year, apply_inflation=apply_inflation
        )
        try:
            self.session.add(cash_flow)
            self.session.commit()
            return cash_flow
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to create cash flow", orig=e)
    def get_cash_flow(self, flow_id: int) -> Optional[InflowOutflow]:
        """Retrieves a cash flow by ID."""
        return self.session.execute(select(InflowOutflow).where(
            InflowOutflow.inflow_outflow_id == flow_id)).scalar_one_or_none()
    def get_plan_cash_flows(self, plan_id: int, flow_type: Optional[str] = None,
                            year: Optional[int] = None) -> List[InflowOutflow]:
        """Retrieves cash flows for a plan, optionally filtered by type and year."""
        stmt = select(InflowOutflow).where(InflowOutflow.plan_id == plan_id)
        if flow_type:
            stmt = stmt.where(InflowOutflow.type == flow_type)
        if year:
            stmt = stmt.where(InflowOutflow.start_year <= year, InflowOutflow.end_year >= year)
        return list(self.session.execute(stmt).scalars().all())
    def update_cash_flow(self, flow_id: int, update_data: Dict[str, Any]) -> Optional[InflowOutflow]:
        """Updates a cash flow event."""
        if "annual_amount" in update_data:
            validate_positive_amount(update_data["annual_amount"], "annual_amount")
        if "type" in update_data and update_data["type"] not in {"inflow", "outflow"}:
            raise ValueError("Type must be 'inflow' or 'outflow'")
        if "start_year" in update_data or "end_year" in update_data:
            current_flow = self.get_cash_flow(flow_id)
            if not current_flow:
                return None
            start_year = update_data.get("start_year", current_flow.start_year)
            end_year = update_data.get("end_year", current_flow.end_year)
            if start_year > end_year:
                raise ValueError("Start year must be before or equal to end year")
            if end_year - start_year > 30:
                raise ValueError("Cash flows must be limited duration events")
        try:
            result = self.session.execute(update(InflowOutflow)
                                          .where(InflowOutflow.inflow_outflow_id == flow_id)
                                          .values(**update_data)
                                          .returning(InflowOutflow))
            self.session.commit()
            return result.scalar_one_or_none()
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to update cash flow", orig=e)
    def delete_cash_flow(self, flow_id: int) -> bool:
        """Deletes a cash flow event."""
        result = self.session.execute(delete(InflowOutflow).where(
            InflowOutflow.inflow_outflow_id == flow_id))
        self.session.commit()
        return result.rowcount > 0
```

######## backend/database_operations/crud/financial/growth_rates_crud.py ########
```
# backend/database_operations/crud/financial/growth_rates.py
"""
Full CRUD operations for growth configurations following SQLAlchemy 2.0 style
Support for all three configuration types:
Default (base rate)
Override (fixed rate)
Stepwise (multiple periods)
Proper validation of:
Configuration types
Growth rates
Year sequences
Target specification
Support for multiple targets:
Assets
Retirement income
Scenarios
Special handling for stepwise configurations
Comprehensive configuration summary
Utility for determining applicable rate
Proper error handling and transaction management
"""
from typing import List, Optional, Dict, Any
from sqlalchemy import select, update, delete, and_
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
from ...models import GrowthRateConfiguration, Asset, RetirementIncomePlan, Scenario
from ...validation.money_validation import validate_rate
from ...validation.growth_validation import validate_stepwise_periods, validate_growth_config_type
from ...validation.time_validation import validate_year_not_before_plan_creation
class GrowthRateCRUD:
    """Handles CRUD operations for growth rate configurations."""
    def __init__(self, session: Session):
        self.session = session
    def create_growth_config(self, configuration_type: str, start_year: int, growth_rate: float,
                             end_year: Optional[int] = None, asset_id: Optional[int] = None,
                             retirement_income_plan_id: Optional[int] = None,
                             scenario_id: Optional[int] = None) -> GrowthRateConfiguration:
        """Creates a growth rate configuration for an asset, retirement income, or scenario."""
        validate_growth_config_type(configuration_type, "configuration_type")
        if sum(x is not None for x in [asset_id, retirement_income_plan_id, scenario_id]) != 1:
            raise ValueError("Must specify exactly one target (asset, retirement income, or scenario)")
        validate_rate(growth_rate, "growth_rate")
        if end_year is not None and start_year > end_year:
            raise ValueError("Start year must be before or equal to end year")
        config = GrowthRateConfiguration(
            configuration_type=configuration_type, start_year=start_year, end_year=end_year,
            growth_rate=growth_rate, asset_id=asset_id, retirement_income_plan_id=retirement_income_plan_id,
            scenario_id=scenario_id
        )
        try:
            self.session.add(config)
            self.session.commit()
            return config
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to create growth configuration", orig=e)
    def create_stepwise_config(self, periods: List[Dict[str, Any]], asset_id: Optional[int] = None,
                               retirement_income_plan_id: Optional[int] = None,
                               scenario_id: Optional[int] = None) -> List[GrowthRateConfiguration]:
        """Creates multiple stepwise growth rate configurations."""
        if sum(x is not None for x in [asset_id, retirement_income_plan_id, scenario_id]) != 1:
            raise ValueError("Must specify exactly one target (asset, retirement income, or scenario)")
        if not validate_stepwise_periods([(p["start_year"], p["end_year"]) for p in periods]):
            raise ValueError("Stepwise periods must be chronological and non-overlapping")
        for period in periods:
            validate_rate(period["growth_rate"], "growth_rate")
        try:
            configs = [GrowthRateConfiguration(
                configuration_type="STEPWISE", start_year=p["start_year"], end_year=p["end_year"],
                growth_rate=p["growth_rate"], asset_id=asset_id, retirement_income_plan_id=retirement_income_plan_id,
                scenario_id=scenario_id
            ) for p in periods]
            self.session.add_all(configs)
            self.session.commit()
            return configs
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to create stepwise configurations", orig=e)
    def get_growth_config(self, config_id: int) -> Optional[GrowthRateConfiguration]:
        """Retrieves a growth configuration by ID."""
        return self.session.execute(select(GrowthRateConfiguration).where(
            GrowthRateConfiguration.growth_rate_id == config_id)).scalar_one_or_none()
    def get_configurations_for_target(self, target_type: str, target_id: int) -> List[GrowthRateConfiguration]:
        """Retrieves all growth configurations for a given target."""
        target_map = {
            "asset": GrowthRateConfiguration.asset_id,
            "retirement_income": GrowthRateConfiguration.retirement_income_plan_id,
            "scenario": GrowthRateConfiguration.scenario_id
        }
        if target_type not in target_map:
            raise ValueError("Invalid target type")
        return list(self.session.execute(select(GrowthRateConfiguration)
                                         .where(target_map[target_type] == target_id)
                                         .order_by(GrowthRateConfiguration.start_year)).scalars().all())
    def update_growth_config(self, config_id: int, update_data: Dict[str, Any]) -> Optional[GrowthRateConfiguration]:
        """Updates a growth configuration."""
        if "configuration_type" in update_data and update_data["configuration_type"] not in {"DEFAULT", "OVERRIDE", "STEPWISE"}:
            raise ValueError("Invalid configuration type")
        if "growth_rate" in update_data:
            validate_rate(update_data["growth_rate"], "growth_rate")
        if "start_year" in update_data or "end_year" in update_data:
            config = self.get_growth_config(config_id)
            if not config:
                return None
            start_year = update_data.get("start_year", config.start_year)
            end_year = update_data.get("end_year", config.end_year)
            if end_year is not None and start_year > end_year:
                raise ValueError("Start year must be before or equal to end year")
        try:
            result = self.session.execute(update(GrowthRateConfiguration)
                                          .where(GrowthRateConfiguration.growth_rate_id == config_id)
                                          .values(**update_data)
                                          .returning(GrowthRateConfiguration))
            self.session.commit()
            return result.scalar_one_or_none()
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to update growth configuration", orig=e)
    def delete_growth_config(self, config_id: int) -> bool:
        """Deletes a growth configuration."""
        result = self.session.execute(delete(GrowthRateConfiguration)
                                      .where(GrowthRateConfiguration.growth_rate_id == config_id))
        self.session.commit()
        return result.rowcount > 0
    def get_growth_config_summary(self, config_id: int) -> Optional[Dict[str, Any]]:
        """Returns a summary of a growth configuration."""
        config = self.get_growth_config(config_id)
        if not config:
            return None
        target_type, target_id = None, None
        if config.asset_id:
            target_type, target_id = "asset", config.asset_id
        elif config.retirement_income_plan_id:
            target_type, target_id = "retirement_income", config.retirement_income_plan_id
        elif config.scenario_id:
            target_type, target_id = "scenario", config.scenario_id
        return {
            "config_id": config.growth_rate_id,
            "type": config.configuration_type,
            "growth_rate": config.growth_rate,
            "start_year": config.start_year,
            "end_year": config.end_year,
            "target_type": target_type,
            "target_id": target_id,
            "is_stepwise": config.configuration_type == "STEPWISE"
        }
    def get_applicable_rate(self, year: int, target_type: str, target_id: int, default_rate: float) -> float:
        """Returns the applicable growth rate for a specific year."""
        for config in self.get_configurations_for_target(target_type, target_id):
            if config.start_year <= year and (config.end_year is None or config.end_year >= year):
                return config.growth_rate
        return default_rate
```

######## backend/database_operations/crud/financial/liabilities_crud.py ########
```
# backend/database_operations/crud/financial/liabilities_crud.py
"""
Full CRUD operations for liabilities following SQLAlchemy 2.0 style
Simple interest rate handling (vs. complex growth rates for assets)
Proper validation of:
Liability values (positive)
Interest rates (if provided)
Owner values
Support for filtering liabilities by category
Comprehensive liability summary
Additional utility for calculating total liabilities
Proper error handling and transaction management
Support for nest egg inclusion/exclusion
The key difference from assets.py is the simpler growth model - liabilities just have an optional interest rate rather than the complex growth rate configurations used for assets.
"""
from datetime import datetime
from typing import List, Optional, Dict, Any
from sqlalchemy import select, update, delete, and_
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError, NoResultFound
from ...models import Liability, LiabilityCategory, Plan
from ...validation.money_validation import validate_positive_amount, validate_rate, validate_owner
class LiabilityCRUD:
    """Handles CRUD operations for liabilities."""
    def __init__(self, session: Session):
        self.session = session
    def create_liability(self, plan_id: int, liability_category_id: int, liability_name: str, value: float, owner: str,
                         interest_rate: Optional[float] = None, include_in_nest_egg: bool = True) -> Liability:
        """Creates a liability linked to a plan and category."""
        stmt = select(Plan).join(LiabilityCategory).where(
            and_(Plan.plan_id == plan_id, LiabilityCategory.liability_category_id == liability_category_id)
        )
        if not self.session.execute(stmt).scalar_one_or_none():
            raise NoResultFound(f"Plan {plan_id} or category {liability_category_id} not found")
        validate_positive_amount(value, "liability_value")
        if interest_rate is not None:
            validate_rate(interest_rate, "interest_rate")
        validate_owner(owner, "owner")
        liability = Liability(
            plan_id=plan_id, liability_category_id=liability_category_id, liability_name=liability_name,
            value=value, owner=owner, interest_rate=interest_rate, include_in_nest_egg=include_in_nest_egg
        )
        try:
            self.session.add(liability)
            self.session.commit()
            return liability
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to create liability", orig=e)
    def get_liability(self, liability_id: int) -> Optional[Liability]:
        """Retrieves a liability by ID."""
        return self.session.execute(
            select(Liability).join(Plan).where(Liability.liability_id == liability_id)
        ).scalar_one_or_none()
    def get_plan_liabilities(self, plan_id: int, category_id: Optional[int] = None) -> List[Liability]:
        """Returns all liabilities for a plan, optionally filtered by category."""
        stmt = select(Liability).join(Plan).where(Liability.plan_id == plan_id)
        if category_id:
            stmt = stmt.where(Liability.liability_category_id == category_id)
        return list(self.session.execute(stmt).scalars().all())
    def update_liability(self, liability_id: int, update_data: Dict[str, Any]) -> Optional[Liability]:
        """Updates a liability."""
        if 'value' in update_data:
            validate_positive_amount(update_data['value'], "liability_value")
        if 'interest_rate' in update_data and update_data['interest_rate'] is not None:
            validate_rate(update_data['interest_rate'], "interest_rate")
        if 'owner' in update_data and update_data['owner'] not in {"person1", "person2", "joint"}:
            raise ValueError("Invalid owner value")
        try:
            stmt = update(Liability).where(Liability.liability_id == liability_id).values(**update_data).returning(Liability)
            result = self.session.execute(stmt)
            self.session.commit()
            return result.scalar_one_or_none()
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to update liability", orig=e)
    def delete_liability(self, liability_id: int) -> bool:
        """Deletes a liability by ID."""
        result = self.session.execute(delete(Liability).where(Liability.liability_id == liability_id))
        self.session.commit()
        return result.rowcount > 0
    def get_liability_summary(self, liability_id: int) -> Optional[Dict[str, Any]]:
        """Returns a summary of a liability, including plan creation year."""
        result = self.session.execute(
            select(Liability, Plan.plan_creation_year).join(Plan).where(Liability.liability_id == liability_id)
        ).first()
        if not result:
            return None
        liability, plan_creation_year = result
        return {
            'liability_id': liability.liability_id,
            'liability_name': liability.liability_name,
            'category_id': liability.liability_category_id,
            'value': liability.value,
            'owner': liability.owner,
            'interest_rate': liability.interest_rate,
            'include_in_nest_egg': liability.include_in_nest_egg,
            'has_interest': liability.interest_rate is not None,
            'plan_creation_year': plan_creation_year
        }
    def get_total_liabilities(self, plan_id: int, include_in_nest_egg_only: bool = False) -> float:
        """Calculates total liability value for a plan."""
        stmt = select(Liability).join(Plan).where(Liability.plan_id == plan_id)
        if include_in_nest_egg_only:
            stmt = stmt.where(Liability.include_in_nest_egg.is_(True))
        liabilities = self.session.execute(stmt).scalars().all()
        return sum(liability.value for liability in liabilities)
```

######## backend/database_operations/crud/financial/retirement_income_crud.py ########
```
# backend/database_operations/crud/financial/retirement.py
"""
Full CRUD operations for retirement income following SQLAlchemy 2.0 style
Support for optional growth rate configuration
Proper validation of:
Income amounts (positive)
Owner values
Age sequence
Support for:
Filtering by owner
Inflation toggle
Nest egg inclusion/exclusion
Optional end age
Comprehensive income summary including:
Duration calculation
Lifetime income detection
Growth rate presence
Additional utility for calculating total income at specific age
Proper error handling and transaction management
"""
from typing import List, Optional, Dict, Any
from sqlalchemy import select, update, delete
from sqlalchemy.orm import Session, joinedload
from sqlalchemy.exc import IntegrityError, NoResultFound
from ...models import RetirementIncomePlan, Plan, GrowthRateConfiguration
from ...validation.money_validation import validate_positive_amount, validate_rate
from ...validation.time_validation import validate_positive_age, validate_age_sequence
from ...utils.time_utils import get_age_in_year
class RetirementIncomeCRUD:
    """Handles CRUD operations for retirement income plans."""
    def __init__(self, session: Session):
        self.session = session
    def create_retirement_income(self, plan_id: int, name: str, owner: str, annual_income: float, start_age: int,
                                 end_age: Optional[int] = None, include_in_nest_egg: bool = True,
                                 apply_inflation: bool = False, growth_config: Optional[Dict[str, Any]] = None) -> RetirementIncomePlan:
        """Creates a retirement income plan."""
        if not self.session.execute(select(Plan).where(Plan.plan_id == plan_id)).scalar_one_or_none():
            raise NoResultFound(f"Plan {plan_id} not found")
        validate_positive_amount(annual_income, "annual_income")
        if owner not in {"person1", "person2", "joint"}:
            raise ValueError("Invalid owner value")
        if not validate_positive_age(start_age):
            raise ValueError("Start age must be positive")
        if end_age is not None:
            if not validate_positive_age(end_age):
                raise ValueError("End age must be positive")
            if not validate_age_sequence(start_age, start_age, end_age):
                raise ValueError("Start age must be before or equal to end age")
        income_plan = RetirementIncomePlan(
            plan_id=plan_id, name=name, owner=owner, annual_income=annual_income, start_age=start_age,
            end_age=end_age, include_in_nest_egg=include_in_nest_egg, apply_inflation=apply_inflation
        )
        try:
            self.session.add(income_plan)
            self.session.flush()
            if growth_config:
                self._add_growth_configuration(income_plan.income_plan_id, growth_config)
            self.session.commit()
            return income_plan
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to create retirement income plan", orig=e)
    def get_retirement_income(self, income_id: int, include_growth_config: bool = False) -> Optional[RetirementIncomePlan]:
        """Retrieves a retirement income plan by ID."""
        stmt = select(RetirementIncomePlan).where(RetirementIncomePlan.income_plan_id == income_id)
        if include_growth_config:
            stmt = stmt.options(joinedload(RetirementIncomePlan.growth_rates))
        return self.session.execute(stmt).scalar_one_or_none()
    def get_plan_retirement_income(self, plan_id: int, owner: Optional[str] = None) -> List[RetirementIncomePlan]:
        """Returns all retirement income plans for a plan, optionally filtered by owner."""
        stmt = select(RetirementIncomePlan).where(RetirementIncomePlan.plan_id == plan_id)
        if owner:
            stmt = stmt.where(RetirementIncomePlan.owner == owner)
        return list(self.session.execute(stmt).scalars().all())
    def update_retirement_income(self, income_id: int, update_data: Dict[str, Any],
                                 growth_config: Optional[Dict[str, Any]] = None) -> Optional[RetirementIncomePlan]:
        """Updates a retirement income plan."""
        if 'annual_income' in update_data:
            validate_positive_amount(update_data['annual_income'], "annual_income")
        if 'owner' in update_data and update_data['owner'] not in {"person1", "person2", "joint"}:
            raise ValueError("Invalid owner value")
        if 'start_age' in update_data or 'end_age' in update_data:
            current_income = self.get_retirement_income(income_id)
            if not current_income:
                return None
            start_age = update_data.get('start_age', current_income.start_age)
            end_age = update_data.get('end_age', current_income.end_age)
            if end_age is not None and not validate_age_sequence(start_age, start_age, end_age):
                raise ValueError("Start age must be before or equal to end age")
        try:
            stmt = update(RetirementIncomePlan).where(RetirementIncomePlan.income_plan_id == income_id).values(**update_data).returning(RetirementIncomePlan)
            result = self.session.execute(stmt)
            income_plan = result.scalar_one_or_none()
            if not income_plan:
                return None
            if growth_config:
                self.session.execute(delete(GrowthRateConfiguration).where(GrowthRateConfiguration.retirement_income_plan_id == income_id))
                self._add_growth_configuration(income_id, growth_config)
            self.session.commit()
            return income_plan
        except IntegrityError as e:
            self.session.rollback()
            raise IntegrityError("Failed to update retirement income plan", orig=e)
    def delete_retirement_income(self, income_id: int) -> bool:
        """Deletes a retirement income plan."""
        result = self.session.execute(delete(RetirementIncomePlan).where(RetirementIncomePlan.income_plan_id == income_id))
        self.session.commit()
        return result.rowcount > 0
    def _add_growth_configuration(self, income_id: int, config: Dict[str, Any]) -> None:
        """Adds a growth rate configuration for a retirement income plan."""
        validate_rate(config.get('growth_rate'), "growth_rate")
        self.session.add(GrowthRateConfiguration(
            retirement_income_plan_id=income_id, configuration_type='OVERRIDE',
            start_year=config.get('start_year'), end_year=config.get('end_year'), growth_rate=config.get('growth_rate')
        ))
    def get_retirement_income_summary(self, income_id: int, include_years: bool = False) -> Optional[Dict[str, Any]]:
        """Returns a summary of a retirement income plan."""
        income = self.get_retirement_income(income_id, include_growth_config=True)
        if not income:
            return None
        summary = {
            'income_id': income.income_plan_id,
            'name': income.name,
            'owner': income.owner,
            'annual_income': income.annual_income,
            'start_age': income.start_age,
            'end_age': income.end_age,
            'include_in_nest_egg': income.include_in_nest_egg,
            'apply_inflation': income.apply_inflation,
            'has_growth_rate': bool(income.growth_rates)
        }
        if include_years:
            summary.update({
                'duration': (income.end_age - income.start_age + 1) if income.end_age else None,
                'is_lifetime': income.end_age is None
            })
        return summary
    def get_total_retirement_income(self, plan_id: int, age: int, include_in_nest_egg_only: bool = False) -> float:
        """Calculates total retirement income at a specific age."""
        stmt = select(RetirementIncomePlan).where(RetirementIncomePlan.plan_id == plan_id, RetirementIncomePlan.start_age <= age)
        if include_in_nest_egg_only:
            stmt = stmt.where(RetirementIncomePlan.include_in_nest_egg.is_(True))
        income_plans = self.session.execute(stmt).scalars().all()
        return sum(plan.annual_income for plan in income_plans if plan.end_age is None or plan.end_age >= age)
```

######## backend/database_operations/crud/financial/__init__.py ########
```
"""
Financial components CRUD operations.
This package contains modules for managing different types of financial components:
- assets: Asset categories and assets
- liabilities: Liability categories and liabilities
- cash_flows: Inflows and outflows
- retirement: Retirement income plans
- growth_rates: Growth rate configurations
"""
from .assets_crud import *
from .liabilities_crud import *
from .cash_flows_crud import *
from .retirement_income_crud import *
from .growth_rates_crud import * 
```

######## backend/database_operations/utils/money_utils.py ########
```
# backend/database_operations/utils/money_utils.py
from typing import Union, List
from decimal import Decimal, ROUND_HALF_UP, InvalidOperation, Context
# Precision settings
CALCULATION_PRECISION = 8
DISPLAY_PRECISION = 2
CALCULATION_CONTEXT = Context(prec=CALCULATION_PRECISION, rounding=ROUND_HALF_UP)
def to_decimal(amount: Union[float, str, Decimal]) -> Decimal:
    """Converts amount to Decimal with high precision."""
    try:
        return CALCULATION_CONTEXT.create_decimal(str(amount)) if not isinstance(amount, Decimal) else CALCULATION_CONTEXT.create_decimal(amount)
    except (InvalidOperation, ValueError) as e:
        raise ValueError(f"Invalid decimal conversion: {amount}") from e
def to_float(amount: Decimal) -> float:
    """Converts Decimal to float with 2 decimal place rounding."""
    return float(round_to_currency(amount))
def apply_annual_compound_rate(principal: Decimal, rate: Decimal) -> Decimal:
    """Applies annual compound rate to principal."""
    try:
        return principal * (to_decimal('1') + to_decimal(rate))
    except (InvalidOperation, ValueError) as e:
        raise ValueError(f"Invalid compound calculation: principal={principal}, rate={rate}") from e
def apply_annual_inflation(amount: Decimal, inflation_rate: Decimal) -> Decimal:
    """Adjusts amount for annual inflation."""
    return apply_annual_compound_rate(amount, inflation_rate)
def combine_amounts(amounts: List[Decimal]) -> Decimal:
    """Sums multiple Decimal amounts with precision."""
    try:
        return sum((to_decimal(amt) for amt in amounts), to_decimal('0'))
    except (InvalidOperation, ValueError) as e:
        raise ValueError(f"Invalid amounts for combination: {amounts}") from e
def round_to_currency(amount: Decimal) -> Decimal:
    """Rounds amount to 2 decimal places."""
    try:
        return amount.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
    except (InvalidOperation, ValueError) as e:
        raise ValueError(f"Invalid currency rounding: {amount}") from e
```

######## backend/database_operations/utils/time_utils.py ########
```
# backend/database_operations/utils/time_utils.py
from datetime import date
from typing import Dict, Tuple
# Handles computed values (age, years, mappings). No validation logic.
def get_start_year(plan_creation_year: int) -> int:
    """Returns the start year for projections (same as plan creation year)."""
    return plan_creation_year
def get_age_in_year(dob: date, year: int) -> int:
    """Returns age in a given year, adjusting for whether the birthday has passed."""
    return year - dob.year - (1 if (year, 1, 1) <= (dob.year, dob.month, dob.day) else 0)
def get_year_for_age(dob: date, target_age: int) -> int:
    """Returns the year when a person reaches a target age."""
    return dob.year + target_age
def map_age_to_years(dob: date, start_year: int, end_year: int) -> Dict[int, int]:
    """Creates a dictionary mapping ages to years."""
    return {get_age_in_year(dob, year): year for year in range(start_year, end_year + 1)}
def map_years_to_ages(dob: date, start_year: int, end_year: int) -> Dict[int, int]:
    """Creates a dictionary mapping years to ages."""
    return {year: get_age_in_year(dob, year) for year in range(start_year, end_year + 1)}
def get_retirement_year(dob: date, retirement_age: int) -> int:
    """Returns the year when retirement begins."""
    return get_year_for_age(dob, retirement_age)
def get_final_projection_year(dob: date, final_age: int) -> int:
    """Returns the last year of financial projections."""
    return get_year_for_age(dob, final_age)
def get_projection_period(dob: date, plan_creation_year: int, final_age: int) -> Tuple[int, int]:
    """Returns (start_year, end_year) for a projection."""
    return get_start_year(plan_creation_year), get_final_projection_year(dob, final_age)
def get_years_between(start_year: int, end_year: int) -> int:
    """Returns the number of years between two given years, inclusive."""
    return max(0, end_year - start_year + 1)
```

######## backend/database_operations/utils/__init__.py ########
```

```

######## backend/database_operations/validation/growth_validation.py ########
```
# backend/database_operations/validation/growth_validation.py
from typing import List, Dict, Any
def validate_stepwise_periods(periods: List[Dict[str, Any]], field_name: str) -> None:
    """Raises ValueError if periods overlap or are not in chronological order."""
    if not periods:
        return
    sorted_periods = sorted(periods, key=lambda x: x['start_year'])
    for i in range(len(sorted_periods) - 1):
        current, next_period = sorted_periods[i], sorted_periods[i + 1]
        if current.get('end_year') is None and i < len(sorted_periods) - 1:
            raise ValueError(f"{field_name} has an open-ended period that is not last")
        if current.get('end_year') is not None and current['end_year'] >= next_period['start_year']:
            raise ValueError(f"{field_name} contains overlapping periods")
def validate_growth_config_type(config_type: str, field_name: str) -> None:
    """Raises ValueError if config_type is not 'DEFAULT', 'OVERRIDE', or 'STEPWISE'."""
    if config_type not in {"DEFAULT", "OVERRIDE", "STEPWISE"}:
        raise ValueError(f"{field_name} must be 'DEFAULT', 'OVERRIDE', or 'STEPWISE'")
```

######## backend/database_operations/validation/money_validation.py ########
```
# backend/database_operations/validation/money_validation.py
from typing import Union
from decimal import Decimal
def validate_positive_amount(amount: Union[float, Decimal], field_name: str) -> None:
    """Raises ValueError if amount is not a positive number."""
    if not isinstance(amount, (float, Decimal)):
        raise ValueError(f"{field_name} must be numeric")
    if amount <= 0:
        raise ValueError(f"{field_name} must be positive")
def validate_rate(rate: Union[float, Decimal], field_name: str) -> None:
    """Raises ValueError if rate is not numeric."""
    if not isinstance(rate, (float, Decimal)):
        raise ValueError(f"{field_name} must be numeric")
def validate_owner(owner: str, field_name: str) -> None:
    """Raises ValueError if owner is not 'person1', 'person2', or 'joint'."""
    if owner not in {"person1", "person2", "joint"}:
        raise ValueError(f"{field_name} must be 'person1', 'person2', or 'joint'")
```

######## backend/database_operations/validation/scenario_timeline_validation.py ########
```
# ## Core Validations
# 1. Date of birth must be a valid past date.  
# 2. Retirement year must be after the start year.  
# 3. End year must be after retirement year.  
# 4. Start year must be before end year for inflows/outflows.  
# 5. Scenario overrides cannot create invalid timelines.  
# 6. Stepwise growth periods must be in chronological order and not overlap.
# backend/database_operations/validation/scenario_timeline_validation.py
from datetime import date
from typing import Dict, Optional, List
from ..models import InflowOutflow, GrowthRateConfiguration, RetirementIncomePlan
from ..utils.time_utils import get_year_for_age
def validate_projection_timeline(
    start_year: int,
    retirement_year: int, 
    end_year: int
) -> bool:
    if not all(isinstance(year, int) for year in [start_year, retirement_year, end_year]):
        return False
    return start_year < retirement_year < end_year
def validate_scenario_override_timeline(
    base_timeline: Dict[str, int],
    override_timeline: Dict[str, int]
) -> bool:
    start_year = override_timeline.get('start_year', base_timeline['start_year'])
    retirement_year = override_timeline.get('retirement_year', base_timeline['retirement_year'])
    end_year = override_timeline.get('end_year', base_timeline['end_year'])
    return validate_projection_timeline(start_year, retirement_year, end_year)
def validate_scenario_timeline_consistency(
    flows: List[InflowOutflow],
    growth_configs: List[GrowthRateConfiguration],
    income_plans: List[RetirementIncomePlan],
    start_year: int,
    retirement_year: int,
    end_year: int
) -> bool:
    if not validate_projection_timeline(start_year, retirement_year, end_year):
        return False
    try:
        for flow in flows:
            if flow.start_year < start_year:
                return False
            if flow.end_year and flow.end_year > end_year:
                return False
        for config in growth_configs:
            if config.start_year < start_year:
                return False
            if config.end_year and config.end_year > end_year:
                return False
        for income in income_plans:
            income_start = get_year_for_age(income.dob, income.start_age)
            if income_start < start_year:
                return False
            if income.end_age:
                income_end = get_year_for_age(income.dob, income.end_age)
                if income_end > end_year:
                    return False
        return True
    except Exception:
        return False
```

######## backend/database_operations/validation/time_validation.py ########
```
# backend/database_operations/validation/time_validation.py
from datetime import date
# time_validation.py: Strictly for validation checks. No computed values.
def validate_dob(dob: date) -> bool:
    """Returns True if dob is in the past."""
    return dob < date.today()
def validate_positive_age(age: int) -> bool:
    """Returns True if an age is a valid positive number."""
    return age > 0
def validate_age_sequence(start_age: int, retirement_age: int, final_age: int) -> bool:
    """Returns True if the sequence is logically valid: start_age < retirement_age < final_age."""
    return start_age > 0 and start_age < retirement_age < final_age
def validate_year_range(year: int, start_year: int, end_year: int) -> bool:
    """Returns True if a year is within the valid projection range."""
    return start_year <= year <= end_year if start_year <= end_year else False
def validate_year_not_before_plan_creation(year: int, plan_creation_year: int) -> bool:
    """Returns True if the given year is not before plan creation."""
    return year >= plan_creation_year
# In time_validation.py
def validate_timeline(start_year: int, retirement_year: int, end_year: int) -> None:
    if not (start_year < retirement_year < end_year):
        raise ValueError("Timeline must flow: start_year < retirement_year < end_year")
```

